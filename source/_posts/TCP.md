---
title: TCP/IP协议详解
date: 2017-12-16
tags: 面试
categories: 网络
---


# TCP的三次握手和四次挥手

## 三次握手

TCP连接是通过三次握手来连接的。

**第一次握手**

当客户端向服务器发起连接请求时，客户端会发送同步序列标号`SYN`到服务器，在这里我们设`SYN`为m，等待服务器确认，这时客户端的状态为`SYN_SENT`。

<!-- more -->

**第二次握手**

当服务器收到客户端发送的`SYN`后，服务器要做的是确认客户端发送过来的`SYN`，在这里服务器发送确认包`ACK`，这里的`ACK`为m+1，意思是说“我收到了你发送的`SYN`了”，同时，服务器也会向客户端发送一个`SYN`包，这里我们设`SYN`为n。这时服务器的状态为`SYN_RECV`。

一句话，服务器端发送`SYN`和`ACK`两个包。

**第三次握手**

客户端收到服务器发送的`SYN`和`ACK`包后，需向服务器发送确认包`ACK`，“我也收到你发送的`SYN`了，我这就给你发个确认过去，然后我们即能合体了”，这里的`ACK`为n+1，发送完毕后，客户端和服务器的状态为`ESTABLISH`，即TCP连接成功。

在三次握手中，客户端和服务器端都发送两个包`SYN`和`ACK`，只不过服务器端的两个包是一次性发过来的，客户端的两个包是分两次发送的。

![](https://images.morethink.cn/092017231747399.jpg "TCP的三次握手和四次挥手")

## 四次挥手
当A端和B端要断开连接时，需要四次握手，这里称为四次挥手。

断开连接请求可以由客户端发出，也可以由服务器端发出，在这里我们称A端向B端请求断开连接。

**第一次挥手**

A端向B端请求断开连接时会向B端发送一个带有`FIN`标记的报文段，这里的`FIN`是`FIN`ish的意思。

**第二次挥手**

B端收到A发送的`FIN`后，B段现在可能现在还有数据没有传完，所以B端并不会马上向A端发送`FIN`，而是先发送一个确认序号`ACK`，意思是说“你发的断开连接请求我收到了，但是我现在还有数据没有发完，请稍等一下呗”。

**第三次挥手**

当B端的事情忙完了，那么此时B端就可以断开连接了，此时B端向A端发送`FIN`序号，意思是这次可以断开连接了。

**第四次挥手**

A端收到B端发送的`FIN`后，会向B端发送确认`ACK`，然后经过两个MSL时长后断开连接。

MSL是Maximum Segment Lifetime，最大报文段生存时间，2个MSL是报文段发送和接收的最长时间。



## 两次握手可以么？

TCP连接时是三次握手，那么两次握手可行吗？

在《计算机网络》中是这样解释的：已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送`ACK`包。这样就会白白浪费资源。

而经过三次握手，客户端和服务器都有应有答，这样可以确保TCP正确连接。

## 为什么TCP连接是三次，挥手确是四次？

在TCP连接中，服务器端的`SYN`和`ACK`向客户端发送是一次性发送的，而在断开连接的过程中，B端向A端发送的`ACK`和`FIN`是是分两次发送的。因为在B端接收到A端的`FIN`后，B端可能还有数据要传输，所以先发送`ACK`，等B端处理完自己的事情后就可以发送`FIN`断开连接了。

## 为什么在第四次挥手后会有2个MSL的延时？
前文说到

MSL是Maximum Segment Lifetime，最大报文段生存时间，2个MSL是报文段发送和接收的最长时间。

假定网络不可靠，那么第四次发送的`ACK`可能丢失，即B端无法收到这个`ACK`，如果B端收不到这个确认`ACK`，B端会定时向A端重复发送`FIN`，直到B端收到A的确认`ACK`。所以这个2MSL就是用来处理这个可能丢失的`ACK`的。


# TCP和UDP的区别

- TCP面向连接，UDP面向非连接即发送数据前不需要建立链接。
    - 面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。
    - 非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。
- TCP提供可靠的服务（数据传输），UDP无法保证。
- TCP面向字节流，UDP面向报文。
- TCP数据传输慢，UDP数据传输快。

**注意**：

TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。

# TCP、UDP对应的协议
C:\Users\think\Desktop\我国社会管理体制的现状分析.doc
## TCP对应的协议

1. FTP：定义了文件传输协议，使用21端口。
2. Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。
3. SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。
4. POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。
5. HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。

## UDP对应的协议

1. DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
2. SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
3. TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。
