<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>More Think</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.morethink.cn/"/>
  <updated>2019-02-08T09:27:11.679Z</updated>
  <id>https://www.morethink.cn/</id>
  
  <author>
    <name>morethink</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java解决LeetCode72题 Edit Distance</title>
    <link href="https://www.morethink.cn/%E7%AE%97%E6%B3%95/Edit-Distance/"/>
    <id>https://www.morethink.cn/算法/Edit-Distance/</id>
    <published>2019-02-07T16:00:00.000Z</published>
    <updated>2019-02-08T09:27:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>地址 ： <a href="https://leetcode.com/problems/edit-distance/description/" target="_blank" rel="noopener">https://leetcode.com/problems/edit-distance/description/</a></p><p><img src="https://images.morethink.cn/7a55770b0fb66c36ef3f3eead5dc5174.png" alt="题目描述" title="题目描述"></p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>使用<code>dp[i][j]</code>用来表示<code>word1</code>的<code>0~i-1</code>、<code>word2</code>的<code>0~j-1</code>的最小编辑距离</li><li>我们可以知道边界情况：<code>dp[i][0] = i</code>、<code>dp[0][j] = j</code>，代表从 <code>&quot;&quot;</code> 变为 <code>dp[0~i-1]</code> 或 <code>dp[0][0~j-1]</code> 所需要的次数</li></ul><p>同时对于两个字符串的子串，都能分为最后一个字符相等或者不等的情况：</p><ul><li>如果<code>word1[i-1] == word2[j-1]</code>：<code>dp[i][j] = dp[i-1][j-1]</code></li><li>如果<code>word1[i-1] != word2[j-1]</code>：  <ul><li>向word1插入：<code>dp[i][j] = dp[i][j-1] + 1</code></li><li>从word1删除：<code>dp[i][j] = dp[i-1][j] + 1</code></li><li>替换word1元素：<code>dp[i][j] = dp[i-1][j-1] + 1</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = word1.length();</span><br><span class="line">    <span class="keyword">int</span> m = word2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;地址 ： &lt;a href=&quot;https://leetcode.com/problems/edit-distance/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/edit-distance/description/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/7a55770b0fb66c36ef3f3eead5dc5174.png&quot; alt=&quot;题目描述&quot; title=&quot;题目描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.morethink.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="https://www.morethink.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>学以致用:Python爬取廖大Python教程制作pdf</title>
    <link href="https://www.morethink.cn/Python/python-tutorial-pdf/"/>
    <id>https://www.morethink.cn/Python/python-tutorial-pdf/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-05-04T06:42:57.807Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.morethink.cn/python-tutorial-pdf.jpeg" alt="python-tutorial-pdf" title="python-tutorial-pdf"></p><p>当我学了廖大的Python教程后，感觉总得做点什么，正好自己想随时查阅，于是就开始有了制作PDF这个想法。</p><p>想要把教程变成PDF有三步：</p><ol><li>先生成空html，爬取每一篇教程放进一个新生成的div，这样就生成了包含所有教程的html文件(<code>BeautifulSoup</code>)</li><li>将html转换成pdf(<code>wkhtmltopdf</code>)</li><li>由于廖大是写教程的，反爬做的比较好，在爬取的过程中还需要代理ip(<a href="https://center.abuyun.com/login" target="_blank" rel="noopener">阿布云代理</a>)</li></ol><a id="more"></a><h1 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h1><blockquote><p><a href="http://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="noopener">Beautiful Soup</a> 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间.</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install BeautifulSoup4</span><br></pre></td></tr></table></figure><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>将一段文档传入 <code>BeautifulSoup</code> 的构造方法,就能得到一个文档的对象, 可以传入一段字符串或一个文件句柄.</p><p>如下所示：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(open(<span class="string">"index.html"</span>))</span><br><span class="line">soup = BeautifulSoup(<span class="string">"&lt;html&gt;data&lt;/html&gt;"</span>)</span><br></pre></td></tr></table></figure></p><ul><li>首先,文档被转换成Unicode,并且HTML的实例都被转换成Unicode编码.</li><li>然后,Beautiful Soup选择最合适的解析器来解析这段文档,如果手动指定解析器那么Beautiful Soup会选择指定的解析器来解析文档.</li></ul><h2 id="对象的种类"><a href="#对象的种类" class="headerlink" title="对象的种类"></a>对象的种类</h2><p><code>Beautiful Soup</code> 将复杂 <code>HTML</code> 文档转换成一个复杂的树形结构,每个节点都是 <code>Python</code> 对象,所有对象可以归纳为 4 种: <code>Tag , NavigableString , BeautifulSoup , Comment .</code></p><ul><li><code>Tag</code>：通俗点讲就是 <code>HTML</code> 中的一个个标签，类似 <code>div，p</code>。</li><li><code>NavigableString</code>：获取标签内部的文字，如，<code>soup.p.string</code>。</li><li><code>BeautifulSoup</code>：表示一个文档的全部内容。</li><li><code>Comment：Comment</code> 对象是一个特殊类型的 <code>NavigableString</code> 对象，其输出的内容不包括注释符号.</li></ul><h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><p><code>Tag</code>就是<code>html</code>中的一个标签，用<code>BeautifulSoup</code>就能解析出来<code>Tag</code>的具体内容，具体的格式为<code>soup.name</code>,其中<code>name</code>是<code>html</code>下的标签，具体实例如下：</p><ul><li><p><code>print soup.title</code>输出<code>title</code>标签下的内容，包括此标签，这个将会输出</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>The Dormouse's story<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>print soup.head</code>输出<code>head</code>标签下的内容</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>The Dormouse's story<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>如果 Tag 对象要获取的标签有多个的话，它只会返回所以内容中第一个符合要求的标签</strong>。</p><h3 id="Tag-属性"><a href="#Tag-属性" class="headerlink" title="Tag 属性"></a>Tag 属性</h3><p>每个 <code>Tag</code> 有两个重要的属性 <code>name</code> 和 <code>attrs</code>：</p><ul><li><code>name</code>：对于<code>Tag</code>，它的<code>name</code>就是其本身，如<code>soup.p.name</code>就是<code>p</code></li><li><code>attrs</code>是一个字典类型的，对应的是属性-值，如<code>print soup.p.attrs</code>,输出的就是<code>{&#39;class&#39;: [&#39;title&#39;], &#39;name&#39;: &#39;dromouse&#39;}</code>,当然你也可以得到具体的值，如<code>print soup.p.attrs[&#39;class&#39;]</code>,输出的就是<code>[title]</code>是一个列表的类型，因为一个属性可能对应多个值,当然你也可以通过get方法得到属性的，如：<code>print soup.p.get(&#39;class&#39;)</code>。还可以直接使用<code>print soup.p[&#39;class&#39;]</code></li></ul><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p><code>get</code>方法用于得到标签下的属性值，注意这是一个重要的方法，在许多场合都能用到，比如你要得到<code>&lt;img src=&quot;#&quot;&gt;</code>标签下的图像<code>url</code>,那么就可以用<code>soup.img.get(&#39;src&#39;)</code>,具体解析如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 得到第一个p标签下的src属性</span></span><br><span class="line"><span class="keyword">print</span> soup.p.get(<span class="string">"class"</span>)</span><br></pre></td></tr></table></figure><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>得到标签下的文本内容，只有在此标签下没有子标签，或者只有一个子标签的情况下才能返回其中的内容，否则返回的是<code>None</code>具体实例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在上面的一段文本中p标签没有子标签，因此能够正确返回文本的内容</span></span><br><span class="line"><span class="keyword">print</span> soup.p.string</span><br><span class="line"><span class="comment"># 这里得到的就是None,因为这里的html中有很多的子标签</span></span><br><span class="line"><span class="keyword">print</span> soup.html.string</span><br></pre></td></tr></table></figure><h3 id="get-text"><a href="#get-text" class="headerlink" title="get_text()"></a><code>get_text()</code></h3><p><strong>可以获得一个标签中的所有文本内容，包括子孙节点的内容，这是最常用的方法</strong>。</p><h2 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h2><p>BeautifulSoup 主要用来遍历子节点及子节点的属性，通过<code>Tag</code>取属性的方式只能获得当前文档中的第一个 tag，例如，<code>soup.p</code>。如果想要得到所有的<code>&lt;p&gt;</code> 标签,或是通过名字得到比一个 tag 更多的内容的时候,就需要用到 find_all()<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find_all(name, attrs, recursive, text, **kwargs )</span><br></pre></td></tr></table></figure></p><p>find_all是用于搜索节点中所有符合过滤条件的节点。</p><p><strong>name参数</strong>：是Tag的名字，如p,div,title<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 节点名</span></span><br><span class="line">print(soup.find_all(<span class="string">'p'</span>))</span><br><span class="line"><span class="comment"># 2. 正则表达式</span></span><br><span class="line">print(soup.find_all(re.compile(<span class="string">'^p'</span>)))</span><br><span class="line"><span class="comment"># 3. 列表  </span></span><br><span class="line">print(soup.find_all([<span class="string">'p'</span>, <span class="string">'a'</span>]))</span><br></pre></td></tr></table></figure></p><p>另外 attrs 参数可以也作为过滤条件来获取内容，而 limit 参数是限制返回的条数。</p><h2 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h2><p>以 CSS 语法为匹配标准找到 Tag。同样也是使用到一个函数，该函数为<code>select()</code>，返回类型是 list。它的具体用法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 通过 tag 标签查找</span></span><br><span class="line">print(soup.select(head))</span><br><span class="line"><span class="comment"># 2. 通过 id 查找</span></span><br><span class="line">print(soup.select(<span class="string">'#link1'</span>))</span><br><span class="line"><span class="comment"># 3. 通过 class 查找</span></span><br><span class="line">print(soup.select(<span class="string">'.sister'</span>))</span><br><span class="line"><span class="comment"># 4. 通过属性查找</span></span><br><span class="line">print(soup.select(<span class="string">'p[name=dromouse]'</span>))</span><br><span class="line"><span class="comment"># 5. 组合查找</span></span><br><span class="line">print(soup.select(<span class="string">"body p"</span>))</span><br></pre></td></tr></table></figure><h1 id="wkhtmltopdf"><a href="#wkhtmltopdf" class="headerlink" title="wkhtmltopdf"></a>wkhtmltopdf</h1><blockquote><ul><li>wkhtmltopdf主要用于HTML生成PDF。</li><li>pdfkit是基于wkhtmltopdf的python封装，支持URL，本地文件，文本内容到PDF的转换，其最终还是调用wkhtmltopdf命令。</li></ul></blockquote><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>先安装wkhtmltopdf，再安装pdfkit。</p><ol><li><a href="https://wkhtmltopdf.org/downloads.html" target="_blank" rel="noopener">https://wkhtmltopdf.org/downloads.html</a></li><li>pdfkit <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install pdfkit</span><br></pre></td></tr></table></figure></li></ol><h2 id="转换url-file-string"><a href="#转换url-file-string" class="headerlink" title="转换url/file/string"></a>转换url/file/string</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pdfkit</span><br><span class="line"></span><br><span class="line">pdfkit.from_url(<span class="string">'http://google.com'</span>, <span class="string">'out.pdf'</span>)</span><br><span class="line">pdfkit.from_file(<span class="string">'index.html'</span>, <span class="string">'out.pdf'</span>)</span><br><span class="line">pdfkit.from_string(<span class="string">'Hello!'</span>, <span class="string">'out.pdf'</span>)</span><br></pre></td></tr></table></figure><h2 id="转换url或者文件名列表"><a href="#转换url或者文件名列表" class="headerlink" title="转换url或者文件名列表"></a>转换url或者文件名列表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pdfkit.from_url([<span class="string">'google.com'</span>, <span class="string">'baidu.com'</span>], <span class="string">'out.pdf'</span>)</span><br><span class="line">pdfkit.from_file([<span class="string">'file1.html'</span>, <span class="string">'file2.html'</span>], <span class="string">'out.pdf'</span>)</span><br></pre></td></tr></table></figure><h2 id="转换打开文件"><a href="#转换打开文件" class="headerlink" title="转换打开文件"></a>转换打开文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'file.html'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pdfkit.from_file(f, <span class="string">'out.pdf'</span>)</span><br></pre></td></tr></table></figure><h2 id="自定义设置"><a href="#自定义设置" class="headerlink" title="自定义设置"></a>自定义设置</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">options = &#123;</span><br><span class="line">    <span class="string">'page-size'</span>: <span class="string">'Letter'</span>,</span><br><span class="line">    <span class="string">'margin-top'</span>: <span class="string">'0.75in'</span>,</span><br><span class="line">    <span class="string">'margin-right'</span>: <span class="string">'0.75in'</span>,</span><br><span class="line">    <span class="string">'margin-bottom'</span>: <span class="string">'0.75in'</span>,</span><br><span class="line">    <span class="string">'margin-left'</span>: <span class="string">'0.75in'</span>,</span><br><span class="line">    <span class="string">'encoding'</span>: <span class="string">"UTF-8"</span>,</span><br><span class="line">    <span class="string">'custom-header'</span> : [</span><br><span class="line">        (<span class="string">'Accept-Encoding'</span>, <span class="string">'gzip'</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="string">'cookie'</span>: [</span><br><span class="line">        (<span class="string">'cookie-name1'</span>, <span class="string">'cookie-value1'</span>),</span><br><span class="line">        (<span class="string">'cookie-name2'</span>, <span class="string">'cookie-value2'</span>),</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'no-outline'</span>: <span class="keyword">None</span>,</span><br><span class="line">    <span class="string">'outline-depth'</span>: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pdfkit.from_url(<span class="string">'http://google.com'</span>, <span class="string">'out.pdf'</span>, options=options)</span><br></pre></td></tr></table></figure><h1 id="使用代理ip"><a href="#使用代理ip" class="headerlink" title="使用代理ip"></a>使用代理ip</h1><p>爬取十几篇教程之后触发了这个错误：<br><img src="https://images.morethink.cn/a7fa858c35a52d0bd1ed89a611546ef1.png" alt="503" title="503"></p><p>看来廖大的反爬虫做的很好，于是只好使用代理ip了，尝试了免费的<a href="https://www.xicidaili.com/" target="_blank" rel="noopener">西刺免费代理</a>后，最后选择了付费的 <a href="http://www.moguproxy.com/" target="_blank" rel="noopener">蘑菇代理</a> ，感觉响应速度和稳定性还OK。</p><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>运行过程截图：</p><p><img src="https://images.morethink.cn/ad8217afdd1d38c665a1a0341ade499e.png" alt="运行过程" title="运行过程"></p><p>生成的效果图：<br><img src="https://images.morethink.cn/3b24e8815b5e9ac26184a3f1ab96bd1d.png" alt="效果图" title="效果图"></p><p>代码如下：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pdfkit</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 阿布云代理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_soup</span><span class="params">(target_url)</span>:</span></span><br><span class="line">    proxy_host = <span class="string">"http-dyn.abuyun.com"</span></span><br><span class="line">    proxy_port = <span class="string">"9020"</span></span><br><span class="line">    proxy_user = <span class="string">"HKQL6V46321071VD"</span></span><br><span class="line">    proxy_pass = <span class="string">"1759D9C2F6DE34B3"</span></span><br><span class="line">    proxy_meta = <span class="string">"http://%(user)s:%(pass)s@%(host)s:%(port)s"</span> % &#123;</span><br><span class="line">        <span class="string">"host"</span>: proxy_host,</span><br><span class="line">        <span class="string">"port"</span>: proxy_port,</span><br><span class="line">        <span class="string">"user"</span>: proxy_user,</span><br><span class="line">        <span class="string">"pass"</span>: proxy_pass,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proxies = &#123;</span><br><span class="line">        <span class="string">"http"</span>: proxy_meta,</span><br><span class="line">        <span class="string">"https"</span>: proxy_meta,</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;<span class="string">'User-Agent'</span>:</span><br><span class="line">                   <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'</span>&#125;</span><br><span class="line">    flag = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">while</span> flag:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            resp = requests.get(target_url, proxies=proxies, headers=headers)</span><br><span class="line">            flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            time.sleep(<span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line">    soup = BeautifulSoup(resp.text, <span class="string">'html.parser'</span>)</span><br><span class="line">    <span class="keyword">return</span> soup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_toc</span><span class="params">(url)</span>:</span></span><br><span class="line">    soup = get_soup(url)</span><br><span class="line">    toc = soup.select(<span class="string">"#x-wiki-index a"</span>)</span><br><span class="line">    print(toc[<span class="number">0</span>][<span class="string">'href'</span>])</span><br><span class="line">    <span class="keyword">return</span> toc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ⬇️教程html</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_html</span><span class="params">(url, depth)</span>:</span></span><br><span class="line">    soup = get_soup(url)</span><br><span class="line">    <span class="comment"># 处理目录</span></span><br><span class="line">    <span class="keyword">if</span> int(depth) &lt;= <span class="number">1</span>:</span><br><span class="line">        depth = <span class="string">'1'</span></span><br><span class="line">    <span class="keyword">elif</span> int(depth) &gt;= <span class="number">2</span>:</span><br><span class="line">        depth = <span class="string">'2'</span></span><br><span class="line">    title = soup.select(<span class="string">"#x-content h4"</span>)[<span class="number">0</span>]</span><br><span class="line">    new_a = soup.new_tag(<span class="string">'a'</span>, href=url)</span><br><span class="line">    new_a.string = title.string</span><br><span class="line">    new_title = soup.new_tag(<span class="string">'h'</span> + depth)</span><br><span class="line">    new_title.append(new_a)</span><br><span class="line">    print(new_title)</span><br><span class="line">    <span class="comment"># 加载图片</span></span><br><span class="line">    images = soup.find_all(<span class="string">'img'</span>)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> images:</span><br><span class="line">        x[<span class="string">'src'</span>] = <span class="string">'https://static.liaoxuefeng.com/'</span> + x[<span class="string">'data-src'</span>]</span><br><span class="line">    <span class="comment"># 将bilibili iframe 视频更换为链接地址</span></span><br><span class="line">    iframes = soup.find_all(<span class="string">'iframe'</span>, src=re.compile(<span class="string">"bilibili"</span>))</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iframes:</span><br><span class="line">        x[<span class="string">'src'</span>] = <span class="string">"http:"</span> + x[<span class="string">'src'</span>]</span><br><span class="line">        a_tag = soup.new_tag(<span class="string">"a"</span>, href=x[<span class="string">'src'</span>])</span><br><span class="line">        a_tag.string = <span class="string">"vide play:"</span> + x[<span class="string">'src'</span>]</span><br><span class="line">        x.replace_with(a_tag)</span><br><span class="line"></span><br><span class="line">    div_content = soup.find(<span class="string">'div'</span>, class_=<span class="string">'x-wiki-content'</span>)</span><br><span class="line">    <span class="keyword">return</span> new_title, div_content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_pdf</span><span class="params">(template)</span>:</span></span><br><span class="line">    html_file = <span class="string">"python-tutorial-pdf.html"</span></span><br><span class="line">    <span class="keyword">with</span> open(html_file, mode=<span class="string">"w"</span>) <span class="keyword">as</span> code:</span><br><span class="line">        code.write(str(template))</span><br><span class="line">    pdfkit.from_file(html_file, <span class="string">'python-tutorial-pdf.pdf'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># html 模板</span></span><br><span class="line">    template = BeautifulSoup(</span><br><span class="line">        <span class="string">'&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;link rel="stylesheet" href="https://cdn.liaoxuefeng.com/cdn/static/themes/default/css/all.css?v=bc43d83"&gt; &lt;script src="https://cdn.liaoxuefeng.com/cdn/static/themes/default/js/all.js?v=bc43d83"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;'</span>,</span><br><span class="line">        <span class="string">'html.parser'</span>)</span><br><span class="line">    <span class="comment"># 教程目录</span></span><br><span class="line">    toc = get_toc(<span class="string">'https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000'</span>)</span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(toc):</span><br><span class="line">        url = <span class="string">'https://www.liaoxuefeng.com'</span> + x[<span class="string">'href'</span>]</span><br><span class="line">        <span class="comment"># ⬇️教程html</span></span><br><span class="line">        content = download_html(url, x.parent[<span class="string">'depth'</span>])</span><br><span class="line">        <span class="comment"># 往template添加新的教程</span></span><br><span class="line">        new_div = template.new_tag(<span class="string">'div'</span>, id=i)</span><br><span class="line">        template.body.insert(<span class="number">3</span> + i, new_div)</span><br><span class="line">        new_div.insert(<span class="number">3</span>, content[<span class="number">0</span>])</span><br><span class="line">        new_div.insert(<span class="number">3</span>, content[<span class="number">1</span>])</span><br><span class="line">        time.sleep(<span class="number">0.4</span>)</span><br><span class="line">    convert_pdf(template)</span><br></pre></td></tr></table></figure></p><p><strong>参考文档</strong>：</p><ol><li><a href="https://beautifulsoup.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">Beautiful Soup 文档</a></li><li><a href="https://www.jianshu.com/p/4d65857ffe5e" target="_blank" rel="noopener">HTML 转 PDF 之 wkhtmltopdf 工具精讲</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/python-tutorial-pdf.jpeg&quot; alt=&quot;python-tutorial-pdf&quot; title=&quot;python-tutorial-pdf&quot;&gt;&lt;/p&gt;
&lt;p&gt;当我学了廖大的Python教程后，感觉总得做点什么，正好自己想随时查阅，于是就开始有了制作PDF这个想法。&lt;/p&gt;
&lt;p&gt;想要把教程变成PDF有三步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先生成空html，爬取每一篇教程放进一个新生成的div，这样就生成了包含所有教程的html文件(&lt;code&gt;BeautifulSoup&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;将html转换成pdf(&lt;code&gt;wkhtmltopdf&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;由于廖大是写教程的，反爬做的比较好，在爬取的过程中还需要代理ip(&lt;a href=&quot;https://center.abuyun.com/login&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿布云代理&lt;/a&gt;)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.morethink.cn/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>puppeteer截图</title>
    <link href="https://www.morethink.cn/%E5%B7%A5%E5%85%B7/puppeteer-screenshot/"/>
    <id>https://www.morethink.cn/工具/puppeteer-screenshot/</id>
    <published>2019-01-08T16:00:00.000Z</published>
    <updated>2019-01-09T13:09:39.906Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.morethink.cn/puppeteer.jpg" alt="puppeteer" title="puppeteer"></p><p>puppeteer是谷歌官方出品的一个通过 <a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="noopener">DevTools</a> 协议控制 headless Chrome 的Node库。可以通过Puppeteer的提供的api直接控制Chrome模拟大部分用户操作来进行UI Test或者作为爬虫访问页面来收集数据。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>直接运行安装命令：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install puppeteer</span><br></pre></td></tr></table></figure></p><p>如果出现无法安装的问题，可以使用淘宝镜像。</p><a id="more"></a><h1 id="puppeteer实现滑动截图"><a href="#puppeteer实现滑动截图" class="headerlink" title="puppeteer实现滑动截图"></a>puppeteer实现滑动截图</h1><p>在我 puppeteer 使用截全屏的过程中发现有些图片无法截取到，而实际上是因为有些图片是懒加载的，如果你没有滑动到图片的位置，那么这个图片是不会加载。</p><p>现在我的方式是采用模拟浏览器滚动条滑动的方式滑动底部来使图片加载出来。</p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        headless: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://www.cnblogs.com/morethink/p/6525216.html'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.setViewport(&#123;</span><br><span class="line">        width: <span class="number">1200</span>,</span><br><span class="line">        height: <span class="number">800</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> autoScroll(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">        path: <span class="string">'1.png'</span>,</span><br><span class="line">        fullPage: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoScroll</span>(<span class="params">page</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> totalHeight = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> distance = <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> scrollHeight = <span class="built_in">document</span>.body.scrollHeight;</span><br><span class="line">                <span class="built_in">window</span>.scrollBy(<span class="number">0</span>, distance);</span><br><span class="line">                totalHeight += distance;</span><br><span class="line">                <span class="keyword">if</span> (totalHeight &gt;= scrollHeight) &#123;</span><br><span class="line">                    clearInterval(timer);</span><br><span class="line">                    resolve();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">100</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动图如下：</p><p><img src="https://dev.tencent.com/u/morethink/p/images/git/raw/master/puppeteer-screenshot.gif" alt="puppeteer-screenshot" title="puppeteer-screenshot"></p><h1 id="puppeteer-实现-html-element-截图"><a href="#puppeteer-实现-html-element-截图" class="headerlink" title="puppeteer 实现 html element 截图"></a>puppeteer 实现 html element 截图</h1><p>在某些情况下我们只想要针对html的某个位置进行截图而不是针对页面截全屏。</p><p>puppeteer提供了ElementHandle.screenshot 方法，该方法参数和page.screenshot 一样。而ElementHandle 对象是页面内的Dom对象。可以帮助我对 html element进行截图。这样的话你想截取页面的哪部分就截取页面的哪部分。</p><p>代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        headless: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://www.cnblogs.com/morethink/p/6525216.html'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.setViewport(&#123;</span><br><span class="line">        width: <span class="number">1200</span>,</span><br><span class="line">        height: <span class="number">800</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//获取页面Dom对象</span></span><br><span class="line">    <span class="keyword">let</span> body = <span class="keyword">await</span> page.$(<span class="string">'#cnblogs_post_body'</span>);</span><br><span class="line">    <span class="comment">//调用页面内Dom对象的 screenshot 方法进行截图</span></span><br><span class="line">    <span class="keyword">await</span> body.screenshot(&#123;</span><br><span class="line">        path: <span class="string">'2.png'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p><strong>参考文档</strong>：</p><ol><li><a href="https://github.com/GoogleChrome/puppeteer/blob/v1.11.0/docs/api.md#elementhandlescreenshotoptions" target="_blank" rel="noopener">https://github.com/GoogleChrome/puppeteer/blob/v1.11.0/docs/api.md#elementhandlescreenshotoptions</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/puppeteer.jpg&quot; alt=&quot;puppeteer&quot; title=&quot;puppeteer&quot;&gt;&lt;/p&gt;
&lt;p&gt;puppeteer是谷歌官方出品的一个通过 &lt;a href=&quot;https://chromedevtools.github.io/devtools-protocol/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DevTools&lt;/a&gt; 协议控制 headless Chrome 的Node库。可以通过Puppeteer的提供的api直接控制Chrome模拟大部分用户操作来进行UI Test或者作为爬虫访问页面来收集数据。&lt;/p&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;直接运行安装命令：&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install puppeteer&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果出现无法安装的问题，可以使用淘宝镜像。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://www.morethink.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Python 豆瓣顶帖</title>
    <link href="https://www.morethink.cn/Python/douban-ding/"/>
    <id>https://www.morethink.cn/Python/douban-ding/</id>
    <published>2018-12-30T08:17:00.000Z</published>
    <updated>2019-01-06T09:32:34.372Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.morethink.cn/278d71ed0f07f6d1d72a8afa76039cc2.png" alt="" title="🆙🆙"></p><p>由于在豆瓣发了个租房帖子，发现很快就被其他的帖子淹没，但是手动顶帖实在太累，😭，所以想通过自动顶帖的方式来解放双手！</p><a id="more"></a><h1 id="评论请求分析"><a href="#评论请求分析" class="headerlink" title="评论请求分析"></a>评论请求分析</h1><p>通过Chrome network 分析</p><p><img src="https://images.morethink.cn/4220f35fed72284a44099dfcf27028d8.png" alt="" title="add_comment"></p><ul><li>评论url是<code>https://www.douban.com/group/topic/129122199/add_comment</code></li><li>需要带5个参数，其中 ck 是 cookie 里面的值，rv_comment 是 评论</li><li>返回302代表重定向</li></ul><p>Python 模拟请求：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 豆瓣具体帖子</span></span><br><span class="line">url = <span class="string">"https://www.douban.com/group/topic/129122199/"</span></span><br><span class="line"><span class="comment"># 豆瓣具体帖子回复的接口，格式是帖子链接+/add_comment</span></span><br><span class="line">comment_url = url + <span class="string">"/add_comment"</span></span><br><span class="line">cookie = <span class="string">'cookie'</span></span><br><span class="line">referer = url</span><br><span class="line">agent = <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"www.douban.com"</span>,</span><br><span class="line">    <span class="string">"Referer"</span>: referer,</span><br><span class="line">    <span class="string">'User-Agent'</span>: agent,</span><br><span class="line">    <span class="string">"Cookie"</span>: cookie</span><br><span class="line">&#125;</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">"rv_comment"</span>: <span class="string">'🆙'</span>,</span><br><span class="line">    <span class="string">"ck"</span>: re.findall(<span class="string">"ck=(.*?);"</span>, headers[<span class="string">"Cookie"</span>])[<span class="number">-1</span>],</span><br><span class="line">    <span class="string">'start'</span>: <span class="string">'0'</span>,</span><br><span class="line">    <span class="string">'submit_btn'</span>: <span class="string">'发送'</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.post(comment_url, headers=headers, allow_redirects=<span class="keyword">False</span>,</span><br><span class="line">                         data=params, verify=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>直接运行即可。</p><p>但是多运行几次就会发现，返回的状态码是200，而且没有顶帖成功。实际上是触发了豆瓣的防爬虫。</p><p><img src="https://images.morethink.cn/96695d5876d98ca99abc79866020a284.png" alt="" title="触发了豆瓣验证码"></p><p>而且在我们顶帖的时候发送请求的时候还带有 captcha-solution 和 captcha-id 字段。</p><p><img src="https://images.morethink.cn/8a57550867a8e02b3272d6043632f51b.png" alt=""></p><p>目前发现，每次评论就算相隔1分钟，只要满3次，就一定会弹出这个验证码进行验证。</p><h1 id="验证码解析"><a href="#验证码解析" class="headerlink" title="验证码解析"></a>验证码解析</h1><p>遇到验证码我们就来破解验证码。</p><h2 id="tesserocr"><a href="#tesserocr" class="headerlink" title="tesserocr"></a>tesserocr</h2><p>识别图形验证码需要安装tesserocr这个库，下面介绍下tesserocr。</p><p>tesserocr是Python的一个OCR识别库，但其实是对tesseract做了一层Python Api的封装，核心还是tesseract，所以在安装tesserocr之前，需要先安装tesseract。<code>Tesseract</code>(/‘tesərækt/) 这个词的意思是”超立方体”，指的是几何学里的四维标准方体，又称”正八胞体”，是一款被广泛使用的开源 <code>OCR</code> 工具。</p><p>在Mac下，使用 brew 安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install tesseract --all-languages</span><br></pre></td></tr></table></figure><p>接下来再安装tesserocr即可：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install imagemagick</span><br><span class="line">pip install tesserocr pillow</span><br></pre></td></tr></table></figure><p>Python 代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tesserocr</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 新建Image对象</span></span><br><span class="line">    image = Image.open(<span class="string">"/Users/liwenhao/Desktop/douban-captcha-example1.jpeg"</span>)</span><br><span class="line">    <span class="comment"># 调用tesserocr的image_to_text()方法，传入image对象完成识别</span></span><br><span class="line">    result = tesserocr.image_to_text(image)</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><p>验证的图片如下：</p><p><img src="https://images.morethink.cn/douban-captcha-example1.jpeg" alt="douban-captcha-example1" title="douban-captcha-example1"></p><p>结果无法识别。</p><p>换一张简单的图片试试：<br><img src="http://images.morethink.cn/captcha-example1.jpg" alt="captcha-example1.jpg"></p><p>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5594</span><br></pre></td></tr></table></figure></p><p>看来 Tesseract 只能识别一些简单的验证码，不适合豆瓣验证码识别。</p><p>试试识别验证码平台。</p><h2 id="百度OCR"><a href="#百度OCR" class="headerlink" title="百度OCR"></a>百度OCR</h2><p><strong>官方接入文档</strong>: <a href="https://cloud.baidu.com/doc/OCR/OCR-Python-SDK.html#.E5.BF.AB.E9.80.9F.E5.85.A5.E9.97.A8" target="_blank" rel="noopener">文字识别-Python SDK接入文档</a></p><ul><li><strong>重点：免费</strong>  </li><li>通用识别（包括身份证、银行卡）500次/日，  </li><li>高精度则50次/日，  </li><li>驾驶证，行驶证，车票，营业执照，通用票据均为200次/日  </li></ul><p>注意：<br><strong>支持2.7.+及3.+</strong></p><h3 id="配置流程："><a href="#配置流程：" class="headerlink" title="配置流程："></a>配置流程：</h3><ol><li>先开通个百度的账号；  </li><li>开通<strong>文字识别服务</strong>，打开后点击立即使用：<a href="https://cloud.baidu.com/product/ocr.html" target="_blank" rel="noopener">https://cloud.baidu.com/product/ocr.html</a>  </li><li>点击步骤2，应该有个信息确认的，确认后，会进入到用户个人首页，向下滑动，直接点击文字识别:<br><img src="https://user-gold-cdn.xitu.io/2018/6/11/163ecde99a94d224" alt=""></li><li>点击创建应用，输入一堆内容后，点击确认即可，然后点击我的应用，这里面的<strong>API Key</strong> 跟<strong>Secret Key</strong>需要使用到: <img src="https://user-gold-cdn.xitu.io/2018/6/11/163ece17b329ea80" alt=""></li><li><p>点击右上角，用户中心，用户ID也需要用到:<br><img src="https://user-gold-cdn.xitu.io/2018/6/11/163ece27d4bc3e76" alt=""></p></li><li><p>需要的信息准备好了，<strong>pip</strong> 安装一波</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install baidu-aip</span><br></pre></td></tr></table></figure></li></ol><h3 id="测试一波"><a href="#测试一波" class="headerlink" title="测试一波"></a>测试一波</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipOcr</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    APP_ID = <span class="string">' '</span></span><br><span class="line">    API_KEY = <span class="string">' '</span></span><br><span class="line">    SECRET_KEY = <span class="string">' '</span></span><br><span class="line"></span><br><span class="line">    client = AipOcr(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取图片</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_file_content</span><span class="params">(file_path)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(file_path, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            <span class="keyword">return</span> fp.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    image = get_file_content(<span class="string">'/Users/liwenhao/Desktop/douban-captcha-example2.jpg'</span>)</span><br><span class="line">    <span class="string">""" 调用通用文字识别(高精度), 图片参数为本地图片 """</span></span><br><span class="line">    result = json.dumps(client.basicAccurate(image))</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><p>验证的图片如下：</p><p><img src="https://images.morethink.cn/douban-captcha-example1.jpeg" alt="douban-captcha-example1" title="douban-captcha-example1"></p><p>结果走一波：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;log_id&quot;: 3968431492157876638, &quot;words_result_num&quot;: 1, &quot;words_result&quot;: [&#123;&quot;words&quot;: &quot; minute:&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>从结果可以看出识别出了这个验证码。</p><ul><li><code>words_result_num</code> 是识别结果数</li><li><code>words_result</code> 是定位和识别结果数组</li><li><code>words</code> 是识别结果字符串</li></ul><p>再来试试</p><p><img src="https://images.morethink.cn/douban-captcha-example2.jpg" alt="douban-captcha-example2" title="douban-captcha-example2"></p><p>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;log_id&quot;: 5251449865676063710, &quot;words_result_num&quot;: 0, &quot;words_result&quot;: []&#125;</span><br></pre></td></tr></table></figure></p><p>没有识别出来，可以看到对于复杂一些的验证码还是会出现无法识别的情况，但是胜在免费。</p><h2 id="超级鹰"><a href="#超级鹰" class="headerlink" title="超级鹰"></a>超级鹰</h2><p>对于无法识别的情况就需要打码平台了，业界比较出名的是 <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.chaojiying.com%2F" target="_blank" rel="noopener">超级鹰</a> 。</p><p>超级鹰是按量级收费，量大便宜，标准价格:1元=1000题分，不同验证码类型，需要的题分不一样，详情可以到这里查询 <a href="http://www.chaojiying.com/price.html" target="_blank" rel="noopener">http://www.chaojiying.com/price.html</a></p><p>python 代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过超级鹰识别验证码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recognition_captcha</span><span class="params">(filename, code_type)</span>:</span></span><br><span class="line">    im = open(filename, <span class="string">'rb'</span>).read()</span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">'user'</span>: <span class="string">'账号'</span>,</span><br><span class="line">        <span class="string">'pass2'</span>: md5(<span class="string">'密码'</span>.encode(<span class="string">'utf8'</span>)).hexdigest(),</span><br><span class="line">        <span class="string">'softid'</span>: <span class="string">'softid'</span>,</span><br><span class="line">        <span class="string">'codetype'</span>: code_type</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'Connection'</span>: <span class="string">'Keep-Alive'</span>,</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    files = &#123;<span class="string">'userfile'</span>: (<span class="string">'ccc.jpg'</span>, im)&#125;</span><br><span class="line">    resp = requests.post(<span class="string">'http://upload.chaojiying.net/Upload/Processing.php'</span>, data=params, files=files,</span><br><span class="line">                         headers=headers).json()</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(json.dumps(recognition_captcha(<span class="string">'/Users/liwenhao/Desktop/douban-captcha-example2.jpg'</span>, <span class="number">1006</span>)))</span><br></pre></td></tr></table></figure></p><p>上传的验证码就是上面百度 OCR 未曾识别的验证码，如下：</p><p><img src="https://images.morethink.cn/douban-captcha-example2.jpg" alt="douban-captcha-example2" title="douban-captcha-example2"><br>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;err_str&quot;: &quot;OK&quot;, &quot;err_no&quot;: 0, &quot;md5&quot;: &quot;0475b05654c376deb409bfef7eee75cd&quot;, &quot;pic_id&quot;: &quot;8054415552001300054&quot;, &quot;pic_str&quot;: &quot;yacvmd&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>发现 验证码 <code>yacvmd</code> 已出来。但是时间花了5s左右。后来测试发现对于豆瓣比较建的验证码花费的时间在1s内，因此从时间和准确性上面，最后还是采用了超级鹰打码平台。</p><h1 id="失败微信通知"><a href="#失败微信通知" class="headerlink" title="失败微信通知"></a>失败微信通知</h1><p>无论采用什么方式，都有可能出现失败的情况，我总不能采取 轮询 的方式，隔几个小时就去看看到底前面几次是否🆙成功，因此需要一个 异步通知 ，最开始想用 邮件，后来发现了 <a href="http://sc.ftqq.com/3.version" target="_blank" rel="noopener">Server酱</a> 这个神器，可以帮助我们发送微信通知，而且特别简单。</p><p>具体可以查看 <a href="http://sc.ftqq.com/3.version" target="_blank" rel="noopener">Server酱</a>。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>采用 python2</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, format=<span class="string">'%(asctime)s.%(msecs)03d %(levelname)s: %(message)s'</span>,</span><br><span class="line">                    datefmt=<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载验证码图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_captcha</span><span class="params">(captcha_url, agent)</span>:</span></span><br><span class="line">    <span class="comment"># findall返回的是一个列表</span></span><br><span class="line">    captcha_name = re.findall(<span class="string">"id=(.*?):"</span>, captcha_url)</span><br><span class="line">    filename = <span class="string">"douban_%s.jpg"</span> % (str(captcha_name[<span class="number">0</span>]))</span><br><span class="line">    logging.info(<span class="string">"文件名为: "</span> + filename)</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 以二进制写入的模式在本地构建新文件</span></span><br><span class="line">        header = &#123;</span><br><span class="line">            <span class="string">'User-Agent'</span>: agent,</span><br><span class="line">            <span class="string">'Referer'</span>: captcha_url</span><br><span class="line">        &#125;</span><br><span class="line">        f.write(requests.get(captcha_url, headers=header).content)</span><br><span class="line">        logging.info(<span class="string">"%s 下载完成"</span> % filename)</span><br><span class="line">    <span class="keyword">return</span> filename</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过超级鹰识别验证码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recognition_captcha</span><span class="params">(filename, code_type)</span>:</span></span><br><span class="line">    im = open(filename, <span class="string">'rb'</span>).read()</span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">'user'</span>: <span class="string">'用户'</span>,</span><br><span class="line">        <span class="string">'pass2'</span>: md5(<span class="string">'密码'</span>.encode(<span class="string">'utf8'</span>)).hexdigest(),</span><br><span class="line">        <span class="string">'softid'</span>: <span class="string">'softid'</span>,</span><br><span class="line">        <span class="string">'codetype'</span>: code_type</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'Connection'</span>: <span class="string">'Keep-Alive'</span>,</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    files = &#123;<span class="string">'userfile'</span>: (<span class="string">'ccc.jpg'</span>, im)&#125;</span><br><span class="line">    resp = requests.post(<span class="string">'http://upload.chaojiying.net/Upload/Processing.php'</span>, data=params, files=files,</span><br><span class="line">                         headers=headers).json()</span><br><span class="line">    <span class="comment"># 错误处理</span></span><br><span class="line">    <span class="keyword">if</span> resp.get(<span class="string">'err_no'</span>, <span class="number">0</span>) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> resp.get(<span class="string">'pic_str'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">result_verification</span><span class="params">(response)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">302</span>:</span><br><span class="line">        logging.info(<span class="string">"豆瓣ding成功"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logging.info(response.status_code)</span><br><span class="line">        logging.info(response)</span><br><span class="line">        url = <span class="string">"https://sc.ftqq.com/你的SCKEY.send?text=douban失败"</span> + \</span><br><span class="line">              str(random.randint(<span class="number">0</span>, <span class="number">1000</span>))</span><br><span class="line">        requests.post(url)</span><br><span class="line">        logging.info(<span class="string">"豆瓣ding失败，发送失败信息到微信"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 豆瓣顶帖</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">douban_ding</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 豆瓣具体帖子</span></span><br><span class="line">    url = <span class="string">"https://www.douban.com/group/topic/129122199/"</span></span><br><span class="line">    <span class="comment"># 豆瓣具体帖子回复的接口，格式是帖子链接+/add_comment</span></span><br><span class="line">    comment_url = url + <span class="string">"/add_comment"</span></span><br><span class="line">    cookie = <span class="string">'cookie'</span></span><br><span class="line">    referer = url</span><br><span class="line">    agent = <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36'</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">"Host"</span>: <span class="string">"www.douban.com"</span>,</span><br><span class="line">        <span class="string">"Referer"</span>: referer,</span><br><span class="line">        <span class="string">'User-Agent'</span>: agent,</span><br><span class="line">        <span class="string">"Cookie"</span>: cookie</span><br><span class="line">    &#125;</span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">"rv_comment"</span>: <span class="string">'🆙'</span>,</span><br><span class="line">        <span class="string">"ck"</span>: re.findall(<span class="string">"ck=(.*?);"</span>, headers[<span class="string">"Cookie"</span>])[<span class="number">-1</span>],</span><br><span class="line">        <span class="string">'start'</span>: <span class="string">'0'</span>,</span><br><span class="line">        <span class="string">'submit_btn'</span>: <span class="string">'发送'</span></span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(url, headers=headers, verify=<span class="keyword">False</span>).content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    selector = html.fromstring(response)</span><br><span class="line">    captcha_image = selector.xpath(<span class="string">"//img[@id=\"captcha_image\"]/@src"</span>)</span><br><span class="line">    <span class="keyword">if</span> captcha_image:</span><br><span class="line">        logging.info(<span class="string">"发现验证码，下载验证码"</span>)</span><br><span class="line">        captcha_id = selector.xpath(<span class="string">"//input[@name=\"captcha-id\"]/@value"</span>)</span><br><span class="line">        filename = download_captcha(captcha_image[<span class="number">0</span>], agent)</span><br><span class="line">        captcha_solution = recognition_captcha(filename, <span class="number">1006</span>)</span><br><span class="line">        os.remove(filename)</span><br><span class="line">        params[<span class="string">'captcha-solution'</span>] = captcha_solution</span><br><span class="line">        params[<span class="string">'captcha-id'</span>] = captcha_id</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logging.info(<span class="string">"没有验证码"</span>)</span><br><span class="line">    response = requests.post(comment_url, headers=headers, allow_redirects=<span class="keyword">False</span>,</span><br><span class="line">                             data=params, verify=<span class="keyword">False</span>)</span><br><span class="line">    result_verification(response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    douban_ding()</span><br></pre></td></tr></table></figure><p>运行结果：</p><ol><li><p>第1次：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-12-30 16:09:35.589 INFO: 没有验证码</span><br><span class="line">2018-12-30 16:09:36.436 INFO: 豆瓣ding成功</span><br></pre></td></tr></table></figure></li><li><p>第4次：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-12-30 16:13:02.135 INFO: 发现验证码，下载验证码</span><br><span class="line">2018-12-30 16:13:02.135 INFO: 文件名为: douban_OJGsVa0hST4O2WhFA0VpMnR9.jpg</span><br><span class="line">2018-12-30 16:13:02.554 INFO: douban_OJGsVa0hST4O2WhFA0VpMnR9.jpg 下载完成</span><br><span class="line">2018-12-30 16:13:09.687 INFO: 豆瓣ding成功</span><br></pre></td></tr></table></figure></li></ol><p>效果图：</p><p><img src="https://images.morethink.cn/b9eeaa536e309a201824eac764d11e33.png" alt=""></p><p>注：</p><ol><li>顶帖的时候控制好频率，不然容易被禁言。 <img src="https://images.morethink.cn/douban-ban.jpg" alt="" title="豆瓣禁言"></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/278d71ed0f07f6d1d72a8afa76039cc2.png&quot; alt=&quot;&quot; title=&quot;🆙🆙&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于在豆瓣发了个租房帖子，发现很快就被其他的帖子淹没，但是手动顶帖实在太累，😭，所以想通过自动顶帖的方式来解放双手！&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.morethink.cn/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker中执行Shell出现乱码</title>
    <link href="https://www.morethink.cn/Linux/Docker%E4%B8%AD%E6%89%A7%E8%A1%8CShell%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81/"/>
    <id>https://www.morethink.cn/Linux/Docker中执行Shell出现乱码/</id>
    <published>2018-10-13T16:00:00.000Z</published>
    <updated>2018-12-05T06:42:48.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>最近遇到一个问题：<br>执行命令<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec f4af9b sh -c 'bash /tmp/build.sh'</span><br></pre></td></tr></table></figure></p><p>在docker中执行shell，会出现中文乱码的问题。但是在docker容器中单独执行shell脚本却没有出现乱码。查看环境变量存在<code>LANG=en_US.UTF-8</code>，因此从原理上来说是不应该出现乱码的。</p><p>但是既然出现了乱码，那么<code>LANG=en_US.UTF-8</code>应该就没有读取到，于是在 <code>build.sh</code>中运行<code>env</code>命令，发现通过<code>docker exec f4af9b sh -c &#39;bash /tmp/build.sh&#39;</code>方式没有<code>LANG=en_US.UTF-8</code>环境变量，那么原因是什么？</p><a id="more"></a><h1 id="原因定位"><a href="#原因定位" class="headerlink" title="原因定位"></a>原因定位</h1><p>原因如下：<br><code>docker exec f4af9b sh -c &#39;bash /tmp/build.sh&#39;</code> 对于docker 容器来说是非登录和非交互式shell，这样就不会读取某些配置文件，导致<code>LANG=en_US.UTF-8</code>没有加载成功。</p><h1 id="Linux-Shell"><a href="#Linux-Shell" class="headerlink" title="Linux Shell"></a>Linux Shell</h1><p>下面介绍一下Linux交互式和非交互式shell、登录和非登录shell之间的区别。</p><ul><li><p><strong>交互式shell（interactive shell）和非交互式shell（non-interactive shell）</strong>：</p><ul><li>交互式的shell会有一个输入提示符，并且它的标准输入、输出和错误输出都会显示在控制台上。这种模式也是大多数用户非常熟悉的：登录、执行一些命令、退出。当你退出后，shell也终止了。  </li><li>非交互式shell是<code>bash script.sh</code>这类的shell。在这种模式下，shell不与你进行交互，而是读取存放在文件中的命令，并且执行它们。当它读到文件的结尾EOF，shell也就终止了。</li></ul></li><li><p><strong>登录式shell（login shell）和非登陆式shell（no-login shell）</strong>：</p><ul><li>需要输入用户名和密码的shell就是登陆式shell。因此通常不管以何种方式登陆机器后用户获得的第一个shell就是login shell。不输入密码的ssh是公钥打通的，某种意义上说也是输入密码的。</li><li>非登陆式的就是在登陆后启动bash等，即不是远程登陆到主机这种。</li></ul></li></ul><p>对于常用环境变量设置文件，整理出如下加载情况表：</p><table><thead><tr><th style="text-align:center">文件</th><th style="text-align:center">非交互+登陆式</th><th style="text-align:center">交互+登陆式</th><th style="text-align:center">交互+非登陆式</th><th style="text-align:center">非交互+非登陆式</th></tr></thead><tbody><tr><td style="text-align:center">/etc/profile</td><td style="text-align:center">加载</td><td style="text-align:center">加载</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">/etc/bashrc</td><td style="text-align:center">加载</td><td style="text-align:center">加载</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">~/.bash_profile</td><td style="text-align:center">加载</td><td style="text-align:center">加载</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">~/.bashrc</td><td style="text-align:center">加载</td><td style="text-align:center">加载</td><td style="text-align:center">加载</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">BASH_ENV</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">加载</td></tr></tbody></table><p>执行脚本，如<code>bash script.sh</code>是属于non-login + non-interactive。</p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>因而，执行命令<code>docker exec f4af9b sh -c &#39;bash /tmp/build.sh&#39;</code>对于docker容器来说是属于non-login + non-interactive。</p><p>将上面的<code>bash /tmp/build.sh</code>改为<code>bash --login /tmp/build.sh</code>变为登录shell，就可以读取/etc/profile和~/.bash_profile等文件。</p><p>或者在执行<code>bash /tmp/build.sh</code>时在<code>build.sh</code>加入<code>export LANG=&quot;en_US.UTF-8&quot;</code>手动设置。</p><h1 id="常见的shell变量"><a href="#常见的shell变量" class="headerlink" title="常见的shell变量"></a>常见的shell变量</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PATH：决定了shell将到哪些目录中寻找命令或程序</span><br><span class="line">HOME：当前用户主目录</span><br><span class="line">MAIL：是指当前用户的邮件存放目录。</span><br><span class="line">SHELL：是指当前用户用的是哪种Shell。</span><br><span class="line">HISTSIZE：是指保存历史命令记录的条数</span><br><span class="line">LOGNAME：是指当前用户的登录名。</span><br><span class="line">HOSTNAME：是指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。</span><br><span class="line">LANG/LANGUGE：是和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。</span><br><span class="line">PS1：是基本提示符，对于root用户是#，对于普通用户是$。</span><br><span class="line">PS2：是附属提示符，默认是&quot;&gt;&quot;。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;最近遇到一个问题：&lt;br&gt;执行命令&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker exec f4af9b sh -c &#39;bash /tmp/build.sh&#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在docker中执行shell，会出现中文乱码的问题。但是在docker容器中单独执行shell脚本却没有出现乱码。查看环境变量存在&lt;code&gt;LANG=en_US.UTF-8&lt;/code&gt;，因此从原理上来说是不应该出现乱码的。&lt;/p&gt;
&lt;p&gt;但是既然出现了乱码，那么&lt;code&gt;LANG=en_US.UTF-8&lt;/code&gt;应该就没有读取到，于是在 &lt;code&gt;build.sh&lt;/code&gt;中运行&lt;code&gt;env&lt;/code&gt;命令，发现通过&lt;code&gt;docker exec f4af9b sh -c &amp;#39;bash /tmp/build.sh&amp;#39;&lt;/code&gt;方式没有&lt;code&gt;LANG=en_US.UTF-8&lt;/code&gt;环境变量，那么原因是什么？&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.morethink.cn/categories/Linux/"/>
    
    
      <category term="Docker" scheme="https://www.morethink.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Netty接收HTTP文件上传及文件下载</title>
    <link href="https://www.morethink.cn/Netty%E6%8E%A5%E6%94%B6HTTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8F%8A%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    <id>https://www.morethink.cn/Netty接收HTTP文件上传及文件下载/</id>
    <published>2018-10-13T16:00:00.000Z</published>
    <updated>2018-10-19T12:11:44.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>这个处理器的原理是接收HttpObject对象，按照HttpRequest，HttpContent来做处理，文件内容是在HttpContent消息带来的。</p><p>然后在HttpContent中一个chunk一个chunk读，chunk大小可以在初始化HttpServerCodec时设置。将每个chunk交个httpDecoder复制一份，当读到LastHttpContent对象时，表明上传结束，可以将httpDecoder中缓存的文件通过HttpDataFactory写到磁盘上，然后在删除缓存的HttpContent对象。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttUploadHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttUploadHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HttpDataFactory factory = <span class="keyword">new</span> DefaultHttpDataFactory(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILE_UPLOAD = <span class="string">"/data/"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URI = <span class="string">"/upload"</span>;</span><br><span class="line">    <span class="keyword">private</span> HttpPostRequestDecoder httpDecoder;</span><br><span class="line">    HttpRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> HttpObject httpObject)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (httpObject <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">            request = (HttpRequest) httpObject;</span><br><span class="line">            <span class="keyword">if</span> (request.uri().startsWith(URI) &amp;&amp; request.method().equals(HttpMethod.POST)) &#123;</span><br><span class="line">                httpDecoder = <span class="keyword">new</span> HttpPostRequestDecoder(factory, request);</span><br><span class="line">                httpDecoder.setDiscardThreshold(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//传递给下一个Handler</span></span><br><span class="line">                ctx.fireChannelRead(httpObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (httpObject <span class="keyword">instanceof</span> HttpContent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (httpDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> HttpContent chunk = (HttpContent) httpObject;</span><br><span class="line">                httpDecoder.offer(chunk);</span><br><span class="line">                <span class="keyword">if</span> (chunk <span class="keyword">instanceof</span> LastHttpContent) &#123;</span><br><span class="line">                    writeChunk(ctx);</span><br><span class="line">                    <span class="comment">//关闭httpDecoder</span></span><br><span class="line">                    httpDecoder.destroy();</span><br><span class="line">                    httpDecoder = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ReferenceCountUtil.release(httpObject);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ctx.fireChannelRead(httpObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeChunk</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (httpDecoder.hasNext()) &#123;</span><br><span class="line">            InterfaceHttpData data = httpDecoder.next();</span><br><span class="line">            <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; HttpDataType.FileUpload.equals(data.getHttpDataType())) &#123;</span><br><span class="line">                <span class="keyword">final</span> FileUpload fileUpload = (FileUpload) data;</span><br><span class="line">                <span class="keyword">final</span> File file = <span class="keyword">new</span> File(FILE_UPLOAD + fileUpload.getFilename());</span><br><span class="line">                log.info(<span class="string">"upload file: &#123;&#125;"</span>, file);</span><br><span class="line">                <span class="keyword">try</span> (FileChannel inputChannel = <span class="keyword">new</span> FileInputStream(fileUpload.getFile()).getChannel();</span><br><span class="line">                     FileChannel outputChannel = <span class="keyword">new</span> FileOutputStream(file).getChannel()) &#123;</span><br><span class="line">                    outputChannel.transferFrom(inputChannel, <span class="number">0</span>, inputChannel.size());</span><br><span class="line">                    ResponseUtil.response(ctx, request, <span class="keyword">new</span> GeneralResponse(HttpResponseStatus.OK, <span class="string">"SUCCESS"</span>, <span class="keyword">null</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"&#123;&#125;"</span>, cause);</span><br><span class="line">        ctx.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (httpDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            httpDecoder.cleanFiles();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h1><p>参考官方Demo： <a href="https://github.com/netty/netty/blob/4.1/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java" target="_blank" rel="noopener">https://github.com/netty/netty/blob/4.1/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java</a></p><p>做了改动：</p><ul><li>为了更高效的传输大数据，实例中用到了ChunkedWriteHandler编码器，它提供了以zero-memory-copy方式写文件。</li><li>通过ChannelProgressiveFutureListener对文件下载过程进行监听。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 新增ChunkedHandler，主要作用是支持异步发送大的码流（例如大文件传输），但是不占用过多的内存，防止发生java内存溢出错误</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line"><span class="comment">// 用于下载文件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> HttpDownloadHandler());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDownloadHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">FullHttpRequest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpDownloadHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filePath = <span class="string">"/data/body.csv"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest request)</span> </span>&#123;</span><br><span class="line">        String uri = request.uri();</span><br><span class="line">        <span class="keyword">if</span> (uri.startsWith(<span class="string">"/download"</span>) &amp;&amp; request.method().equals(HttpMethod.GET)) &#123;</span><br><span class="line">            GeneralResponse generalResponse = <span class="keyword">null</span>;</span><br><span class="line">            File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"r"</span>);</span><br><span class="line">                <span class="keyword">long</span> fileLength = raf.length();</span><br><span class="line">                HttpResponse response = <span class="keyword">new</span> DefaultHttpResponse(HTTP_1_1, HttpResponseStatus.OK);</span><br><span class="line">                response.headers().set(HttpHeaderNames.CONTENT_LENGTH, fileLength);</span><br><span class="line">                response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">"application/octet-stream"</span>);</span><br><span class="line">                response.headers().add(HttpHeaderNames.CONTENT_DISPOSITION, String.format(<span class="string">"attachment; filename=\"%s\""</span>, file.getName()));</span><br><span class="line">                ctx.write(response);</span><br><span class="line">                ChannelFuture sendFileFuture = ctx.write(<span class="keyword">new</span> DefaultFileRegion(raf.getChannel(), <span class="number">0</span>, fileLength), ctx.newProgressivePromise());</span><br><span class="line">                sendFileFuture.addListener(<span class="keyword">new</span> ChannelProgressiveFutureListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelProgressiveFuture future)</span></span></span><br><span class="line"><span class="function">                            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        log.info(<span class="string">"file &#123;&#125; transfer complete."</span>, file.getName());</span><br><span class="line">                        raf.close();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationProgressed</span><span class="params">(ChannelProgressiveFuture future,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">long</span> progress, <span class="keyword">long</span> total)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (total &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            log.warn(<span class="string">"file &#123;&#125; transfer progress: &#123;&#125;"</span>, file.getName(), progress);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            log.debug(<span class="string">"file &#123;&#125; transfer progress: &#123;&#125;/&#123;&#125;"</span>, file.getName(), progress, total);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                log.warn(<span class="string">"file &#123;&#125; not found"</span>, file.getPath());</span><br><span class="line">                generalResponse = <span class="keyword">new</span> GeneralResponse(HttpResponseStatus.NOT_FOUND, String.format(<span class="string">"file %s not found"</span>, file.getPath()), <span class="keyword">null</span>);</span><br><span class="line">                ResponseUtil.response(ctx, request, generalResponse);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.warn(<span class="string">"file &#123;&#125; has a IOException: &#123;&#125;"</span>, file.getName(), e.getMessage());</span><br><span class="line">                generalResponse = <span class="keyword">new</span> GeneralResponse(HttpResponseStatus.INTERNAL_SERVER_ERROR, String.format(<span class="string">"读取 file %s 发生异常"</span>, filePath), <span class="keyword">null</span>);</span><br><span class="line">                ResponseUtil.response(ctx, request, generalResponse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.fireChannelRead(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable e)</span> </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"&#123;&#125;"</span>, e);</span><br><span class="line">        ctx.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下载文件遇到的坑"><a href="#下载文件遇到的坑" class="headerlink" title="下载文件遇到的坑"></a>下载文件遇到的坑</h2><p>由于<code>RandomAccessFile</code>是一种文件资源，所以我习惯性的在最后关闭文件资源，采用的是Java7的 <code>try-with-resources</code> 语法，于是问题就出现了，由于 <code>ctx.write(new DefaultFileRegion(raf.getChannel(), 0, fileLength), ctx.newProgressivePromise());</code> 是异步的，在我关闭<code>RandomAccessFile</code>时，文件还未传输完毕，就会导致下载文件停止。</p><p>代码放在： <a href="https://github.com/morethink/code/tree/master/java/netty-example" target="_blank" rel="noopener">https://github.com/morethink/code/tree/master/java/netty-example</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;文件上传&quot;&gt;&lt;a href=&quot;#文件上传&quot; class=&quot;headerlink&quot; title=&quot;文件上传&quot;&gt;&lt;/a&gt;文件上传&lt;/h1&gt;&lt;p&gt;这个处理器的原理是接收HttpObject对象，按照HttpRequest，HttpContent来做处理，文件内容是在HttpContent消息带来的。&lt;/p&gt;
&lt;p&gt;然后在HttpContent中一个chunk一个chunk读，chunk大小可以在初始化HttpServerCodec时设置。将每个chunk交个httpDecoder复制一份，当读到LastHttpContent对象时，表明上传结束，可以将httpDecoder中缓存的文件通过HttpDataFactory写到磁盘上，然后在删除缓存的HttpContent对象。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.morethink.cn/categories/Java/"/>
    
    
      <category term="Netty" scheme="https://www.morethink.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty URL路由方案探讨</title>
    <link href="https://www.morethink.cn/Netty-URL-routing-scheme/"/>
    <id>https://www.morethink.cn/Netty-URL-routing-scheme/</id>
    <published>2018-09-26T16:00:00.000Z</published>
    <updated>2018-09-27T09:16:37.473Z</updated>
    
    <content type="html"><![CDATA[<p>最近在用Netty做开发，需要提供一个http web server，供调用方调用。采用Netty本身提供的<code>HttpServerCodec</code> handler进行Http协议的解析，但是需要自己提供路由。</p><p>最开始是通过对Http method及uri 采用多层if else 嵌套判断的方法路由到真正的controller类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String uri = request.uri();</span><br><span class="line">HttpMethod method = request.method();</span><br><span class="line"><span class="keyword">if</span> (method == HttpMethod.POST) &#123;</span><br><span class="line">    <span class="keyword">if</span> (uri.startsWith(<span class="string">"/login"</span>)) &#123;</span><br><span class="line">        <span class="comment">//url参数解析，调用controller的方法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (uri.startsWith(<span class="string">"/logout"</span>)) &#123;</span><br><span class="line">        <span class="comment">//同上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (method == HttpMethod.GET) &#123;</span><br><span class="line">    <span class="keyword">if</span> (uri.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (uri.startsWith(<span class="string">"/status"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>在只需提供<code>login</code>及<code>logout</code>API时，代码可以完成功能，可是随着API的数量越来越多，需要支持的方法及uri越来越多，<code>else if</code> 越来越多，代码越来越复杂。</p><p><img src="https://images.morethink.cn/time-for-change.jpg" alt="time-for-change" title="是时候考虑重构了"></p><p>在阿里开发手册中也提到过：</p><p><img src="https://images.morethink.cn/e1a6f2bd638f0baf5aba0d7a63e77230.png" alt="" title="重构多层else if"></p><p>因此首先考虑采用状态设计模式及策略设计模式重构。</p><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="状态模式的角色："><a href="#状态模式的角色：" class="headerlink" title="状态模式的角色："></a>状态模式的角色：</h2><ul><li>state状态<br>表示状态，定义了根据不同状态进行不同处理的接口，该接口是那些处理内容依赖于状态的方法集合，对应实例的state类</li><li>具体的状态<br>实现了state接口，对应daystate和nightstate</li><li>context<br>context持有当前状态的具体状态的实例，此外，他还定义了供外部调用者使用的状态模式的接口。</li></ul><p>首先我们知道每个http请求都是由method及uri来唯一标识的，所谓路由就是通过这个唯一标识定位到controller类的中的某个方法。</p><p>因此把HttpLabel作为状态<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpLabel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String uri;</span><br><span class="line">    <span class="keyword">private</span> HttpMethod method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>状态接口：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Route</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">GeneralResponse <span class="title">call</span><span class="params">(FullHttpRequest request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为每个状态添加状态实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//单例controller类</span></span><br><span class="line">    <span class="keyword">final</span> DemoController demoController = DemoController.getInstance();</span><br><span class="line">    Map&lt;HttpLabel, Route&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="keyword">new</span> HttpLabel(<span class="string">"/login"</span>, HttpMethod.POST), demoController::login);</span><br><span class="line">    map.put(<span class="keyword">new</span> HttpLabel(<span class="string">"/logout"</span>, HttpMethod.POST), demoController::login);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接到请求，判断状态，调用不同接口：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">FullHttpRequest</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest request)</span> </span>&#123;</span><br><span class="line">        String uri = request.uri();</span><br><span class="line">        GeneralResponse generalResponse;</span><br><span class="line">        <span class="keyword">if</span> (uri.contains(<span class="string">"?"</span>)) &#123;</span><br><span class="line">            uri = uri.substring(<span class="number">0</span>, uri.indexOf(<span class="string">"?"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        Route route = map.get(<span class="keyword">new</span> HttpLabel(uri, request.method()));</span><br><span class="line">        <span class="keyword">if</span> (route != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ResponseUtil.response(ctx, request, route.call(request));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            generalResponse = <span class="keyword">new</span> GeneralResponse(HttpResponseStatus.BAD_REQUEST, <span class="string">"请检查你的请求方法及url"</span>, <span class="keyword">null</span>);</span><br><span class="line">            ResponseUtil.response(ctx, request, generalResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用状态设计模式重构代码，在增加url时只需要网map里面put一个值就行了。</p><h1 id="类似SpringMVC路由功能"><a href="#类似SpringMVC路由功能" class="headerlink" title="类似SpringMVC路由功能"></a>类似SpringMVC路由功能</h1><p>后来看了 <a href="https://yuerblog.cc/2018/03/08/java-router-with-annotation/" target="_blank" rel="noopener">JAVA反射+运行时注解实现URL路由</a> 发现反射+注解的方式很优雅，代码也不复杂。</p><p>下面介绍Netty使用反射实现URL路由。</p><p>路由注解：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由的uri</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">uri</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>扫描classpath下带有<code>@RequestMapping</code>注解的方法，将这个方法放进一个路由Map：<code>Map&lt;HttpLabel, Action&lt;GeneralResponse&gt;&gt; httpRouterAction</code>，key为上面提到过的Http唯一标识  <code>HttpLabel</code>，value为通过反射调用的方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRouter</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;HttpLabel, Action&lt;GeneralResponse&gt;&gt; httpRouterAction = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classpath = <span class="keyword">this</span>.getClass().getResource(<span class="string">""</span>).getPath();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; controllerBeans = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String path = classpath + name.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes;</span><br><span class="line">        <span class="keyword">try</span> (InputStream ins = <span class="keyword">new</span> FileInputStream(path)) &#123;</span><br><span class="line">            <span class="keyword">try</span> (ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line">                <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((b = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    out.write(buffer, <span class="number">0</span>, b);</span><br><span class="line">                &#125;</span><br><span class="line">                bytes = out.toByteArray();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRouter</span><span class="params">(String controllerClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; cls = loadClass(controllerClass);</span><br><span class="line">            Method[] methods = cls.getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span> (Method invokeMethod : methods) &#123;</span><br><span class="line">                Annotation[] annotations = invokeMethod.getAnnotations();</span><br><span class="line">                <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (annotation.annotationType() == RequestMapping.class) &#123;</span><br><span class="line">                        RequestMapping requestMapping = (RequestMapping) annotation;</span><br><span class="line">                        String uri = requestMapping.uri();</span><br><span class="line">                        String httpMethod = requestMapping.method().toUpperCase();</span><br><span class="line">                        <span class="comment">// 保存Bean单例</span></span><br><span class="line">                        <span class="keyword">if</span> (!controllerBeans.containsKey(cls.getName())) &#123;</span><br><span class="line">                            controllerBeans.put(cls.getName(), cls.newInstance());</span><br><span class="line">                        &#125;</span><br><span class="line">                        Action action = <span class="keyword">new</span> Action(controllerBeans.get(cls.getName()), invokeMethod);</span><br><span class="line">                        <span class="comment">//如果需要FullHttpRequest，就注入FullHttpRequest对象</span></span><br><span class="line">                        Class[] params = invokeMethod.getParameterTypes();</span><br><span class="line">                        <span class="keyword">if</span> (params.length == <span class="number">1</span> &amp;&amp; params[<span class="number">0</span>] == FullHttpRequest.class) &#123;</span><br><span class="line">                            action.setInjectionFullhttprequest(<span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 保存映射关系</span></span><br><span class="line">                        httpRouterAction.put(<span class="keyword">new</span> HttpLabel(uri, <span class="keyword">new</span> HttpMethod(httpMethod)), action);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"&#123;&#125;"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">getRoute</span><span class="params">(HttpLabel httpLabel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> httpRouterAction.get(httpLabel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过反射调用<code>controller</code> 类中的方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> injectionFullhttprequest;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) method.invoke(object, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            log.warn(<span class="string">"&#123;&#125;"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>ServerHandler.java</code>处理如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//根据不同的请求API做不同的处理(路由分发)</span></span><br><span class="line">Action&lt;GeneralResponse&gt; action = httpRouter.getRoute(<span class="keyword">new</span> HttpLabel(uri, request.method()));</span><br><span class="line"><span class="keyword">if</span> (action != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (action.isInjectionFullhttprequest()) &#123;</span><br><span class="line">        ResponseUtil.response(ctx, request, action.call(request));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ResponseUtil.response(ctx, request, action.call());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//错误处理</span></span><br><span class="line">    generalResponse = <span class="keyword">new</span> GeneralResponse(HttpResponseStatus.BAD_REQUEST, <span class="string">"请检查你的请求方法及url"</span>, <span class="keyword">null</span>);</span><br><span class="line">    ResponseUtil.response(ctx, request, generalResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>DemoController</code> 方法配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(uri = &quot;/login&quot;, method = &quot;POST&quot;)</span><br><span class="line">public GeneralResponse login(FullHttpRequest request) &#123;</span><br><span class="line">    User user = JsonUtil.fromJson(request, User.class);</span><br><span class="line">    log.info(&quot;/login called,user: &#123;&#125;&quot;, user);</span><br><span class="line">    return new GeneralResponse(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果如下：<br><img src="https://images.morethink.cn/5166aac96c36b6fca7645a5aca07f630.png" alt="" title="测试结果"></p><p>完整代码在 <a href="https://github.com/morethink/Netty-Route" target="_blank" rel="noopener">https://github.com/morethink/Netty-Route</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在用Netty做开发，需要提供一个http web server，供调用方调用。采用Netty本身提供的&lt;code&gt;HttpServerCodec&lt;/code&gt; handler进行Http协议的解析，但是需要自己提供路由。&lt;/p&gt;
&lt;p&gt;最开始是通过对Http method及uri 采用多层if else 嵌套判断的方法路由到真正的controller类：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String uri = request.uri();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HttpMethod method = request.method();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (method == HttpMethod.POST) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (uri.startsWith(&lt;span class=&quot;string&quot;&gt;&quot;/login&quot;&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//url参数解析，调用controller的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (uri.startsWith(&lt;span class=&quot;string&quot;&gt;&quot;/logout&quot;&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//同上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (method == HttpMethod.GET) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (uri.startsWith(&lt;span class=&quot;string&quot;&gt;&quot;/&quot;&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (uri.startsWith(&lt;span class=&quot;string&quot;&gt;&quot;/status&quot;&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.morethink.cn/categories/Java/"/>
    
    
      <category term="Netty" scheme="https://www.morethink.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Java使用UDP发送数据到InfluxDB</title>
    <link href="https://www.morethink.cn/Java-USES-InfluxDB-UDP-sending-data/"/>
    <id>https://www.morethink.cn/Java-USES-InfluxDB-UDP-sending-data/</id>
    <published>2018-09-22T16:00:00.000Z</published>
    <updated>2018-09-23T11:36:26.859Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做压测引擎相关的开发，需要将聚合数据发送到InfluxDB保存以便实时分析和控制QPS。</p><p>下面介绍对InfluxDB的使用。</p><h1 id="什么是InfluxDB"><a href="#什么是InfluxDB" class="headerlink" title="什么是InfluxDB"></a>什么是InfluxDB</h1><p>InfluxDB是一款用Go语言编写的开源分布式时序、事件和指标数据库，无需外部依赖。该数据库现在主要用于存储涉及大量的时间戳数据，如DevOps监控数据，APP metrics, loT传感器数据和实时分析数据。</p><a id="more"></a><p>InfluxDB特征：</p><ul><li>无结构(无模式)：可以是任意数量的列(tags)。</li><li>可以设置metric的保存时间。</li><li>支持与时间有关的相关函数(如min、max、sum、count、mean、median等)，方便统计。</li><li>支持存储策略：可以用于数据的删改(influxDB没有提供数据的删除与修改方法)。</li><li>支持连续查询：是数据库中自动定时启动的一组语句，和存储策略搭配可以降低InfluxDB的系统占用量。</li><li>原生的HTTP支持，内置HTTP API。</li><li>支持类似SQL语法。</li><li>支持设置数据在集群中的副本数。</li><li>支持定期采样数据，写入另外的measurement，方便分粒度存储数据。</li><li>自带web管理界面，方便使用(登入方式：http://&lt; InfluxDB-IP &gt;:8083)。</li><li>支持Grafana画图展示。</li></ul><p>PS：有了InfluxDB+Grafana后，你就可以写一些简单的程序了，可以只负责写后端逻辑部分，数据都可以存入InfluxDB，然后通过Grafana展示出来。</p><h1 id="Mac安装InfluxDB"><a href="#Mac安装InfluxDB" class="headerlink" title="Mac安装InfluxDB"></a>Mac安装InfluxDB</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 安装</span><br><span class="line">brew install influxdb</span><br><span class="line"><span class="meta">#</span> 启动</span><br><span class="line">influxd -config /usr/local/etc/influxdb.conf</span><br><span class="line"><span class="meta">#</span> 查看influxdb运行配置</span><br><span class="line">influxd config</span><br><span class="line"><span class="meta">#</span> 启动客户端</span><br><span class="line">influx -precision rfc3339</span><br></pre></td></tr></table></figure><h1 id="InfluxDB开启UDP配置"><a href="#InfluxDB开启UDP配置" class="headerlink" title="InfluxDB开启UDP配置"></a>InfluxDB开启UDP配置</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/etc/influxdb.conf</span><br></pre></td></tr></table></figure><p>开启udp配置，其他为默认值<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[[udp]]</span><br><span class="line">  enabled = true</span><br></pre></td></tr></table></figure></p><p>udp配置含义：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[[udp]] – udp配置</span><br><span class="line"></span><br><span class="line">    enabled：是否启用该模块，默认值：false。</span><br><span class="line"></span><br><span class="line">    bind-address：绑定地址，默认值：”:8089″。</span><br><span class="line"></span><br><span class="line">    database：数据库名称，默认值：”udp”。</span><br><span class="line"></span><br><span class="line">    retention-policy：存储策略，无默认值。</span><br><span class="line"></span><br><span class="line">    batch-size：默认值：5000。</span><br><span class="line"></span><br><span class="line">    batch-pending：默认值：10。</span><br><span class="line"></span><br><span class="line">    read-buffer：udp读取buffer的大小，0表示使用操作系统提供的值，如果超过操作系统的默认配置则会出错。 该配置的默认值：0。</span><br><span class="line"></span><br><span class="line">    batch-timeout：超时时间，默认值：”1s”。</span><br><span class="line"></span><br><span class="line">    precision：时间精度，无默认值。</span><br></pre></td></tr></table></figure></p><h1 id="Java发送UDP数据报"><a href="#Java发送UDP数据报" class="headerlink" title="Java发送UDP数据报"></a>Java发送UDP数据报</h1><p>我们知道InfluxDB是支持Http的，为什么我们还要采用UDP方式发送数据呢？</p><p>基于下列原因：</p><ol><li>TCP数据传输慢，UDP数据传输快。</li><li>网络带宽需求较小，而实时性要求高。</li><li>InfluxDB和服务器在同机房，发生数据丢包的可能性较小，即使真的发生丢包，对整个请求流量的收集影响也较小。</li></ol><p>我们采用了worker线程调用<code>addMetric</code>方法将数据存储到缓存 <code>map</code> 中，send线程池来进行每个指定时间发送数据到Influxdb。</p><p>代码如下(也可参考<code>Jmeter</code>的<code>UdpMetricsSender</code>类)：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfluxDBClient</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String measurement = <span class="string">"example"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InetAddress hostAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> udpPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, List&lt;Response&gt;&gt; metrics = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String transaction;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfluxDBClient</span><span class="params">(String influxdbUrl, String transaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transaction = transaction;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"Setting up with url:&#123;&#125;"</span>, influxdbUrl);</span><br><span class="line">            String[] urlComponents = influxdbUrl.split(<span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">if</span> (urlComponents.length == <span class="number">2</span>) &#123;</span><br><span class="line">                hostAddress = InetAddress.getByName(urlComponents[<span class="number">0</span>]);</span><br><span class="line">                udpPort = Integer.parseInt(urlComponents[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"InfluxDBClient url '"</span> + influxdbUrl + <span class="string">"' is wrong. The format shoule be &lt;host/ip&gt;:&lt;port&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"InfluxDBClient url '"</span> + influxdbUrl + <span class="string">"' is wrong. The format shoule be &lt;host/ip&gt;:&lt;port&gt;"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMetric</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (metrics.containsKey(response.getLabel())) &#123;</span><br><span class="line">                metrics.get(response.getLabel()).add(response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                metrics.put(response.getLabel(), <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.singletonList(response)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sendMetrics();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMetrics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, List&lt;Response&gt;&gt; tempMetrics;</span><br><span class="line">        <span class="comment">//复制数据到tempMetrics，清空原来metrics并初始化上次的大小</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(metrics)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            time = System.currentTimeMillis();</span><br><span class="line">            tempMetrics = metrics;</span><br><span class="line">            metrics = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Response&gt;&gt; entry : tempMetrics.entrySet()) &#123;</span><br><span class="line">                metrics.put(entry.getKey(), <span class="keyword">new</span> ArrayList&lt;&gt;(entry.getValue().size()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, List&lt;Response&gt;&gt; copyMetrics = tempMetrics;</span><br><span class="line">        <span class="keyword">final</span> List&lt;MetricTuple&gt; aggregateMetrics = aggregate(copyMetrics);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(aggregateMetrics.size() * <span class="number">200</span>);</span><br><span class="line">        <span class="comment">//发送tempMetrics,生成一行数据，然后换行</span></span><br><span class="line">        <span class="keyword">for</span> (MetricTuple metric : aggregateMetrics) &#123;</span><br><span class="line">            sb.append(metric.getMeasurement()).append(metric.getTag()).append(<span class="string">" "</span>)</span><br><span class="line">                    .append(metric.getField()).append(<span class="string">" "</span>).append(metric.getTimestamp() + <span class="string">"000000"</span>).append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//udp发送数据到Influxdb</span></span><br><span class="line">        <span class="keyword">try</span> (DatagramSocket ds = <span class="keyword">new</span> DatagramSocket()) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buf = sb.toString().getBytes();</span><br><span class="line">            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf, buf.length, <span class="keyword">this</span>.hostAddress, <span class="keyword">this</span>.udpPort);</span><br><span class="line">            ds.send(dp);</span><br><span class="line">            log.debug(<span class="string">"send &#123;&#125; to influxdb"</span>, sb.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Cannot open udp port!"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error in transferring udp package"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到聚合数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metrics</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;MetricTuple&gt; <span class="title">aggregate</span><span class="params">(Map&lt;String, List&lt;Response&gt;&gt; metrics)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Map&lt;String, List&lt;Response&gt;&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Response&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!entry.getValue().isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>参考文档</strong>：</p><ol><li><a href="https://jasper-zhang1.gitbooks.io/influxdb/content/" target="_blank" rel="noopener">InfluxDB中文文档</a></li><li><a href="http://www.ywnds.com/?p=10763" target="_blank" rel="noopener">玩转时序数据库InfluxDB</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做压测引擎相关的开发，需要将聚合数据发送到InfluxDB保存以便实时分析和控制QPS。&lt;/p&gt;
&lt;p&gt;下面介绍对InfluxDB的使用。&lt;/p&gt;
&lt;h1 id=&quot;什么是InfluxDB&quot;&gt;&lt;a href=&quot;#什么是InfluxDB&quot; class=&quot;headerlink&quot; title=&quot;什么是InfluxDB&quot;&gt;&lt;/a&gt;什么是InfluxDB&lt;/h1&gt;&lt;p&gt;InfluxDB是一款用Go语言编写的开源分布式时序、事件和指标数据库，无需外部依赖。该数据库现在主要用于存储涉及大量的时间戳数据，如DevOps监控数据，APP metrics, loT传感器数据和实时分析数据。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://www.morethink.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="InfluxDB" scheme="https://www.morethink.cn/tags/InfluxDB/"/>
    
      <category term="UDP" scheme="https://www.morethink.cn/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>Git为某个域名设置代理</title>
    <link href="https://www.morethink.cn/%E5%B7%A5%E5%85%B7/Git-set-proxy-for-a-domain/"/>
    <id>https://www.morethink.cn/工具/Git-set-proxy-for-a-domain/</id>
    <published>2018-08-03T16:00:00.000Z</published>
    <updated>2018-08-04T09:51:45.987Z</updated>
    
    <content type="html"><![CDATA[<p>国内访问Github很慢，可以通过配置代理来加快访问速度，但是对公司内部git服务器却不能使用代理。</p><p>下面通过更改Git配置文件对不同的域名使用不同的代理配置。<br><br><a id="more"></a></p><ol><li><p>打开Git 配置文件</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi ~/.gitconfig</span><br></pre></td></tr></table></figure></li><li><p>添加如下配置：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[http "https://github.com/"]</span><br><span class="line">    proxy = http://127.0.0.1:1081</span><br><span class="line">[https "https://github.com/"]</span><br><span class="line">    proxy = http://127.0.0.1:1081</span><br><span class="line">[http "https://my.comapnyserver.com/"]</span><br><span class="line">    proxy = ""</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国内访问Github很慢，可以通过配置代理来加快访问速度，但是对公司内部git服务器却不能使用代理。&lt;/p&gt;
&lt;p&gt;下面通过更改Git配置文件对不同的域名使用不同的代理配置。&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="https://www.morethink.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="https://www.morethink.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Java压缩/解压 .zip、.tar.gz、.tar.bz2(支持中文)</title>
    <link href="https://www.morethink.cn/Java%E5%8E%8B%E7%BC%A9/%E8%A7%A3%E5%8E%8B%20.zip%E3%80%81.tar.gz%E3%80%81.tar.bz2(%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87)/"/>
    <id>https://www.morethink.cn/Java压缩/解压 .zip、.tar.gz、.tar.bz2(支持中文)/</id>
    <published>2018-08-03T16:00:00.000Z</published>
    <updated>2018-10-14T16:09:56.337Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍Java压缩/解压.zip、.tar.gz、.tar.bz2的方式。</p><ol><li>对于zip文件：使用<code>java.util.zip.ZipEntry</code> 和 <code>java.util.zip.ZipFile</code>，通过设置<code>Charset</code>为<code>StandardCharsets.UTF_8</code>支持中文。</li><li>对于.tar.gz、tgz文件：可以看做先用tar打包，再使用gz进行压缩。使用<code>commons-compress</code>包的<code>TarArchiveInputStream</code>和<code>GzipCompressorInputStream</code>。</li><li>对于.tar.bz2文件：可以看做先用tar打包，再使用bz2进行压缩。使用<code>commons-compress</code>包的<code>TarArchiveInputStream</code>和<code>BZip2CompressorInputStream</code>。</li></ol><p>在这里有个问题如果使用<code>TarInputStream</code>搭配jdk的 <code>GZIPInputStream</code>会产生乱码。而使用<code>commons-compress</code>包的<code>TarArchiveInputStream</code>和<code>GzipCompressorInputStream</code>则可解决乱码问题。</p><a id="more"></a><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(ZipUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span> * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ZipUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有函数将文件集合压缩成tar包后返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> files  要压缩的文件集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target tar 输出流的目标文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> File  指定返回的目标文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">pack</span><span class="params">(List&lt;File&gt; files, File target)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(target)) &#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos, BUFFER_SIZE)) &#123;</span><br><span class="line">                <span class="keyword">try</span> (TarArchiveOutputStream taos = <span class="keyword">new</span> TarArchiveOutputStream(bos)) &#123;</span><br><span class="line">                    <span class="comment">//解决文件名过长问题</span></span><br><span class="line">                    taos.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);</span><br><span class="line">                    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                        taos.putArchiveEntry(<span class="keyword">new</span> TarArchiveEntry(file));</span><br><span class="line">                        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(file)) &#123;</span><br><span class="line">                            IOUtils.copy(fis, taos);</span><br><span class="line">                            taos.closeArchiveEntry();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将tar压缩成tar.gz文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outPutPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">compress</span><span class="params">(List&lt;File&gt; list, String outPutPath, String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File outPutFile = <span class="keyword">new</span> File(outPutPath + File.separator + fileName + <span class="string">".tar.gz"</span>);</span><br><span class="line">        File tempTar = <span class="keyword">new</span> File(<span class="string">"temp.tar"</span>);</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(pack(list, tempTar))) &#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis, BUFFER_SIZE)) &#123;</span><br><span class="line">                <span class="keyword">try</span> (FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(outPutFile)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> (GZIPOutputStream gzp = <span class="keyword">new</span> GZIPOutputStream(fos)) &#123;</span><br><span class="line">                        <span class="keyword">int</span> count;</span><br><span class="line">                        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">                        <span class="keyword">while</span> ((count = bis.read(data, <span class="number">0</span>, BUFFER_SIZE)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            gzp.write(data, <span class="number">0</span>, count);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Files.deleteIfExists(tempTar.toPath());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outPutFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">decompress</span><span class="params">(String filePath, String outputDir, <span class="keyword">boolean</span> isDeleted)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            LOG.error(<span class="string">"decompress file not exist."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (filePath.endsWith(<span class="string">".zip"</span>)) &#123;</span><br><span class="line">                unZip(file, outputDir);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (filePath.endsWith(<span class="string">".tar.gz"</span>) || filePath.endsWith(<span class="string">".tgz"</span>)) &#123;</span><br><span class="line">                decompressTarGz(file, outputDir);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (filePath.endsWith(<span class="string">".tar.bz2"</span>)) &#123;</span><br><span class="line">                decompressTarBz2(file, outputDir);</span><br><span class="line">            &#125;</span><br><span class="line">            filterFile(<span class="keyword">new</span> File(outputDir));</span><br><span class="line">            <span class="keyword">if</span> (isDeleted) &#123;</span><br><span class="line">                FileUtils.deleteQuietly(file);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOG.error(<span class="string">"decompress occur error."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解压 .zip 文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file      要解压的zip文件对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputDir 要解压到某个指定的目录下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unZip</span><span class="params">(File file, String outputDir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ZipFile zipFile = <span class="keyword">new</span> ZipFile(file, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">            <span class="comment">//创建输出目录</span></span><br><span class="line">            createDirectory(outputDir, <span class="keyword">null</span>);</span><br><span class="line">            Enumeration&lt;?&gt; enums = zipFile.entries();</span><br><span class="line">            <span class="keyword">while</span> (enums.hasMoreElements()) &#123;</span><br><span class="line">                ZipEntry entry = (ZipEntry) enums.nextElement();</span><br><span class="line">                <span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line">                    <span class="comment">//创建空目录</span></span><br><span class="line">                    createDirectory(outputDir, entry.getName());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> (InputStream in = zipFile.getInputStream(entry)) &#123;</span><br><span class="line">                        <span class="keyword">try</span> (OutputStream out = <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                                <span class="keyword">new</span> File(outputDir + File.separator + entry.getName()))) &#123;</span><br><span class="line">                            writeFile(in, out);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decompressTarGz</span><span class="params">(File file, String outputDir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (TarArchiveInputStream tarIn = <span class="keyword">new</span> TarArchiveInputStream(</span><br><span class="line">                <span class="keyword">new</span> GzipCompressorInputStream(</span><br><span class="line">                        <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                                <span class="keyword">new</span> FileInputStream(file))))) &#123;</span><br><span class="line">            <span class="comment">//创建输出目录</span></span><br><span class="line">            createDirectory(outputDir, <span class="keyword">null</span>);</span><br><span class="line">            TarArchiveEntry entry = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((entry = tarIn.getNextTarEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//是目录</span></span><br><span class="line">                <span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line">                    <span class="comment">//创建空目录</span></span><br><span class="line">                    createDirectory(outputDir, entry.getName());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//是文件</span></span><br><span class="line">                    <span class="keyword">try</span> (OutputStream out = <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                            <span class="keyword">new</span> File(outputDir + File.separator + entry.getName()))) &#123;</span><br><span class="line">                        writeFile(tarIn, out);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解压缩tar.bz2文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file      压缩包文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputDir 目标文件夹</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decompressTarBz2</span><span class="params">(File file, String outputDir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (TarArchiveInputStream tarIn =</span><br><span class="line">                     <span class="keyword">new</span> TarArchiveInputStream(</span><br><span class="line">                             <span class="keyword">new</span> BZip2CompressorInputStream(</span><br><span class="line">                                     <span class="keyword">new</span> FileInputStream(file)))) &#123;</span><br><span class="line">            createDirectory(outputDir, <span class="keyword">null</span>);</span><br><span class="line">            TarArchiveEntry entry;</span><br><span class="line">            <span class="keyword">while</span> ((entry = tarIn.getNextTarEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line">                    createDirectory(outputDir, entry.getName());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> (OutputStream out = <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                            <span class="keyword">new</span> File(outputDir + File.separator + entry.getName()))) &#123;</span><br><span class="line">                        writeFile(tarIn, out);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(InputStream in, OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">        <span class="keyword">while</span> ((length = in.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            out.write(b, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建目录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputDir</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subDir</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createDirectory</span><span class="params">(String outputDir, String subDir)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(outputDir);</span><br><span class="line">        <span class="comment">//子目录不为空</span></span><br><span class="line">        <span class="keyword">if</span> (!(subDir == <span class="keyword">null</span> || subDir.trim().equals(<span class="string">""</span>))) &#123;</span><br><span class="line">            file = <span class="keyword">new</span> File(outputDir + File.separator + subDir);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!file.getParentFile().exists()) &#123;</span><br><span class="line">                file.getParentFile().mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除Mac压缩再解压产生的 __MACOSX 文件夹和 .开头的其他文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filteredFile</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filterFile</span><span class="params">(File filteredFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (filteredFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            File[] files = filteredFile.listFiles();</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                <span class="keyword">if</span> (file.getName().startsWith(<span class="string">"."</span>) ||</span><br><span class="line">                        (file.isDirectory() &amp;&amp; file.getName().equals(<span class="string">"__MACOSX"</span>))) &#123;</span><br><span class="line">                    FileUtils.deleteQuietly(file);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码地址： <a href="https://github.com/morethink/code/blob/master/java/tools/src/main/java/cn/morethink/tools/util/ZipUtil.java" target="_blank" rel="noopener">https://github.com/morethink/code/blob/master/java/tools/src/main/java/cn/morethink/tools/util/ZipUtil.java</a></p><p><strong>参考文档</strong>：</p><ol><li><a href="https://www.programcreek.com/java-api-examples/?api=org.apache.commons.compress.archivers.tar.TarArchiveInputStream" target="_blank" rel="noopener">commons-compress官方实例</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍Java压缩/解压.zip、.tar.gz、.tar.bz2的方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于zip文件：使用&lt;code&gt;java.util.zip.ZipEntry&lt;/code&gt; 和 &lt;code&gt;java.util.zip.ZipFile&lt;/code&gt;，通过设置&lt;code&gt;Charset&lt;/code&gt;为&lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;支持中文。&lt;/li&gt;
&lt;li&gt;对于.tar.gz、tgz文件：可以看做先用tar打包，再使用gz进行压缩。使用&lt;code&gt;commons-compress&lt;/code&gt;包的&lt;code&gt;TarArchiveInputStream&lt;/code&gt;和&lt;code&gt;GzipCompressorInputStream&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;对于.tar.bz2文件：可以看做先用tar打包，再使用bz2进行压缩。使用&lt;code&gt;commons-compress&lt;/code&gt;包的&lt;code&gt;TarArchiveInputStream&lt;/code&gt;和&lt;code&gt;BZip2CompressorInputStream&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这里有个问题如果使用&lt;code&gt;TarInputStream&lt;/code&gt;搭配jdk的 &lt;code&gt;GZIPInputStream&lt;/code&gt;会产生乱码。而使用&lt;code&gt;commons-compress&lt;/code&gt;包的&lt;code&gt;TarArchiveInputStream&lt;/code&gt;和&lt;code&gt;GzipCompressorInputStream&lt;/code&gt;则可解决乱码问题。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://www.morethink.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB 及 Mysql 背后的 B/B+树</title>
    <link href="https://www.morethink.cn/%E7%AE%97%E6%B3%95/data-structure-behind-the-index/"/>
    <id>https://www.morethink.cn/算法/data-structure-behind-the-index/</id>
    <published>2018-06-30T16:00:00.000Z</published>
    <updated>2018-08-22T11:18:45.493Z</updated>
    
    <content type="html"><![CDATA[<p>索引是数据库常见的数据结构，每个后台开发人员都应该对索引背后的数据结构有所了解。</p><p>本文通过分析B-Tree及B-/+Tree数据结构及索引性能分析及磁盘存取原理尝试着回答一下问题：</p><ol><li>为什么B-Tree适合数据库索引及红黑树的二叉平衡树不适合作为索引</li><li>B+Tree比BTree做索引的优势</li><li>为什么MongoDB采用B-Tree作为索引结构而MySQL采用B+Tree作为索引存储结构</li></ol><a id="more"></a><h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h1><p>B 树（B-Tree）是为磁盘等辅助存取设备设计的一种平衡查找树，它实现了以 $O(\lg n)$ 时间复杂度执行查找、顺序读取、插入和删除操作。由于 B 树和 B 树的变种在降低磁盘 I/O 操作次数方面表现优异，所以经常用于设计文件系统和数据库。</p><p>使用阶来定义 B 树，一棵 m 阶的 B 树，需要满足下列条件：</p><ol><li>每个节点最多拥有m个子节点且m&gt;=2，空树除外</li><li><strong>除根节点外每个节点的关键字数量大于等于<code>ceil(m/2)-1</code>，小于等于<code>m-1</code>，非根节点关键字数必须&gt;=2</strong></li><li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子</li><li><strong>如果一个非叶节点有n个子节点，则该节点的关键字数等于n-1</strong></li><li>所有节点关键字是按递增次序排列，并遵循左小右大原则</li></ol><p>注：</p><ol><li>m阶代表一个树节点最多有多少个查找路径，m阶=m路,当m=2则是2叉树，m=3则是3叉。</li><li>ceil()是个朝正无穷方向取整的函数，如ceil(1.1)结果为2，即向上取整。</li></ol><p><img src="https://images.morethink.cn/B-Tree-1.jpg" alt="B-Tree" title="B-Tree"></p><p>B 树中的节点分为内部节点（Internal Node）和叶节点（Leaf Node），内部节点也就是非叶节点（Non-Leaf Node）。</p><h2 id="B-Tree的查找"><a href="#B-Tree的查找" class="headerlink" title="B-Tree的查找"></a>B-Tree的查找</h2><p>B-Tree的查找过程：根据给定值查找结点和在结点的关键字中进行查找交叉进行。</p><p>首先从根结点开始重复如下过程：若比结点的第一个关键字小，则查找在该结点第一个指针指向的结点进行；若等于结点中某个关键字，则查找成功；若在两个关键字之间，则查找在它们之间的指针指向的结点进行；若比该结点所有关键字大，则查找在该结点最后一个指针指向的结点进行；若查找已经到达某个叶结点，则说明给定值对应的数据记录不存在，查找失败。</p><p>例如：<br>在一棵 5 阶B-树中查找元素 29</p><p><img src="https://upload-images.jianshu.io/upload_images/1630488-43897a4dd77bf18f.gif" alt="" title="B-Tree的查询"></p><p>首先29比根节点值大，所以找根节点的右子数，然后再根据值得判断，发现 29 介于 28 和 48 之间，然后在从中间子树继续查找下去。</p><h2 id="B-Tree的插入"><a href="#B-Tree的插入" class="headerlink" title="B-Tree的插入"></a>B-Tree的插入</h2><p>插入的过程分两步完成：</p><ol><li><p>利用前述的B-树的查找算法查找关键字的插入位置。若找到，则说明该关键字已经存在，直接返回。否则查找操作必失败于某个最低层的非终端结点上。</p></li><li><p>判断该结点是否还有空位置。<strong>即判断该结点的关键字总数是否满足n&lt;=m-1</strong>。若满足，则说明该结点还有空位置，直接把关键字k插入到该结点的合适位置上。若不满足，说明该结点己没有空位置，需要把结点分裂成两个。</p></li></ol><p>分裂的方法是：<br>生成一新结点。把原结点上的关键字和k按升序排序后，<strong>从中间位置把关键字（不包括中间位置的关键字）分成两部分</strong>。左部分所含关键字放在旧结点中，右部分所含关键字放在新结点中，中间位置的关键字连同新结点的存储位置插入到父结点中。如果父结点的关键字个数也超过（m-1），则要再分裂，再往上插。直至这个过程传到根结点为止。</p><p>例子：</p><p><strong>如果该节点的元素个数还没达到 m，则插入完后无需处理</strong><br>比如：</p><p><img src="https://upload-images.jianshu.io/upload_images/1630488-25083e10d9708891.gif" alt="" title="在 B-树中插入元素 3"></p><p><strong>如果该节点元素个数达到 m 时，这时候将元素插入到合适的位置，将最中间的元素取出，成为该节点的父节点元素，然后将其余左右元素拆成两个新节点</strong></p><p>比如：</p><p><img src="https://upload-images.jianshu.io/upload_images/1630488-afa3b6b35908cf99.gif" alt="" title="在 B-树中插入元素 44"></p><p><strong>刚才的操作可能导致父节点的元素个数达到 m，这时候用情况 2 迭代处理，直到如果遇到根结点元素个数达到 m，则最中间元素将成为新的根结点。</strong></p><p>比如：</p><p><img src="https://upload-images.jianshu.io/upload_images/1630488-8dda91b45852ba9d.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="" title="在 B-树中插入元素 45"></p><h2 id="B-Tree-的删除"><a href="#B-Tree-的删除" class="headerlink" title="B-Tree 的删除"></a>B-Tree 的删除</h2><p>我们需要分两种情况进行讨论：</p><ul><li>如果该元素存在于叶子结点，直接删除它，无需进行其它处理。</li><li>如果该元素存在于非叶子节点，那么删除它将会留下一个空位，这时候我们需要一些处理来填充该位置。<br>因为节点的元素个数在 [M/2, M] 的范围内，所以比如这里我们以 5 阶B-树为例，判断节点元素是否充足即满足个数则至少拥有三（2 + 1）个元素的节点才算是有充足的元素。<ol><li>如果被删元素的左子树拥有足够的元素，这时候我们只需拿左子节点的最大值元素上来填充即可</li><li>当左子树不够元素而右子树元素充足时，这时候我们拿右子树的最小值元素上来进行填充</li><li>当左右子树所含元素均不足时，但左子树的左边兄弟节点的元素个数充足，这时我们需要拿左边的兄弟节点来进行调整。</li><li>当左右子树所含元素均不足时，但左子树的左边兄弟节点的元素个数也不足时，这时候我们还是拿左子树的最大值元素进行填充，之后再将该节点与其他节点合并形成新的节点。</li></ol></li></ul><h1 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h1><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p><p>与B-Tree相比，B+Tree有以下不同点：</p><ul><li>每个节点的指针上限为2d而不是2d+1。</li><li>B+Tree叶子节点保存了父节点的所有关键字和关键字记录的指针，每个叶子节点的关键字从小到大链接</li><li>内节点不存储data，只存储key；叶子节点不存储指针。因此所有数据地址必须要到叶子节点才能获取到，所以每次数据查询的次数都一样。<br><img src="https://images.morethink.cn/B+Tree.jpg" alt="" title="B+Tree"></li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，<strong>索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数</strong>。</p><p>下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p><h1 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h1><p>索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p><p>下面是磁盘的整体结构示意图：</p><p><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/6.png" alt="" title="磁盘的整体结构"></p><p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p><p>下面是磁盘结构的示意图：</p><p><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/7.png" alt="" title="磁盘结构"></p><p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p><p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p><h2 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h2><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。</p><p>这样做的理论依据是计算机科学中著名的局部性原理：</p><blockquote><p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p></blockquote><p>程序运行期间所需要的数据通常比较集中。</p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h1 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h1><p>一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为$O(h)=O(\log_d N)$。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>综上所述，用B-Tree作为索引结构效率是非常高的。</p><p><strong>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</strong></p><p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p><p>$$<br>d_{max}=floor({pagesize \over keysize+datasize+pointsize})<br>$$</p><p>floor表示向下取整。</p><p><strong>由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，容纳更多的节点，能够有效减少磁盘IO次数</strong>。</p><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p><p><img src="https://images.morethink.cn/B+Tree.jpg" alt="" title="B+Tree"></p><p>如上图图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，<strong>只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率</strong>。</p><p>综上所述：<br>B+Tree做索引的优势是：</p><ol><li>内部节点取消data域，每一页可以容纳更多的数据，有效减少磁盘IO次数。</li><li>数据都存储在叶子节点，所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。所以B+树查询时间复杂度为log n，而B树查询时间复杂度不固定，与所查结点在树中的位置有关，最好为O(1)。</li><li>通过增加顺序访问指针提高区间查询效率。</li></ol><p>而MongoDB索引选择B树可能是因为：<br>MongoDB 是文档型的数据库，是一种nosql，它使用BSON格式保存数据，归属于聚合型数据库。被设计用在数据模型简单，性能要求高的场合。之所以采用B树，是因为B树key和data域聚合在一起。因此并不需要类似于区间查询的操作。</p><p><strong>参考文档</strong>：</p><ol><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></li><li><a href="https://www.cnblogs.com/gaochundong/p/btree_and_bplustree.html#bplustree_implementation" target="_blank" rel="noopener">人人都是 DBA（VII）B 树和 B+ 树</a></li><li><a href="https://zhuanlan.zhihu.com/p/27700617" target="_blank" rel="noopener">平衡二叉树、B-Tree、B+Tree、B*树 理解其中一种你就都明白了</a></li><li><a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/B%E6%A0%91</a></li><li>B-Tree gif：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></li><li><a href="https://www.jianshu.com/p/ed76dbc0536d" target="_blank" rel="noopener">6. 数据结构 - B 树</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;索引是数据库常见的数据结构，每个后台开发人员都应该对索引背后的数据结构有所了解。&lt;/p&gt;
&lt;p&gt;本文通过分析B-Tree及B-/+Tree数据结构及索引性能分析及磁盘存取原理尝试着回答一下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么B-Tree适合数据库索引及红黑树的二叉平衡树不适合作为索引&lt;/li&gt;
&lt;li&gt;B+Tree比BTree做索引的优势&lt;/li&gt;
&lt;li&gt;为什么MongoDB采用B-Tree作为索引结构而MySQL采用B+Tree作为索引存储结构&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.morethink.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="https://www.morethink.cn/tags/%E6%A0%91/"/>
    
      <category term="索引" scheme="https://www.morethink.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MAC安装RabbitMQ</title>
    <link href="https://www.morethink.cn/MAC%E5%AE%89%E8%A3%85RabbitMQ/"/>
    <id>https://www.morethink.cn/MAC安装RabbitMQ/</id>
    <published>2018-05-11T16:00:00.000Z</published>
    <updated>2018-05-23T16:31:34.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install rabbitmq</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ol><li>添加环境变量<ul><li>打开配置文件<code>$ vi ~/.bash_profile</code></li><li>添加 <code>export PATH=$PATH:/usr/local/sbin</code><br>到末尾，编辑完后:wq保存退出。</li><li>使环境变量立即生效 <code>$ source ~/.bash_profile</code></li></ul></li><li>启动RabbitMQ服务<br>上面配置完成后，需要关闭终端窗口，重新打开，然后输入下面命令即可启动RabbitMQ服务：<code>rabbitmq-server</code></li><li>登录Web管理界面<br>浏览器输入localhost：15672，账号密码全输入guest即可登录。</li></ol><p>这里需要注意下，从3.3.1版本开始，RabbitMQ默认不允许远程ip登录，即只能使用localhost登录。如果希望远程登录，需要添加用户权限。</p><h1 id="设置RabbitMQ远程ip登录"><a href="#设置RabbitMQ远程ip登录" class="headerlink" title="设置RabbitMQ远程ip登录"></a>设置RabbitMQ远程ip登录</h1><p>由于账号guest具有所有的操作权限，并且又是默认账号，出于安全因素的考虑，guest用户只能通过localhost登陆使用，并建议修改guest用户的密码以及新建其他账号管理使用rabbitmq。<br>这里我们以创建个test帐号，密码123456为例，创建一个账号并支持远程ip访问。</p><ul><li><p>创建账号</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl add_user test 123456</span><br></pre></td></tr></table></figure></li><li><p>设置用户角色</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl  set_user_tags  test  administrator</span><br></pre></td></tr></table></figure></li><li><p>设置用户权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; test &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure></li><li><p>设置完成后可以查看当前用户和角色(需要开启服务)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure></li></ul><p>这是你就可以通过其他主机的访问RabbitMQ的Web管理界面了，访问方式，浏览器输入：serverip:15672。其中serverip是RabbitMQ-Server所在主机的ip。</p><h1 id="RabbitMQ常用操作"><a href="#RabbitMQ常用操作" class="headerlink" title="RabbitMQ常用操作"></a>RabbitMQ常用操作</h1><ol><li><p>用户管理<br>用户管理包括增加用户，删除用户，查看用户列表，修改用户密码。</p><ul><li><p>新增一个用户</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl  add_user  Username  Password</span><br></pre></td></tr></table></figure></li><li><p>删除一个用户</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl  delete_user  Username</span><br></pre></td></tr></table></figure></li><li><p>修改用户的密码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl  change_password  Username  Newpassword</span><br></pre></td></tr></table></figure></li><li><p>查看当前用户列表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl  list_users</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;brew update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;brew install rabbitmq&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="工具" scheme="https://www.morethink.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="MQ" scheme="https://www.morethink.cn/tags/MQ/"/>
    
      <category term="MAC" scheme="https://www.morethink.cn/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>科学上网之在VPS上安装SSR</title>
    <link href="https://www.morethink.cn/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E4%B9%8B%E5%9C%A8VPS%E4%B8%8A%E5%AE%89%E8%A3%85SSR/"/>
    <id>https://www.morethink.cn/科学上网之在VPS上安装SSR/</id>
    <published>2018-05-11T16:00:00.000Z</published>
    <updated>2018-05-23T16:31:30.777Z</updated>
    
    <content type="html"><![CDATA[<p>本文对VPS安装SSR的过程进行总结，免得因为XX重新安装SSR时找不到安装方法。</p><h1 id="安装SSR"><a href="#安装SSR" class="headerlink" title="安装SSR"></a>安装SSR</h1><p>简单的来说，如果你什么都不懂，那么你直接一路回车就可以了！<br><a id="more"></a><br>本脚本需要Linux root账户权限才能正常安装运行，所以 <strong>如果不是 root账号，请先切换为root，如果是 root账号，那么请跳过</strong>！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure><p>输入上面代码回车后会提示你输入当前用户的密码，输入并回车后，没有报错就继续下面的步骤安装ShadowsocksR。</p><p>v2.0.0 版本以后的脚本，请先卸载旧脚本ShadowsocksR服务端，再重新安装！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure><p>备用下载地址（上面的链接无法下载，就用这个）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure></p><p>下载运行后会提示你输入数字来选择要做什么。</p><p>运行脚本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash ssr.sh</span><br></pre></td></tr></table></figure><p>输入对应的数字来执行相应的命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  请输入一个数字来选择菜单选项</span><br><span class="line"></span><br><span class="line"> 1. 安装 ShadowsocksR</span><br><span class="line"> 2. 更新 ShadowsocksR</span><br><span class="line"> 3. 卸载 ShadowsocksR</span><br><span class="line"> 4. 安装 libsodium(chacha20)</span><br><span class="line">————————————</span><br><span class="line"> 5. 查看 账号信息</span><br><span class="line"> 6. 显示 连接信息</span><br><span class="line"> 7. 设置 用户配置</span><br><span class="line"> 8. 手动 修改配置</span><br><span class="line"> 9. 切换 端口模式</span><br><span class="line">————————————</span><br><span class="line"> 10. 启动 ShadowsocksR</span><br><span class="line"> 11. 停止 ShadowsocksR</span><br><span class="line"> 12. 重启 ShadowsocksR</span><br><span class="line"> 13. 查看 ShadowsocksR 日志</span><br><span class="line">————————————</span><br><span class="line"> 14. 其他功能</span><br><span class="line"> 15. 升级脚本</span><br><span class="line"></span><br><span class="line"> 当前状态: 已安装 并 已启动</span><br><span class="line"> 当前模式: 单端口</span><br><span class="line"></span><br><span class="line">请输入数字(1-15)：</span><br></pre></td></tr></table></figure></p><h1 id="文件位置"><a href="#文件位置" class="headerlink" title="文件位置"></a>文件位置</h1><ul><li>安装目录：<code>/usr/local/shadowsocksr</code></li><li>配置文件：<code>/etc/shadowsocksr/user-config.json</code></li></ul><h1 id="设置为系统服务"><a href="#设置为系统服务" class="headerlink" title="设置为系统服务"></a>设置为系统服务</h1><p>ShadowsocksR 安装后，自动设置为 系统服务，所以支持使用服务来启动/停止等操作，同时支持开机启动。</p><ul><li>启动 ShadowsocksR：<code>/etc/init.d/ssr start</code></li><li>停止 ShadowsocksR：<code>/etc/init.d/ssr stop</code></li><li>重启 ShadowsocksR：<code>/etc/init.d/ssr restart</code></li><li>查看 ShadowsocksR状态：<code>/etc/init.d/ssr status</code></li></ul><p>ShadowsocksR 默认支持UDP转发，服务端无需任何设置。</p><h1 id="定时重启"><a href="#定时重启" class="headerlink" title="定时重启"></a>定时重启</h1><p>一些人可能需要定时重启ShadowsocksR服务端来保证稳定性等，所以这里用 crontab 定时。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 输入这个命令可以查看当前配置的定时任务</span><br><span class="line">crontab -l</span><br><span class="line"># 如果提示命令不存在，下面是安装命令</span><br><span class="line"># CentOS系统：</span><br><span class="line">yum update</span><br><span class="line">yum install -y crond</span><br><span class="line"># Debian/Ubuntu系统：</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y cron</span><br></pre></td></tr></table></figure><p>安装 crontab 后，我们就能开始添加定时任务了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -l &gt; &quot;crontab.bak&quot;</span><br><span class="line">sed -i &quot;/ssr restart/d&quot; &quot;crontab.bak&quot;</span><br><span class="line">echo -e &quot;\n10 3 * * * /etc/init.d/ssr restart&quot; &gt;&gt; &quot;crontab.bak&quot;</span><br><span class="line">crontab &quot;crontab.bak&quot;</span><br><span class="line">rm -r &quot;crontab.bak&quot;</span><br></pre></td></tr></table></figure><p>下面是定时任务规则(代码前面的 <em> </em> <em> </em> * 分别对应：分钟 小时 日 月 星期)参考：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 2 * * * /etc/init.d/ssr restart</span><br><span class="line"># 这个代表 每天2点10分重启一次 ShadowsocksR</span><br><span class="line"></span><br><span class="line">10 2 */2 * * /etc/init.d/ssr restart</span><br><span class="line"># 这个代表 每隔2天的2点10分重启一次 ShadowsocksR</span><br><span class="line"></span><br><span class="line">10 */4 * * * /etc/init.d/ssr restart</span><br><span class="line"># 这个代表 每隔4小时的第10分重启一次 ShadowsocksR</span><br></pre></td></tr></table></figure><h1 id="BBR和锐速"><a href="#BBR和锐速" class="headerlink" title="BBR和锐速"></a>BBR和锐速</h1><p>BBR和锐速都是用来提高翻墙速度的。</p><p>BBR是来自于Google的黑科技，目的是通过优化和控制TCP的拥塞，充分利用带宽并降低延迟，其目的就是要尽量跑满带宽，并且尽量不要有排队的情况。<br>BBR 这个特性其实是在 Linux 内核 4.9 才计划加入的。所以，要开启BBR，需要内核版本在Linux kernel 4.9以上，脚本会帮助我们安装。</p><p>在BBR之前，比较有名的就是国产的锐速了，不过，由于锐速是个国产的闭源软件，可能存在安全性问题，因此 <strong>推荐使用安装BBR</strong>。</p><ul><li><p>启动脚本：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash ssr.sh</span><br></pre></td></tr></table></figure></li><li><p>选择<code>14. 其他功能</code></p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1. 配置 BBR</span><br><span class="line">  2. 配置 锐速(ServerSpeeder)</span><br><span class="line">  3. 配置 LotServer(锐速母公司)</span><br><span class="line">  注意： 锐速/LotServer/BBR 不支持 OpenVZ！</span><br><span class="line">  注意： 锐速/LotServer/BBR 不能共存！</span><br><span class="line">————————————</span><br><span class="line">  4. 一键封禁 BT/PT/SPAM (iptables)</span><br><span class="line">  5. 一键解封 BT/PT/SPAM (iptables)</span><br><span class="line">  6. 切换 ShadowsocksR日志输出模式</span><br><span class="line">  ——说明：SSR默认只输出错误日志，此项可切换为输出详细的访问日志</span><br></pre></td></tr></table></figure></li><li><p>安装BBR或者锐速(推荐BBR)</p></li></ul><h1 id="TCP优化"><a href="#TCP优化" class="headerlink" title="TCP优化"></a>TCP优化</h1><ul><li><p>增加TCP连接数量</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/security/limits.conf</span><br></pre></td></tr></table></figure></li><li><p>添加两行：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* soft nofile 51200</span><br><span class="line">* hard nofile 51200</span><br></pre></td></tr></table></figure></li><li><p>设置ulimit：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit -n 51200</span><br></pre></td></tr></table></figure></li><li><p>添加一些优化内容</p><ul><li><p>修改sysctl.conf</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  /etc/sysctl.conf</span><br></pre></td></tr></table></figure></li><li><p>插入代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#TCP配置优化(不然你自己根本不知道你在干什么)</span><br><span class="line">fs.file-max = 51200</span><br><span class="line">#提高整个系统的文件限制</span><br><span class="line">net.core.rmem_max = 67108864</span><br><span class="line">net.core.wmem_max = 67108864</span><br><span class="line">net.core.netdev_max_backlog = 250000</span><br><span class="line">net.core.somaxconn = 4096</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 8192</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line">net.ipv4.tcp_fastopen = 3</span><br><span class="line">net.ipv4.tcp_mem = 25600 51200 102400</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class="line">net.ipv4.tcp_mtu_probing = 1</span><br><span class="line">net.ipv4.tcp_congestion_control = bbr</span><br><span class="line">#END OF LINE</span><br></pre></td></tr></table></figure></li><li><p>应用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li><li><p>重启SSR</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ssr restart</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>参考文档</strong>：</p><ol><li><a href="https://jasper-1024.github.io/2016/06/26/VPS%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97/" target="_blank" rel="noopener">科学上网教程（一）——VPS上搭建SSR</a></li><li><a href="https://doub.io/ss-jc42" target="_blank" rel="noopener">『原创』CentOS/Debian/Ubuntu ShadowsocksR 单/多端口 一键管理脚本</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对VPS安装SSR的过程进行总结，免得因为XX重新安装SSR时找不到安装方法。&lt;/p&gt;
&lt;h1 id=&quot;安装SSR&quot;&gt;&lt;a href=&quot;#安装SSR&quot; class=&quot;headerlink&quot; title=&quot;安装SSR&quot;&gt;&lt;/a&gt;安装SSR&lt;/h1&gt;&lt;p&gt;简单的来说，如果你什么都不懂，那么你直接一路回车就可以了！&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="https://www.morethink.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>给你的博客园图片添加标题</title>
    <link href="https://www.morethink.cn/%E7%BB%99%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E6%A0%87%E9%A2%98/"/>
    <id>https://www.morethink.cn/给你的博客园图片添加标题/</id>
    <published>2018-05-05T16:00:00.000Z</published>
    <updated>2018-05-23T16:31:25.381Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来都觉得在图片下面添加一个标题可以更加清晰的表示这张图片的含义，可是博客园原生并不支持这种渲染方式，再加上博客园可以自己写js来更改主题，于是通过搜索资料完成给博客园图片添加标题的功能。</p><a id="more"></a><p>当我们如下书写markdown时：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://images.morethink.cn/092017231747399.jpg "TCP的三次握手和四次挥手")</span><br></pre></td></tr></table></figure></p><p>会被博客园渲染成<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://images.morethink.cn/092017231747399.jpg"</span> <span class="attr">title</span>=<span class="string">"TCP的三次握手和四次挥手"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>于是我就想通过在img标签后面动态添加一个带有<code>title</code>的p标签来给博客园图片添加标题。</p><p>将下面代码放入<code>页首Html代码</code>代码中即可(需要申请js权限)。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入jQuery --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="built_in">window</span>).load(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//给每张图片添加标题,div.cnblogs_post_body是博客主体</span></span></span><br><span class="line"><span class="javascript">        $(<span class="string">"div[id=cnblogs_post_body] img"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> title = $(<span class="keyword">this</span>).attr(<span class="string">"title"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (title != <span class="literal">undefined</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> boardp_style = <span class="string">"style='display: block; text-align: center; color: #969696;padding: 10px;border-bottom: 1px solid #d9d9d9;margin: 0 auto;"</span> +</span></span><br><span class="line"><span class="javascript">                    <span class="string">"width: "</span> + ($(<span class="keyword">this</span>).width() * <span class="number">0.8</span>) + <span class="string">"px;"</span> +</span></span><br><span class="line"><span class="javascript">                    <span class="string">"height: 28px;"</span> +</span></span><br><span class="line"><span class="javascript">                    <span class="string">"'&gt;"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> boardp = <span class="string">"&lt;p "</span> + boardp_style + title + <span class="string">"&lt;/p"</span>;</span></span><br><span class="line"><span class="javascript">                $(<span class="keyword">this</span>).after(boardp);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将img变为块级元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    img &#123;</span></span><br><span class="line"><span class="undefined">        margin: 0 auto;</span></span><br><span class="line"><span class="undefined">        display: block;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>markdown图片：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://images.morethink.cn/092017231747399.jpg "TCP的三次握手和四次挥手")</span><br></pre></td></tr></table></figure></p><p><img src="https://images.morethink.cn/092017231747399.jpg" alt="" title="TCP的三次握手和四次挥手"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来都觉得在图片下面添加一个标题可以更加清晰的表示这张图片的含义，可是博客园原生并不支持这种渲染方式，再加上博客园可以自己写js来更改主题，于是通过搜索资料完成给博客园图片添加标题的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://www.morethink.cn/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Cron表达式</title>
    <link href="https://www.morethink.cn/Linux/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://www.morethink.cn/Linux/Cron表达式/</id>
    <published>2018-04-21T16:00:00.000Z</published>
    <updated>2018-05-23T16:31:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Cron表达式范例：</strong></p><ul><li><code>*/5 * * * * ?</code>  ：每隔5<code>秒</code>执行一次</li><li><code>0 */1 * * * ?</code>  ：每隔1分钟执行一次</li><li><code>0 0 23 * * ?</code>   ：每天23点执行一次</li><li><code>0 0 1 * * ?</code>    ：每天凌晨1点执行一次：</li><li><code>0 0 1 1 * ?</code>  ：每月1号凌晨1点执行一次</li><li><code>0 0 23 L * ?</code> ： 每月最后一天23点执行一次</li><li><code>0 0 1 ? * L</code>  ：每周星期天凌晨1点实行一次</li><li><code>0 26,29,33 * * * ?</code> ： 在26分、29分、33分执行一次</li><li><code>0 0 0,13,18,21 * * ?</code> ： 每天的0点、13点、18点、21点都执行一次<a id="more"></a><h1 id="Cron表达式"><a href="#Cron表达式" class="headerlink" title="Cron表达式"></a>Cron表达式</h1></li></ul><p>Cron表达式由7个部分组成，各部分用空格隔开，Cron表达式的7个部分从左到右代表的含义如下：</p><p><code>秒</code> <code>分</code> <code>时</code> <code>日</code> <code>月</code> <code>周</code> <code>年</code><br>其中 <code>年</code>是可选的。</p><table><thead><tr><th>字段名</th><th>允许的值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td><code>秒</code></td><td>0-59</td><td>,- * /</td><td></td></tr><tr><td><code>分</code></td><td>0-59</td><td>,- * /</td><td></td></tr><tr><td><code>时</code></td><td>0-23</td><td>,- * /</td><td></td></tr><tr><td><code>日</code></td><td>1-31</td><td>,- * ? / L W C</td><td></td></tr><tr><td><code>月</code></td><td>1-12 or JAN-DEC</td><td>,- * /</td><td></td></tr><tr><td><code>周</code></td><td>1-7 or SUN-SAT</td><td>,- * ? / L C #</td><td></td></tr><tr><td><code>年</code> (可选字段)</td><td>empty，1970-2099</td><td>,- * /</td></tr></tbody></table><h1 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h1><ul><li><code>,</code>：表示列出枚举值值。例如在<code>分</code>使用5,20，则意味着在5和20分每分钟触发一次。</li><li><code>-</code>：表示范围。例如在<code>分</code>使用5-20，表示从5分到20分钟每分钟触发一次。</li><li><code>*</code> ：表示匹配该域的任意值。假如在<code>分</code>域使用<code>*</code>，即表示每分钟都会触发事件。</li><li><code>/</code> ：表示起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次。</li><li><code>?</code> ：只能用在<code>周</code>和<code>日</code>。它也匹配域的任意值，但实际不会。因为<code>周</code>和<code>日</code>会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 <em> ?,其中最后一位只能用？，而不能使用</em>，如果使用*表示不管星期几都会触发，实际上并不是这样。    </li><li><code>L</code> ： 表示最后，只能出现在<code>日</code>和<code>周</code>，如果在<code>日</code>使用5L,意味着在最后的一个星期四触发。  </li><li><code>W</code>：表示有效工作日(周一到周五),只能出现在<code>周</code>域，系统将在离指定日期的最近的有效工作日触发事件。例如：在<code>日</code>使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份。</li><li><code>#</code>：用于确定每个月第几个星期几，只能出现在<code>周</code>。例如在4#2，表示某月的第二个星期三。</li></ul><p><strong>参考文档</strong>：</p><ol><li><a href="http://Cron.qqe2.com/" target="_blank" rel="noopener">在线Cron表达式生成器</a></li><li><a href="https://www.jianshu.com/p/f03b1497122a" target="_blank" rel="noopener">QuartZ Cron表达式详解</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Cron表达式范例：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*/5 * * * * ?&lt;/code&gt;  ：每隔5&lt;code&gt;秒&lt;/code&gt;执行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 */1 * * * ?&lt;/code&gt;  ：每隔1分钟执行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 0 23 * * ?&lt;/code&gt;   ：每天23点执行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 0 1 * * ?&lt;/code&gt;    ：每天凌晨1点执行一次：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 0 1 1 * ?&lt;/code&gt;  ：每月1号凌晨1点执行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 0 23 L * ?&lt;/code&gt; ： 每月最后一天23点执行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 0 1 ? * L&lt;/code&gt;  ：每周星期天凌晨1点实行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 26,29,33 * * * ?&lt;/code&gt; ： 在26分、29分、33分执行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 0 0,13,18,21 * * ?&lt;/code&gt; ： 每天的0点、13点、18点、21点都执行一次
    
    </summary>
    
      <category term="Linux" scheme="https://www.morethink.cn/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>GitHub更新已经fork的项目</title>
    <link href="https://www.morethink.cn/%E5%B7%A5%E5%85%B7/GitHub%E6%9B%B4%E6%96%B0%E5%B7%B2%E7%BB%8Ffork%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    <id>https://www.morethink.cn/工具/GitHub更新已经fork的项目/</id>
    <published>2018-04-21T16:00:00.000Z</published>
    <updated>2018-05-23T16:31:20.473Z</updated>
    
    <content type="html"><![CDATA[<p>当我们fork一个项目后，在我们使用代码的时候就会以我们本地为准，不会跟随我们fork前的项目，如果需要同步对方的代码，需要进行同步操作。</p><a id="more"></a><ol><li>clone 自己的 fork 分支到本地<br>可以直接使用 GitHub 客户端，clone 到本地，如果使用命令行，命令为：<br><code>$ git clone  git@github.com:morethink/git-recipes.git</code></li><li><p>进入仓库，增加源分支地址到你项目远程分支列表中<br>此处是关键，先得将原来的仓库指定为 upstream，命令为：<br><code>$ git remote add upstream git@github.com:geeeeeeeeek/git-recipes.git</code><br>此处可使用 <code>git remote -v</code> 查看远程分支列表</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origingit@github.com:morethink/git-recipes.git (fetch)</span><br><span class="line">origingit@github.com:morethink/git-recipes.git (push)</span><br><span class="line">upstreamgit@github.com:geeeeeeeeek/git-recipes.git (fetch)</span><br><span class="line">upstreamgit@github.com:geeeeeeeeek/git-recipes.git (push)</span><br></pre></td></tr></table></figure></li><li><p>fetch 源分支的新版本到本地<br><code>$ git fetch upstream</code></p></li><li>切换到本地master分支<br><code>$ git checkout master</code></li><li>合并两个版本的代码<br><code>$ git merge upstream/master</code></li><li>将合并后的代码 push 到 GitHub 上去<br><code>$ git push origin master</code></li></ol><p><strong>参考文档：</strong></p><ol><li>添加远程分支<br><a href="https://help.github.com/articles/configuring-a-remote-for-a-fork/" target="_blank" rel="noopener">https://help.github.com/articles/configuring-a-remote-for-a-fork/</a></li><li>完成同步<br><a href="https://help.github.com/articles/syncing-a-fork/" target="_blank" rel="noopener">https://help.github.com/articles/syncing-a-fork/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们fork一个项目后，在我们使用代码的时候就会以我们本地为准，不会跟随我们fork前的项目，如果需要同步对方的代码，需要进行同步操作。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://www.morethink.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="https://www.morethink.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>常见web攻击总结</title>
    <link href="https://www.morethink.cn/%E5%B8%B8%E8%A7%81web%E6%94%BB%E5%87%BB%E6%80%BB%E7%BB%93/"/>
    <id>https://www.morethink.cn/常见web攻击总结/</id>
    <published>2018-04-06T16:00:00.000Z</published>
    <updated>2018-04-07T10:17:36.145Z</updated>
    
    <content type="html"><![CDATA[<p>搞Web开发离不开安全这个话题，确保网站或者网页应用的安全性，是每个开发人员都应该了解的事。本篇主要简单介绍在Web领域几种常见的攻击手段及Java Web中的预防方式。</p><ul><li><a href="#XSS">XSS</a></li><li><a href="#SQL注入">SQL注入</a></li><li><a href="#DDOS">DDOS</a></li><li><a href="#CSRF">CSRF</a></li></ul><a id="more"></a><p>项目地址： <a href="https://github.com/morethink/web-security" target="_blank" rel="noopener">https://github.com/morethink/web-security</a></p><h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><h2 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h2><p>XSS攻击：跨站脚本攻击(Cross-Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。XSS是一种常见的web安全漏洞，它允许攻击者将恶意代码植入到提供给其它用户使用的页面中。不同于大多数攻击(一般只涉及攻击者和受害者)，XSS涉及到三方，即攻击者、客户端与Web应用。XSS的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。</p><p>XSS通常可以分为两大类：</p><ol><li>存储型XSS，主要出现在让用户输入数据，供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等。应用程序从数据库中查询数据，在页面中显示出来，攻击者在相关页面输入恶意的脚本数据后，用户浏览此类页面时就可能受到攻击。这个流程简单可以描述为：<code>恶意用户的Html输入Web程序-&gt;进入数据库-&gt;Web程序-&gt;用户浏览器</code>。</li><li>反射型XSS，主要做法是将脚本代码加入URL地址的请求参数里，请求参数进入程序后在页面直接输出，用户点击类似的恶意链接就可能受到攻击。</li></ol><p>比如说我写了一个网站，然后攻击者在上面发布了一个文章，内容是这样的 <code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>,如果我没有对他的内容进行处理，直接存储到数据库，那么下一次当其他用户访问他的这篇文章的时候，服务器从数据库读取后然后响应给客户端，浏览器执行了这段脚本，就会将cookie展现出来，这就是典型的存储型XSS。</p><p>如图：<br><img src="https://images.morethink.cn/a1c6ebf6de227e086d0289f34d8c5f76.png" alt=""></p><h2 id="如何预防XSS"><a href="#如何预防XSS" class="headerlink" title="如何预防XSS"></a>如何预防XSS</h2><p>答案很简单，坚决不要相信用户的任何输入，并过滤掉输入中的所有特殊字符。这样就能消灭绝大部分的XSS攻击。</p><p>目前防御XSS主要有如下几种方式：</p><ol><li>过滤特殊字符<br>避免XSS的方法之一主要是将用户所提供的内容进行过滤(如上面的<code>script</code>标签)。</li><li>使用HTTP头指定类型<br><code>w.Header().Set(&quot;Content-Type&quot;,&quot;text/javascript&quot;)</code><br>这样就可以让浏览器解析javascript代码，而不会是html输出。</li></ol><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="什么是SQL注入"><a href="#什么是SQL注入" class="headerlink" title="什么是SQL注入"></a>什么是SQL注入</h2><p>攻击者成功的向服务器提交恶意的SQL查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。</p><p>举例：<code>&#39; OR &#39;1&#39;=&#39;1</code></p><p>这是最常见的 SQL注入攻击，当我们输如用户名 admin ，然后密码输如<code>&#39; OR &#39;1&#39;=1=&#39;1</code>的时候，我们在查询用户名和密码是否正确的时候，本来要执行的是<code>SELECT * FROM user WHERE username=&#39;&#39; and password=&#39;&#39;</code>,经过参数拼接后，会执行 SQL语句 <code>SELECT * FROM user WHERE username=&#39;&#39; and password=&#39;&#39; OR &#39;1&#39;=&#39;1&#39;</code>，这个时候1=1是成立，自然就跳过验证了。<br>如下图所示：</p><p><img src="https://images.morethink.cn/69855b1538333659f26afc281feb4e30.png" alt=""></p><p>但是如果再严重一点，密码输如的是<code>&#39;;DROP TABLE user;--</code>，那么 SQL命令为<code>SELECT *  FROM user WHERE username=&#39;admin&#39; and password=&#39;&#39;;drop table user;--&#39;</code> 这个时候我们就直接把这个表给删除了。</p><h2 id="如何预防SQL注入"><a href="#如何预防SQL注入" class="headerlink" title="如何预防SQL注入"></a>如何预防SQL注入</h2><ul><li>在Java中，我们可以使用预编译语句(PreparedStatement)，这样的话即使我们使用 SQL语句伪造成参数，到了服务端的时候，这个伪造 SQL语句的参数也只是简单的字符，并不能起到攻击的作用。</li><li>对进入数据库的特殊字符（<code>&#39;&quot;\尖括号&amp;*</code>;等）进行转义处理，或编码转换。</li><li>在应用发布之前建议使用专业的SQL注入检测工具进行检测，以及时修补被发现的SQL注入漏洞。网上有很多这方面的开源工具，例如sqlmap、SQLninja等。</li><li>避免网站打印出SQL错误信息，比如类型错误、字段不匹配等，把代码里的SQL语句暴露出来，以防止攻击者利用这些错误信息进行SQL注入。</li></ul><p>在上图展示中，使用了Java JDBC中的<code>PreparedStatement</code>预编译预防SQL注入，可以看到将所有输入都作为了字符串，避免执行恶意SQL。</p><h1 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h1><h2 id="什么是DDOS"><a href="#什么是DDOS" class="headerlink" title="什么是DDOS"></a>什么是DDOS</h2><p>DDOS：分布式拒绝服务攻击（Distributed Denial of Service），简单说就是发送大量请求是使服务器瘫痪。DDos攻击是在DOS攻击基础上的，可以通俗理解，dos是单挑，而ddos是群殴，因为现代技术的发展，dos攻击的杀伤力降低，所以出现了DDOS，攻击者借助公共网络，将大数量的计算机设备联合起来，向一个或多个目标进行攻击。</p><p>在技术角度上，DDoS攻击可以针对网络通讯协议的各层，手段大致有：TCP类的SYN Flood、ACK Flood，UDP类的Fraggle、Trinoo，DNS Query Flood，ICMP Flood，Slowloris类等等。一般会根据攻击目标的情况，针对性的把技术手法混合，以达到最低的成本最难防御的目的，并且可以进行合理的节奏控制，以及隐藏保护攻击资源。</p><p>下面介绍一下TCP协议中的SYN攻击。</p><h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><p>在三次握手过程中，服务器发送 <code>SYN-ACK</code> 之后，收到客户端的 <code>ACK</code> 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 <code>SYN_RCVD</code> 状态。当收到 ACK 后，服务器才能转入 <code>ESTABLISHED</code> 状态.</p><p><code>SYN</code>攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送<code>SYN</code>包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的<code>SYN</code>包将长时间占用未连接队列，正常的<code>SYN</code>请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p><h2 id="如何预防DDOS"><a href="#如何预防DDOS" class="headerlink" title="如何预防DDOS"></a>如何预防DDOS</h2><p>阿里巴巴的安全团队在实战中发现，DDoS 防御产品的核心是检测技术和清洗技术。检测技术就是检测网站是否正在遭受 DDoS 攻击，而清洗技术就是清洗掉异常流量。而检测技术的核心在于对业务深刻的理解，才能快速精确判断出是否真的发生了 DDoS 攻击。清洗技术对检测来讲，不同的业务场景下要求的粒度不一样。</p><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h2 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h2><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p><p>你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p><h2 id="CSRF的原理"><a href="#CSRF的原理" class="headerlink" title="CSRF的原理"></a>CSRF的原理</h2><p>下图简单阐述了CSRF攻击的思<br><img src="https://images.morethink.cn/138ad4f05b47533bf46904dc165167cc.png" alt=""></p><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><ol><li>登录受信任网站A，并在本地生成Cookie。</li><li>在不登出A的情况下，访问危险网站B。</li></ol><p>看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：</p><ol><li>你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</li><li>你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</li><li>上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li></ol><p>下面讲一讲java解决CSRF攻击的方式。</p><h2 id="模拟CSRF攻击"><a href="#模拟CSRF攻击" class="headerlink" title="模拟CSRF攻击"></a>模拟CSRF攻击</h2><h3 id="登录A网站"><a href="#登录A网站" class="headerlink" title="登录A网站"></a>登录A网站</h3><p>用户名和密码都是admin。</p><p><code>http://localhost:8081/login.html</code>:<br><img src="https://images.morethink.cn/e298f8ef08869557b8fb60034f06bb80.png" alt=""></p><h3 id="你有权限删除1号帖子"><a href="#你有权限删除1号帖子" class="headerlink" title="你有权限删除1号帖子"></a>你有权限删除1号帖子</h3><p><code>http://localhost:8081/deletePost.html</code>:<br><img src="https://images.morethink.cn/897d358f2677d053bb9555ff69d112ac.png" alt=""></p><h3 id="登录有CSRF攻击A网站的B网站"><a href="#登录有CSRF攻击A网站的B网站" class="headerlink" title="登录有CSRF攻击A网站的B网站"></a>登录有CSRF攻击A网站的B网站</h3><p><code>http://localhost:8082/deletePost.html</code>:</p><p><img src="https://images.morethink.cn/csrf-attack.gif" alt=""></p><p>明显看到B网站是8082端口，A网站是8081端口，但是B网站的删除2号帖子功能依然实现。</p><h2 id="如何预防CSRF攻击"><a href="#如何预防CSRF攻击" class="headerlink" title="如何预防CSRF攻击"></a>如何预防CSRF攻击</h2><p>简单来说，CSRF 就是网站 A 对用户建立信任关系后，在网站 B 上利用这种信任关系，跨站点向网站 A 发起一些伪造的用户操作请求，以达到攻击的目的。</p><p>而之所以可以完成攻击是因为B向A发起攻击的时候会把A网站的cookie带给A网站，也就是说cookie已经不安全了。</p><h3 id="通过Synchronizer-Tokens"><a href="#通过Synchronizer-Tokens" class="headerlink" title="通过Synchronizer Tokens"></a>通过Synchronizer Tokens</h3><p>Synchronizer Tokens： 在表单里隐藏一个随机变化的 csrf_token csrf_token 提交到后台进行验证，如果验证通过则可以继续执行操作。这种情况有效的主要原因是网站 B 拿不到网站 A 表单里的 csrf_token</p><p>这种方式的使用条件是PHP和JSP等。因为cookie已经不安全了，因此把csrf_token值存储在session中，然后每次表单提交时都从session取出来放到form表单的隐藏域中，这样B网站不可以得到这个存储到session中的值。</p><p>下面是JSP的：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;input type="hidden" name="random_form" value=&lt;%=random%&gt;&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure></p><p>但是我现在的情况是html，不是JSP，并不能动态的从session中取出csrf_token值。只能采用加密的方式了。</p><h3 id="Hash加密cookie中csrf-token值"><a href="#Hash加密cookie中csrf-token值" class="headerlink" title="Hash加密cookie中csrf_token值"></a>Hash加密cookie中csrf_token值</h3><p>这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了。</p><p>我采用的hash加密方法是JS实现Java的HashCode方法，得到hash值，这个比较简单。也可以采用其他的hash算法。</p><p>前端向后台传递hash之后的csrf_token值和cookie中的csrf_token值，后台拿到cookie中的csrf_token值后得到hashCode值然后与前端传过来的值进行比较，一样则通过。</p><h4 id="你有权限删除3号帖子"><a href="#你有权限删除3号帖子" class="headerlink" title="你有权限删除3号帖子"></a>你有权限删除3号帖子</h4><p><code>http://localhost:8081/deletePost.html</code></p><p><img src="https://images.morethink.cn/2ac5eab98780646c6c36dcdc98fa50c7.png" alt=""></p><h4 id="B网站的他已经没有权限了"><a href="#B网站的他已经没有权限了" class="headerlink" title="B网站的他已经没有权限了"></a>B网站的他已经没有权限了</h4><p>我们通过UserFilter.java给攻击者返回的是403错误，表示服务器理解用户客户端的请求但拒绝处理。</p><p><code>http://localhost:8082/deletePost.html</code>:<br><img src="https://images.morethink.cn/csrf-attack-fail-failure.gif" alt=""></p><p>攻击者不能删除4号帖子。</p><p>前端代码：</p><p>deletePost.html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>deletePost<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">deletePost</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> url = <span class="string">'/post/'</span> + <span class="built_in">document</span>.getElementById(<span class="string">"postId"</span>).value;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> csrf_token = <span class="built_in">document</span>.cookie.replace(<span class="regexp">/(?:(?:^|.*;\s*)csrf_token\s*\=\s*([^;]*).*$)|^.*$/</span>, <span class="string">"$1"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'csrf_token='</span> + csrf_token);</span></span><br><span class="line"><span class="javascript">            $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                type: <span class="string">"post"</span>,<span class="comment">//请求方式</span></span></span><br><span class="line"><span class="javascript">                url: url,  <span class="comment">//发送请求地址</span></span></span><br><span class="line"><span class="javascript">                timeout: <span class="number">30000</span>,<span class="comment">//超时时间：30秒</span></span></span><br><span class="line"><span class="undefined">                data: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="string">"_method"</span>: <span class="string">"delete"</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">"csrf_token"</span>: hash(csrf_token) <span class="comment">// 对csrf_token进行hash加密</span></span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="javascript">                dataType: <span class="string">"json"</span>,<span class="comment">//设置返回数据的格式</span></span></span><br><span class="line"><span class="javascript">                success: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (result.message == <span class="string">"success"</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        $(<span class="string">"#result"</span>).text(<span class="string">"删除成功"</span>);</span></span><br><span class="line"><span class="javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                        $(<span class="string">"#result"</span>).text(<span class="string">"删除失败"</span>);</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="javascript">                error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//请求出错的处理</span></span></span><br><span class="line"><span class="javascript">                    $(<span class="string">"#result"</span>).text(<span class="string">"请求出错"</span>);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// javascript的String到int(32位)的hash算法</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">str</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> hash = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (str.length == <span class="number">0</span>) <span class="keyword">return</span> hash;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span></span><br><span class="line"><span class="undefined">                char = str.charCodeAt(i);</span></span><br><span class="line"><span class="undefined">                hash = ((hash &lt;&lt; 5) - hash) + char;</span></span><br><span class="line"><span class="javascript">                hash = hash &amp; hash; <span class="comment">// Convert to 32bit integer</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> hash;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>删除帖子<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">帖子编号 ： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"postId"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"deletePost();"</span>&gt;</span>deletePost<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后台代码：</p><p>UserInterceptor.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.morethink.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.morethink.util.JsonUtil;</span><br><span class="line"><span class="keyword">import</span> cn.morethink.util.Result;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李文浩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/1/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        System.out.println(method);</span><br><span class="line">        <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">"POST"</span>) || method.equalsIgnoreCase(<span class="string">"DELETE"</span>)</span><br><span class="line">                || method.equalsIgnoreCase(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line">            String csrf_token = request.getParameter(<span class="string">"csrf_token"</span>);</span><br><span class="line">            Cookie[] cookies = request.getCookies();</span><br><span class="line">            <span class="keyword">if</span> (cookies != <span class="keyword">null</span> &amp;&amp; cookies.length &gt; <span class="number">0</span> &amp;&amp; csrf_token != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cookie.getName().equals(<span class="string">"csrf_token"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (Integer.valueOf(csrf_token) == cookie.getValue().hashCode()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Result result = <span class="keyword">new</span> Result(<span class="string">"403"</span>, <span class="string">"你还想攻击我??????????"</span>, <span class="string">""</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.write(JsonUtil.toJson(result));</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>cookie必须要设置PATH才可以生效，否则在下一次请求的时候无法带给服务器。</li><li>Spring Boot 出现启动找不到主类的问题时可以mvn clean一下。</li><li>Filter设置response.sendError(403)在Spring Boot没有效果。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面一共提到了4种攻击方式，分别是XSS攻击（关键是脚本，利用恶意脚本发起攻击），SQL注入（关键是通过用SQL语句伪造参数发出攻击），DDOS攻击（关键是发出大量请求，最后令服务器崩溃），CSRF攻击（关键是借助本地cookie进行认证，伪造发送请求）。</p><p><strong>参考文档</strong>：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/24249045" target="_blank" rel="noopener">XSS实战：我是如何拿下你的百度账号</a></li><li><a href="http://www.cnblogs.com/-new/p/7135814.html" target="_blank" rel="noopener">总结几种常见web攻击手段及其防御方式</a></li><li><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈CSRF攻击方式</a></li><li><a href="http://blog.csdn.net/zzhongcy/article/details/20133883" target="_blank" rel="noopener">jQueue 动态设置form表单的action属性的值和方法</a></li><li><a href="https://www.thinksaas.cn/group/topic/304242/" target="_blank" rel="noopener">javascript的String到int(32位)的hash算法</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搞Web开发离不开安全这个话题，确保网站或者网页应用的安全性，是每个开发人员都应该了解的事。本篇主要简单介绍在Web领域几种常见的攻击手段及Java Web中的预防方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#XSS&quot;&gt;XSS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#SQL注入&quot;&gt;SQL注入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#DDOS&quot;&gt;DDOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#CSRF&quot;&gt;CSRF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Web安全" scheme="https://www.morethink.cn/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Git同时push到多个远程仓库</title>
    <link href="https://www.morethink.cn/%E5%B7%A5%E5%85%B7/Git%E5%90%8C%E6%97%B6push%E5%88%B0%E5%A4%9A%E4%B8%AA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>https://www.morethink.cn/工具/Git同时push到多个远程仓库/</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-05-23T16:31:10.718Z</updated>
    
    <content type="html"><![CDATA[<p>添加第二个远程地址时使用以下命令：<br><code>git remote set-url --add origin git@github.com:morethink/programming.git</code></p><p>查看远程分支：<code>git remote -v</code></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">origingit@git.coding.net:morethink/programming.git (fetch)</span><br><span class="line">origingit@git.coding.net:morethink/programming.git (push)</span><br><span class="line">originhexo@MyHost2:/var/repo/gitbook.git (push)</span><br></pre></td></tr></table></figure><p>也可以同时 push 到多个远程地址：<code>git push origin master</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Everything up-to-date</span><br><span class="line">Everything up-to-date</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;添加第二个远程地址时使用以下命令：&lt;br&gt;&lt;code&gt;git remote set-url --add origin git@github.com:morethink/programming.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看远程分支：&lt;code&gt;git remote -v&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://www.morethink.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="https://www.morethink.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>二叉树从右边看到的节点</title>
    <link href="https://www.morethink.cn/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%8E%E5%8F%B3%E8%BE%B9%E7%9C%8B%E5%88%B0%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://www.morethink.cn/算法/二叉树从右边看到的节点/</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2018-06-29T09:32:08.288Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 LeetCode <a href="https://leetcode.com/problems/binary-tree-right-side-view/description/" target="_blank" rel="noopener">Binary Tree Right Side View</a> 解法的探讨。</p><p>题目：<br>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.<br><a id="more"></a><br>For example:<br>Given the following binary tree,<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure></p><p>You should return [1, 3, 4].</p><p>解法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为题目的二叉树并不是满二叉树，所以采用层序遍历的方式。</span></span><br><span class="line"><span class="comment"> * 将以前层序遍历中一个个出队的方式变为一层层出队，</span></span><br><span class="line"><span class="comment"> * 这样就能定位最右边的节点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="comment">//将每一层的节点都出队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode treeNode = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(treeNode.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(treeNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(treeNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 LeetCode &lt;a href=&quot;https://leetcode.com/problems/binary-tree-right-side-view/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Binary Tree Right Side View&lt;/a&gt; 解法的探讨。&lt;/p&gt;
&lt;p&gt;题目：&lt;br&gt;Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.morethink.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="https://www.morethink.cn/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>求小于n的素数个数</title>
    <link href="https://www.morethink.cn/%E6%B1%82%E5%B0%8F%E4%BA%8En%E7%9A%84%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0/"/>
    <id>https://www.morethink.cn/求小于n的素数个数/</id>
    <published>2018-03-10T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.192Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 LeetCode <a href="https://leetcode.com/problems/count-primes/description/" target="_blank" rel="noopener">Count Primes</a> 解法的探讨。</p><p>题目：<br>Count the number of prime numbers less than a non-negative number, n.</p><p>尽管题目并没有要我们写一个最优的算法，但是身为一个程序员，优化应该是一种习惯，在编程的过程中，随着思考进行优化。只要求我们满足给定的时间和空间即可。</p><p>如果你只能想出一个最简单的方法，难道你会有什么竞争力吗？</p><a id="more"></a><h1 id="穷举"><a href="#穷举" class="headerlink" title="穷举"></a>穷举</h1><p>最开始我用的就是这个方法，可以说这是最简单的一种方法了，而且最开始，我就是想的这种方法，说明：我没有对这个问题进行思考，没有去优化它，而作为一个程序员，如何提高效率是拿到一个问题首先要思考的事情。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i - <span class="number">1</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取开始时</span></span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"The num is "</span> + <span class="keyword">new</span> L_204_Count_Primes().countPrimes(<span class="number">2000000</span>));</span><br><span class="line">    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//获取结束时间</span></span><br><span class="line">    System.out.println(<span class="string">"程序运行时间： "</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间太长，已经不能计算。</p></blockquote><h1 id="只能是奇数且小于-sqrt-n"><a href="#只能是奇数且小于-sqrt-n" class="headerlink" title="只能是奇数且小于$\sqrt{n}$"></a>只能是奇数且小于$\sqrt{n}$</h1><p>思考后发现</p><ol><li>素数一定是奇数</li><li>若 n=ab 是个合数（其中 a 与 b ≠ 1）, 则其中一个约数 a 或 b 必定至大为  $\sqrt{n}$.</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= (<span class="keyword">int</span>) Math.sqrt(i); j++)</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The num is 148933<br>程序运行时间： 1124ms</p></blockquote><h1 id="试除法：数学知识的运用"><a href="#试除法：数学知识的运用" class="headerlink" title="试除法：数学知识的运用"></a>试除法：数学知识的运用</h1><p>查阅 <a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">算术基本定理</a>可知：</p><blockquote><p><strong>算术基本定理</strong> :<br>每个大于1的整数均可写成一个以上的素数之乘积，且除了质约数的排序不同外是唯一的</p></blockquote><p>也就是说我们可以每个数来除以得到的素数，这样可大大减少运行次数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0 1 不算做素数,2一定是素数</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.size() &amp;&amp; list.get(j) &lt;= (<span class="keyword">int</span>) Math.sqrt(n); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % list.get(j) == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The num is 148933<br>程序运行时间： 383ms</p></blockquote><h1 id="筛选法"><a href="#筛选法" class="headerlink" title="筛选法"></a>筛选法</h1><blockquote><p>埃拉托斯特尼筛法，简称埃氏筛，也有人称素数筛。这是一种简单且历史悠久的筛法，用来找出一定范围内所有的素数。</p><p>所使用的原理是从2开始，将每个素数的各个倍数，标记成合数。一个素数的各个倍数，是一个差为此素数本身的等差数列。此为这个筛法和试除法不同的关键之处，后者是以素数来测试每个待测数能否被整除。</p></blockquote><p>筛选法的策略是将素数的倍数全部筛掉，剩下的就是素数了，下图很生动的体现了筛选的过程：</p><p><img src="https://images.morethink.cn/dcp5x843_338cbm3tmg7_b.gif" alt="" title="筛选法"></p><p>筛选的过程是先筛掉非素数，针对本文的题目，每筛掉一个，素数数量-1即可，上面说过素数的一个特点，除了2，其它的素数都是奇数，所以我们只需在奇数范围内筛选就可以了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes4</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//false代表素数，true代表非素数</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="comment">//0不是素数</span></span><br><span class="line">    flags[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//1不是素数</span></span><br><span class="line">    flags[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> num = n - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= (<span class="keyword">int</span>) Math.sqrt(n); i++) &#123;</span><br><span class="line">        <span class="comment">//当i为素数时，i的所有倍数都不是素数</span></span><br><span class="line">        <span class="keyword">if</span> (!flags[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!flags[j]) &#123;</span><br><span class="line">                    flags[j] = <span class="keyword">true</span>;</span><br><span class="line">                    num--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The num is 148933<br>程序运行时间： 43ms</p></blockquote><p>全部代码放在：<br> <a href="https://github.com/morethink/algorithm/blob/master/src/algorithm/leetcode/L_204_Count_Primes.java" target="_blank" rel="noopener">https://github.com/morethink/algorithm/blob/master/src/algorithm/leetcode/L_204_Count_Primes.java</a></p><p><strong>参考文档</strong>：</p><ol><li><a href="https://program-think.blogspot.com/2011/12/prime-algorithm-1.html" target="_blank" rel="noopener">求质数算法的N种境界[1] - 试除法和初级筛法</a></li><li><a href="http://blog.csdn.net/ghsau/article/details/78768157" target="_blank" rel="noopener"> 求素数个数</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95" target="_blank" rel="noopener">埃拉托斯特尼筛法</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 LeetCode &lt;a href=&quot;https://leetcode.com/problems/count-primes/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Count Primes&lt;/a&gt; 解法的探讨。&lt;/p&gt;
&lt;p&gt;题目：&lt;br&gt;Count the number of prime numbers less than a non-negative number, n.&lt;/p&gt;
&lt;p&gt;尽管题目并没有要我们写一个最优的算法，但是身为一个程序员，优化应该是一种习惯，在编程的过程中，随着思考进行优化。只要求我们满足给定的时间和空间即可。&lt;/p&gt;
&lt;p&gt;如果你只能想出一个最简单的方法，难道你会有什么竞争力吗？&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.morethink.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="素数" scheme="https://www.morethink.cn/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
</feed>
