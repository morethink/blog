<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>More Think</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.morethink.cn/"/>
  <updated>2018-07-03T12:21:07.540Z</updated>
  <id>https://www.morethink.cn/</id>
  
  <author>
    <name>李文浩</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库索引背后的数据结构(B-/+Tree)</title>
    <link href="https://www.morethink.cn/data-structure-behind-the-index/"/>
    <id>https://www.morethink.cn/data-structure-behind-the-index/</id>
    <published>2018-06-30T16:00:00.000Z</published>
    <updated>2018-07-03T12:21:07.540Z</updated>
    
    <content type="html"><![CDATA[<p>索引是数据库常见的数据结构，每个后台开发人员都应该对索引背后的数据结构有所了解。</p><p>本文通过分析B-Tree及B-/+Tree数据结构及索引性能分析及磁盘存取原理尝试着回答一下问题：</p><ol><li>为什么B-Tree适合数据库索引及红黑树的二叉平衡树不适合作为索引</li><li>B+Tree比BTree做索引的优势</li><li>为什么MongoDB采用B-Tree作为索引结构而MySQL采用B+Tree作为索引存储结构</li></ol><a id="more"></a><h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h1><p>B 树（B-Tree）是为磁盘等辅助存取设备设计的一种平衡查找树，它实现了以 $O(\lg n)$ 时间复杂度执行查找、顺序读取、插入和删除操作。由于 B 树和 B 树的变种在降低磁盘 I/O 操作次数方面表现优异，所以经常用于设计文件系统和数据库。</p><p>使用阶来定义 B 树，一棵 m 阶的 B 树，需要满足下列条件：</p><ol><li>每个节点最多拥有m个子节点且m&gt;=2，空树除外</li><li><strong>除根节点外每个节点的关键字数量大于等于<code>ceil(m/2)-1</code>，小于等于<code>m-1</code>，非根节点关键字数必须&gt;=2</strong></li><li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子</li><li><strong>如果一个非叶节点有n个子节点，则该节点的关键字数等于n-1</strong></li><li>所有节点关键字是按递增次序排列，并遵循左小右大原则</li></ol><p>注：</p><ol><li>m阶代表一个树节点最多有多少个查找路径，m阶=m路,当m=2则是2叉树，m=3则是3叉。</li><li>ceil()是个朝正无穷方向取整的函数，如ceil(1.1)结果为2，即向上取整。</li></ol><p><img src="https://images.morethink.cn/B-Tree-1.jpg" alt="B-Tree" title="B-Tree"></p><p>B 树中的节点分为内部节点（Internal Node）和叶节点（Leaf Node），内部节点也就是非叶节点（Non-Leaf Node）。</p><h2 id="B-Tree的查找"><a href="#B-Tree的查找" class="headerlink" title="B-Tree的查找"></a>B-Tree的查找</h2><p>B-Tree的查找过程：根据给定值查找结点和在结点的关键字中进行查找交叉进行。</p><p>首先从根结点开始重复如下过程：若比结点的第一个关键字小，则查找在该结点第一个指针指向的结点进行；若等于结点中某个关键字，则查找成功；若在两个关键字之间，则查找在它们之间的指针指向的结点进行；若比该结点所有关键字大，则查找在该结点最后一个指针指向的结点进行；若查找已经到达某个叶结点，则说明给定值对应的数据记录不存在，查找失败。</p><p>例如：<br>在一棵 5 阶B-树中查找元素 29</p><p><img src="https://upload-images.jianshu.io/upload_images/1630488-43897a4dd77bf18f.gif" alt="" title="B-Tree的查询"></p><p>首先29比根节点值大，所以找根节点的右子数，然后再根据值得判断，发现 29 介于 28 和 48 之间，然后在从中间子树继续查找下去。</p><h2 id="B-Tree的插入"><a href="#B-Tree的插入" class="headerlink" title="B-Tree的插入"></a>B-Tree的插入</h2><p>插入的过程分两步完成：</p><ol><li><p>利用前述的B-树的查找算法查找关键字的插入位置。若找到，则说明该关键字已经存在，直接返回。否则查找操作必失败于某个最低层的非终端结点上。</p></li><li><p>判断该结点是否还有空位置。<strong>即判断该结点的关键字总数是否满足n&lt;=m-1</strong>。若满足，则说明该结点还有空位置，直接把关键字k插入到该结点的合适位置上。若不满足，说明该结点己没有空位置，需要把结点分裂成两个。</p></li></ol><p>分裂的方法是：<br>生成一新结点。把原结点上的关键字和k按升序排序后，<strong>从中间位置把关键字（不包括中间位置的关键字）分成两部分</strong>。左部分所含关键字放在旧结点中，右部分所含关键字放在新结点中，中间位置的关键字连同新结点的存储位置插入到父结点中。如果父结点的关键字个数也超过（m-1），则要再分裂，再往上插。直至这个过程传到根结点为止。</p><p>例子：</p><p><strong>如果该节点的元素个数还没达到 m，则插入完后无需处理</strong><br>比如：</p><p><img src="https://upload-images.jianshu.io/upload_images/1630488-25083e10d9708891.gif" alt="" title="在 B-树中插入元素 3"></p><p><strong>如果该节点元素个数达到 m 时，这时候将元素插入到合适的位置，将最中间的元素取出，成为该节点的父节点元素，然后将其余左右元素拆成两个新节点</strong></p><p>比如：</p><p><img src="https://upload-images.jianshu.io/upload_images/1630488-afa3b6b35908cf99.gif" alt="" title="在 B-树中插入元素 44"></p><p><strong>刚才的操作可能导致父节点的元素个数达到 m，这时候用情况 2 迭代处理，直到如果遇到根结点元素个数达到 m，则最中间元素将成为新的根结点。</strong></p><p>比如：</p><p><img src="https://upload-images.jianshu.io/upload_images/1630488-8dda91b45852ba9d.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="" title="在 B-树中插入元素 45"></p><h2 id="B-Tree-的删除"><a href="#B-Tree-的删除" class="headerlink" title="B-Tree 的删除"></a>B-Tree 的删除</h2><p>我们需要分两种情况进行讨论：</p><ul><li>如果该元素存在于叶子结点，直接删除它，无需进行其它处理。</li><li>如果该元素存在于非叶子节点，那么删除它将会留下一个空位，这时候我们需要一些处理来填充该位置。<br>因为节点的元素个数在 [M/2, M] 的范围内，所以比如这里我们以 5 阶B-树为例，判断节点元素是否充足即满足个数则至少拥有三（2 + 1）个元素的节点才算是有充足的元素。<ol><li>如果被删元素的左子树拥有足够的元素，这时候我们只需拿左子节点的最大值元素上来填充即可</li><li>当左子树不够元素而右子树元素充足时，这时候我们拿右子树的最小值元素上来进行填充</li><li>当左右子树所含元素均不足时，但左子树的左边兄弟节点的元素个数充足，这时我们需要拿左边的兄弟节点来进行调整。</li><li>当左右子树所含元素均不足时，但左子树的左边兄弟节点的元素个数也不足时，这时候我们还是拿左子树的最大值元素进行填充，之后再将该节点与其他节点合并形成新的节点。</li></ol></li></ul><h1 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h1><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p><p>与B-Tree相比，B+Tree有以下不同点：</p><ul><li>每个节点的指针上限为2d而不是2d+1。</li><li>B+Tree叶子节点保存了父节点的所有关键字和关键字记录的指针，每个叶子节点的关键字从小到大链接</li><li>内节点不存储data，只存储key；叶子节点不存储指针。因此所有数据地址必须要到叶子节点才能获取到，所以每次数据查询的次数都一样。<br><img src="https://images.morethink.cn/B+Tree.jpg" alt="" title="B+Tree"></li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，<strong>索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数</strong>。</p><p>下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p><h1 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h1><p>索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p><p>下面是磁盘的整体结构示意图：</p><p><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/6.png" alt="" title="磁盘的整体结构"></p><p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p><p>下面是磁盘结构的示意图：</p><p><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/7.png" alt="" title="磁盘结构"></p><p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p><p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p><h2 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h2><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。</p><p>这样做的理论依据是计算机科学中著名的局部性原理：</p><blockquote><p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p></blockquote><p>程序运行期间所需要的数据通常比较集中。</p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h1 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h1><p>一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为$O(h)=O(\log_d N)$。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>综上所述，用B-Tree作为索引结构效率是非常高的。</p><p><strong>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</strong></p><p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p><p>$$<br>d_{max}=floor({pagesize \over keysize+datasize+pointsize})<br>$$</p><p>floor表示向下取整。</p><p><strong>由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，容纳更多的节点，能够有效减少磁盘IO次数</strong>。</p><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p><p><img src="https://images.morethink.cn/B+Tree.jpg" alt="" title="B+Tree"></p><p>如上图图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，<strong>只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率</strong>。</p><p>综上所述：<br>B+Tree做索引的优势是：</p><ol><li>内部节点取消data域，每一页可以容纳更多的数据，有效减少磁盘IO次数。</li><li>数据都存储在叶子节点，所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。所以B+树查询时间复杂度为log n，而B树查询时间复杂度不固定，与所查结点在树中的位置有关，最好为O(1)。</li><li>通过增加顺序访问指针提高区间查询效率。</li></ol><p>而MongoDB索引选择B树可能是因为：<br>MongoDB 是文档型的数据库，是一种nosql，它使用BSON格式保存数据，归属于聚合型数据库。被设计用在数据模型简单，性能要求高的场合。之所以采用B树，是因为B树key和data域聚合在一起。因此并不需要类似于区间查询的操作。</p><p><strong>参考文档</strong>：</p><ol><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></li><li><a href="https://www.cnblogs.com/gaochundong/p/btree_and_bplustree.html#bplustree_implementation" target="_blank" rel="noopener">人人都是 DBA（VII）B 树和 B+ 树</a></li><li><a href="https://zhuanlan.zhihu.com/p/27700617" target="_blank" rel="noopener">平衡二叉树、B-Tree、B+Tree、B*树 理解其中一种你就都明白了</a></li><li><a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/B%E6%A0%91</a></li><li>B-Tree gif：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></li><li><a href="https://www.jianshu.com/p/ed76dbc0536d" target="_blank" rel="noopener">6. 数据结构 - B 树</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;索引是数据库常见的数据结构，每个后台开发人员都应该对索引背后的数据结构有所了解。&lt;/p&gt;
&lt;p&gt;本文通过分析B-Tree及B-/+Tree数据结构及索引性能分析及磁盘存取原理尝试着回答一下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么B-Tree适合数据库索引及红黑树的二叉平衡树不适合作为索引&lt;/li&gt;
&lt;li&gt;B+Tree比BTree做索引的优势&lt;/li&gt;
&lt;li&gt;为什么MongoDB采用B-Tree作为索引结构而MySQL采用B+Tree作为索引存储结构&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.morethink.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="https://www.morethink.cn/tags/%E6%A0%91/"/>
    
      <category term="索引" scheme="https://www.morethink.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MAC安装RabbitMQ</title>
    <link href="https://www.morethink.cn/MAC%E5%AE%89%E8%A3%85RabbitMQ/"/>
    <id>https://www.morethink.cn/MAC安装RabbitMQ/</id>
    <published>2018-05-11T16:00:00.000Z</published>
    <updated>2018-05-23T16:31:34.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install rabbitmq</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ol><li>添加环境变量<ul><li>打开配置文件<code>$ vi ~/.bash_profile</code></li><li>添加 <code>export PATH=$PATH:/usr/local/sbin</code><br>到末尾，编辑完后:wq保存退出。</li><li>使环境变量立即生效 <code>$ source ~/.bash_profile</code></li></ul></li><li>启动RabbitMQ服务<br>上面配置完成后，需要关闭终端窗口，重新打开，然后输入下面命令即可启动RabbitMQ服务：<code>rabbitmq-server</code></li><li>登录Web管理界面<br>浏览器输入localhost：15672，账号密码全输入guest即可登录。</li></ol><p>这里需要注意下，从3.3.1版本开始，RabbitMQ默认不允许远程ip登录，即只能使用localhost登录。如果希望远程登录，需要添加用户权限。</p><h1 id="设置RabbitMQ远程ip登录"><a href="#设置RabbitMQ远程ip登录" class="headerlink" title="设置RabbitMQ远程ip登录"></a>设置RabbitMQ远程ip登录</h1><p>由于账号guest具有所有的操作权限，并且又是默认账号，出于安全因素的考虑，guest用户只能通过localhost登陆使用，并建议修改guest用户的密码以及新建其他账号管理使用rabbitmq。<br>这里我们以创建个test帐号，密码123456为例，创建一个账号并支持远程ip访问。</p><ul><li><p>创建账号</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl add_user test 123456</span><br></pre></td></tr></table></figure></li><li><p>设置用户角色</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl  set_user_tags  test  administrator</span><br></pre></td></tr></table></figure></li><li><p>设置用户权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; test &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure></li><li><p>设置完成后可以查看当前用户和角色(需要开启服务)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure></li></ul><p>这是你就可以通过其他主机的访问RabbitMQ的Web管理界面了，访问方式，浏览器输入：serverip:15672。其中serverip是RabbitMQ-Server所在主机的ip。</p><h1 id="RabbitMQ常用操作"><a href="#RabbitMQ常用操作" class="headerlink" title="RabbitMQ常用操作"></a>RabbitMQ常用操作</h1><ol><li><p>用户管理<br>用户管理包括增加用户，删除用户，查看用户列表，修改用户密码。</p><ul><li><p>新增一个用户</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl  add_user  Username  Password</span><br></pre></td></tr></table></figure></li><li><p>删除一个用户</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl  delete_user  Username</span><br></pre></td></tr></table></figure></li><li><p>修改用户的密码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl  change_password  Username  Newpassword</span><br></pre></td></tr></table></figure></li><li><p>查看当前用户列表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl  list_users</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;brew update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;brew install rabbitmq&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="工具" scheme="https://www.morethink.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="MQ" scheme="https://www.morethink.cn/tags/MQ/"/>
    
      <category term="MAC" scheme="https://www.morethink.cn/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>科学上网之在VPS上安装SSR</title>
    <link href="https://www.morethink.cn/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E4%B9%8B%E5%9C%A8VPS%E4%B8%8A%E5%AE%89%E8%A3%85SSR/"/>
    <id>https://www.morethink.cn/科学上网之在VPS上安装SSR/</id>
    <published>2018-05-11T16:00:00.000Z</published>
    <updated>2018-05-23T16:31:30.777Z</updated>
    
    <content type="html"><![CDATA[<p>本文对VPS安装SSR的过程进行总结，免得因为XX重新安装SSR时找不到安装方法。</p><h1 id="安装SSR"><a href="#安装SSR" class="headerlink" title="安装SSR"></a>安装SSR</h1><p>简单的来说，如果你什么都不懂，那么你直接一路回车就可以了！<br><a id="more"></a><br>本脚本需要Linux root账户权限才能正常安装运行，所以 <strong>如果不是 root账号，请先切换为root，如果是 root账号，那么请跳过</strong>！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure><p>输入上面代码回车后会提示你输入当前用户的密码，输入并回车后，没有报错就继续下面的步骤安装ShadowsocksR。</p><p>v2.0.0 版本以后的脚本，请先卸载旧脚本ShadowsocksR服务端，再重新安装！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure><p>备用下载地址（上面的链接无法下载，就用这个）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure></p><p>下载运行后会提示你输入数字来选择要做什么。</p><p>运行脚本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash ssr.sh</span><br></pre></td></tr></table></figure><p>输入对应的数字来执行相应的命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  请输入一个数字来选择菜单选项</span><br><span class="line"></span><br><span class="line"> 1. 安装 ShadowsocksR</span><br><span class="line"> 2. 更新 ShadowsocksR</span><br><span class="line"> 3. 卸载 ShadowsocksR</span><br><span class="line"> 4. 安装 libsodium(chacha20)</span><br><span class="line">————————————</span><br><span class="line"> 5. 查看 账号信息</span><br><span class="line"> 6. 显示 连接信息</span><br><span class="line"> 7. 设置 用户配置</span><br><span class="line"> 8. 手动 修改配置</span><br><span class="line"> 9. 切换 端口模式</span><br><span class="line">————————————</span><br><span class="line"> 10. 启动 ShadowsocksR</span><br><span class="line"> 11. 停止 ShadowsocksR</span><br><span class="line"> 12. 重启 ShadowsocksR</span><br><span class="line"> 13. 查看 ShadowsocksR 日志</span><br><span class="line">————————————</span><br><span class="line"> 14. 其他功能</span><br><span class="line"> 15. 升级脚本</span><br><span class="line"></span><br><span class="line"> 当前状态: 已安装 并 已启动</span><br><span class="line"> 当前模式: 单端口</span><br><span class="line"></span><br><span class="line">请输入数字(1-15)：</span><br></pre></td></tr></table></figure></p><h1 id="文件位置"><a href="#文件位置" class="headerlink" title="文件位置"></a>文件位置</h1><ul><li>安装目录：<code>/usr/local/shadowsocksr</code></li><li>配置文件：<code>/etc/shadowsocksr/user-config.json</code></li></ul><h1 id="设置为系统服务"><a href="#设置为系统服务" class="headerlink" title="设置为系统服务"></a>设置为系统服务</h1><p>ShadowsocksR 安装后，自动设置为 系统服务，所以支持使用服务来启动/停止等操作，同时支持开机启动。</p><ul><li>启动 ShadowsocksR：<code>/etc/init.d/ssr start</code></li><li>停止 ShadowsocksR：<code>/etc/init.d/ssr stop</code></li><li>重启 ShadowsocksR：<code>/etc/init.d/ssr restart</code></li><li>查看 ShadowsocksR状态：<code>/etc/init.d/ssr status</code></li></ul><p>ShadowsocksR 默认支持UDP转发，服务端无需任何设置。</p><h1 id="定时重启"><a href="#定时重启" class="headerlink" title="定时重启"></a>定时重启</h1><p>一些人可能需要定时重启ShadowsocksR服务端来保证稳定性等，所以这里用 crontab 定时。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 输入这个命令可以查看当前配置的定时任务</span><br><span class="line">crontab -l</span><br><span class="line"># 如果提示命令不存在，下面是安装命令</span><br><span class="line"># CentOS系统：</span><br><span class="line">yum update</span><br><span class="line">yum install -y crond</span><br><span class="line"># Debian/Ubuntu系统：</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y cron</span><br></pre></td></tr></table></figure><p>安装 crontab 后，我们就能开始添加定时任务了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -l &gt; &quot;crontab.bak&quot;</span><br><span class="line">sed -i &quot;/ssr restart/d&quot; &quot;crontab.bak&quot;</span><br><span class="line">echo -e &quot;\n10 3 * * * /etc/init.d/ssr restart&quot; &gt;&gt; &quot;crontab.bak&quot;</span><br><span class="line">crontab &quot;crontab.bak&quot;</span><br><span class="line">rm -r &quot;crontab.bak&quot;</span><br></pre></td></tr></table></figure><p>下面是定时任务规则(代码前面的 <em> </em> <em> </em> * 分别对应：分钟 小时 日 月 星期)参考：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 2 * * * /etc/init.d/ssr restart</span><br><span class="line"># 这个代表 每天2点10分重启一次 ShadowsocksR</span><br><span class="line"></span><br><span class="line">10 2 */2 * * /etc/init.d/ssr restart</span><br><span class="line"># 这个代表 每隔2天的2点10分重启一次 ShadowsocksR</span><br><span class="line"></span><br><span class="line">10 */4 * * * /etc/init.d/ssr restart</span><br><span class="line"># 这个代表 每隔4小时的第10分重启一次 ShadowsocksR</span><br></pre></td></tr></table></figure><h1 id="BBR和锐速"><a href="#BBR和锐速" class="headerlink" title="BBR和锐速"></a>BBR和锐速</h1><p>BBR和锐速都是用来提高翻墙速度的。</p><p>BBR是来自于Google的黑科技，目的是通过优化和控制TCP的拥塞，充分利用带宽并降低延迟，其目的就是要尽量跑满带宽，并且尽量不要有排队的情况。<br>BBR 这个特性其实是在 Linux 内核 4.9 才计划加入的。所以，要开启BBR，需要内核版本在Linux kernel 4.9以上，脚本会帮助我们安装。</p><p>在BBR之前，比较有名的就是国产的锐速了，不过，由于锐速是个国产的闭源软件，可能存在安全性问题，因此 <strong>推荐使用安装BBR</strong>。</p><ul><li><p>启动脚本：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash ssr.sh</span><br></pre></td></tr></table></figure></li><li><p>选择<code>14. 其他功能</code></p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1. 配置 BBR</span><br><span class="line">  2. 配置 锐速(ServerSpeeder)</span><br><span class="line">  3. 配置 LotServer(锐速母公司)</span><br><span class="line">  注意： 锐速/LotServer/BBR 不支持 OpenVZ！</span><br><span class="line">  注意： 锐速/LotServer/BBR 不能共存！</span><br><span class="line">————————————</span><br><span class="line">  4. 一键封禁 BT/PT/SPAM (iptables)</span><br><span class="line">  5. 一键解封 BT/PT/SPAM (iptables)</span><br><span class="line">  6. 切换 ShadowsocksR日志输出模式</span><br><span class="line">  ——说明：SSR默认只输出错误日志，此项可切换为输出详细的访问日志</span><br></pre></td></tr></table></figure></li><li><p>安装BBR或者锐速(推荐BBR)</p></li></ul><h1 id="TCP优化"><a href="#TCP优化" class="headerlink" title="TCP优化"></a>TCP优化</h1><ul><li><p>增加TCP连接数量</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/security/limits.conf</span><br></pre></td></tr></table></figure></li><li><p>添加两行：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* soft nofile 51200</span><br><span class="line">* hard nofile 51200</span><br></pre></td></tr></table></figure></li><li><p>设置ulimit：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit -n 51200</span><br></pre></td></tr></table></figure></li><li><p>添加一些优化内容</p><ul><li><p>修改sysctl.conf</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  /etc/sysctl.conf</span><br></pre></td></tr></table></figure></li><li><p>插入代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#TCP配置优化(不然你自己根本不知道你在干什么)</span><br><span class="line">fs.file-max = 51200</span><br><span class="line">#提高整个系统的文件限制</span><br><span class="line">net.core.rmem_max = 67108864</span><br><span class="line">net.core.wmem_max = 67108864</span><br><span class="line">net.core.netdev_max_backlog = 250000</span><br><span class="line">net.core.somaxconn = 4096</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 8192</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line">net.ipv4.tcp_fastopen = 3</span><br><span class="line">net.ipv4.tcp_mem = 25600 51200 102400</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class="line">net.ipv4.tcp_mtu_probing = 1</span><br><span class="line">net.ipv4.tcp_congestion_control = bbr</span><br><span class="line">#END OF LINE</span><br></pre></td></tr></table></figure></li><li><p>应用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li><li><p>重启SSR</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ssr restart</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>参考文档</strong>：</p><ol><li><a href="https://jasper-1024.github.io/2016/06/26/VPS%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97/" target="_blank" rel="noopener">科学上网教程（一）——VPS上搭建SSR</a></li><li><a href="https://doub.io/ss-jc42" target="_blank" rel="noopener">『原创』CentOS/Debian/Ubuntu ShadowsocksR 单/多端口 一键管理脚本</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对VPS安装SSR的过程进行总结，免得因为XX重新安装SSR时找不到安装方法。&lt;/p&gt;
&lt;h1 id=&quot;安装SSR&quot;&gt;&lt;a href=&quot;#安装SSR&quot; class=&quot;headerlink&quot; title=&quot;安装SSR&quot;&gt;&lt;/a&gt;安装SSR&lt;/h1&gt;&lt;p&gt;简单的来说，如果你什么都不懂，那么你直接一路回车就可以了！&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="https://www.morethink.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>给你的博客园图片添加标题</title>
    <link href="https://www.morethink.cn/%E7%BB%99%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E6%A0%87%E9%A2%98/"/>
    <id>https://www.morethink.cn/给你的博客园图片添加标题/</id>
    <published>2018-05-05T16:00:00.000Z</published>
    <updated>2018-05-23T16:31:25.381Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来都觉得在图片下面添加一个标题可以更加清晰的表示这张图片的含义，可是博客园原生并不支持这种渲染方式，再加上博客园可以自己写js来更改主题，于是通过搜索资料完成给博客园图片添加标题的功能。</p><a id="more"></a><p>当我们如下书写markdown时：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://images.morethink.cn/092017231747399.jpg "TCP的三次握手和四次挥手")</span><br></pre></td></tr></table></figure></p><p>会被博客园渲染成<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://images.morethink.cn/092017231747399.jpg"</span> <span class="attr">title</span>=<span class="string">"TCP的三次握手和四次挥手"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>于是我就想通过在img标签后面动态添加一个带有<code>title</code>的p标签来给博客园图片添加标题。</p><p>将下面代码放入<code>页首Html代码</code>代码中即可(需要申请js权限)。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入jQuery --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="built_in">window</span>).load(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//给每张图片添加标题,div.cnblogs_post_body是博客主体</span></span></span><br><span class="line"><span class="javascript">        $(<span class="string">"div[id=cnblogs_post_body] img"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> title = $(<span class="keyword">this</span>).attr(<span class="string">"title"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (title != <span class="literal">undefined</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> boardp_style = <span class="string">"style='display: block; text-align: center; color: #969696;padding: 10px;border-bottom: 1px solid #d9d9d9;margin: 0 auto;"</span> +</span></span><br><span class="line"><span class="javascript">                    <span class="string">"width: "</span> + ($(<span class="keyword">this</span>).width() * <span class="number">0.8</span>) + <span class="string">"px;"</span> +</span></span><br><span class="line"><span class="javascript">                    <span class="string">"height: 28px;"</span> +</span></span><br><span class="line"><span class="javascript">                    <span class="string">"'&gt;"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> boardp = <span class="string">"&lt;p "</span> + boardp_style + title + <span class="string">"&lt;/p"</span>;</span></span><br><span class="line"><span class="javascript">                $(<span class="keyword">this</span>).after(boardp);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将img变为块级元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    img &#123;</span></span><br><span class="line"><span class="undefined">        margin: 0 auto;</span></span><br><span class="line"><span class="undefined">        display: block;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>markdown图片：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://images.morethink.cn/092017231747399.jpg "TCP的三次握手和四次挥手")</span><br></pre></td></tr></table></figure></p><p><img src="https://images.morethink.cn/092017231747399.jpg" alt="" title="TCP的三次握手和四次挥手"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来都觉得在图片下面添加一个标题可以更加清晰的表示这张图片的含义，可是博客园原生并不支持这种渲染方式，再加上博客园可以自己写js来更改主题，于是通过搜索资料完成给博客园图片添加标题的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://www.morethink.cn/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Cron表达式</title>
    <link href="https://www.morethink.cn/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://www.morethink.cn/Cron表达式/</id>
    <published>2018-04-21T16:00:00.000Z</published>
    <updated>2018-05-23T16:31:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Cron表达式范例：</strong></p><ul><li><code>*/5 * * * * ?</code>  ：每隔5<code>秒</code>执行一次</li><li><code>0 */1 * * * ?</code>  ：每隔1分钟执行一次</li><li><code>0 0 23 * * ?</code>   ：每天23点执行一次</li><li><code>0 0 1 * * ?</code>    ：每天凌晨1点执行一次：</li><li><code>0 0 1 1 * ?</code>  ：每月1号凌晨1点执行一次</li><li><code>0 0 23 L * ?</code> ： 每月最后一天23点执行一次</li><li><code>0 0 1 ? * L</code>  ：每周星期天凌晨1点实行一次</li><li><code>0 26,29,33 * * * ?</code> ： 在26分、29分、33分执行一次</li><li><code>0 0 0,13,18,21 * * ?</code> ： 每天的0点、13点、18点、21点都执行一次<a id="more"></a><h1 id="Cron表达式"><a href="#Cron表达式" class="headerlink" title="Cron表达式"></a>Cron表达式</h1></li></ul><p>Cron表达式由7个部分组成，各部分用空格隔开，Cron表达式的7个部分从左到右代表的含义如下：</p><p><code>秒</code> <code>分</code> <code>时</code> <code>日</code> <code>月</code> <code>周</code> <code>年</code><br>其中 <code>年</code>是可选的。</p><table><thead><tr><th>字段名</th><th>允许的值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td><code>秒</code></td><td>0-59</td><td>,- * /</td><td></td></tr><tr><td><code>分</code></td><td>0-59</td><td>,- * /</td><td></td></tr><tr><td><code>时</code></td><td>0-23</td><td>,- * /</td><td></td></tr><tr><td><code>日</code></td><td>1-31</td><td>,- * ? / L W C</td><td></td></tr><tr><td><code>月</code></td><td>1-12 or JAN-DEC</td><td>,- * /</td><td></td></tr><tr><td><code>周</code></td><td>1-7 or SUN-SAT</td><td>,- * ? / L C #</td><td></td></tr><tr><td><code>年</code> (可选字段)</td><td>empty，1970-2099</td><td>,- * /</td></tr></tbody></table><h1 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h1><ul><li><code>,</code>：表示列出枚举值值。例如在<code>分</code>使用5,20，则意味着在5和20分每分钟触发一次。</li><li><code>-</code>：表示范围。例如在<code>分</code>使用5-20，表示从5分到20分钟每分钟触发一次。</li><li><code>*</code> ：表示匹配该域的任意值。假如在<code>分</code>域使用<code>*</code>，即表示每分钟都会触发事件。</li><li><code>/</code> ：表示起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次。</li><li><code>?</code> ：只能用在<code>周</code>和<code>日</code>。它也匹配域的任意值，但实际不会。因为<code>周</code>和<code>日</code>会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 <em> ?,其中最后一位只能用？，而不能使用</em>，如果使用*表示不管星期几都会触发，实际上并不是这样。    </li><li><code>L</code> ： 表示最后，只能出现在<code>日</code>和<code>周</code>，如果在<code>日</code>使用5L,意味着在最后的一个星期四触发。  </li><li><code>W</code>：表示有效工作日(周一到周五),只能出现在<code>周</code>域，系统将在离指定日期的最近的有效工作日触发事件。例如：在<code>日</code>使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份。</li><li><code>#</code>：用于确定每个月第几个星期几，只能出现在<code>周</code>。例如在4#2，表示某月的第二个星期三。</li></ul><p><strong>参考文档</strong>：</p><ol><li><a href="http://Cron.qqe2.com/" target="_blank" rel="noopener">在线Cron表达式生成器</a></li><li><a href="https://www.jianshu.com/p/f03b1497122a" target="_blank" rel="noopener">QuartZ Cron表达式详解</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Cron表达式范例：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*/5 * * * * ?&lt;/code&gt;  ：每隔5&lt;code&gt;秒&lt;/code&gt;执行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 */1 * * * ?&lt;/code&gt;  ：每隔1分钟执行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 0 23 * * ?&lt;/code&gt;   ：每天23点执行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 0 1 * * ?&lt;/code&gt;    ：每天凌晨1点执行一次：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 0 1 1 * ?&lt;/code&gt;  ：每月1号凌晨1点执行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 0 23 L * ?&lt;/code&gt; ： 每月最后一天23点执行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 0 1 ? * L&lt;/code&gt;  ：每周星期天凌晨1点实行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 26,29,33 * * * ?&lt;/code&gt; ： 在26分、29分、33分执行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 0 0,13,18,21 * * ?&lt;/code&gt; ： 每天的0点、13点、18点、21点都执行一次
    
    </summary>
    
      <category term="Linux" scheme="https://www.morethink.cn/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>GitHub更新已经fork的项目</title>
    <link href="https://www.morethink.cn/GitHub%E6%9B%B4%E6%96%B0%E5%B7%B2%E7%BB%8Ffork%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    <id>https://www.morethink.cn/GitHub更新已经fork的项目/</id>
    <published>2018-04-21T16:00:00.000Z</published>
    <updated>2018-05-23T16:31:20.473Z</updated>
    
    <content type="html"><![CDATA[<p>当我们fork一个项目后，在我们使用代码的时候就会以我们本地为准，不会跟随我们fork前的项目，如果需要同步对方的代码，需要进行同步操作。</p><a id="more"></a><ol><li>clone 自己的 fork 分支到本地<br>可以直接使用 GitHub 客户端，clone 到本地，如果使用命令行，命令为：<br><code>$ git clone  git@github.com:morethink/git-recipes.git</code></li><li><p>进入仓库，增加源分支地址到你项目远程分支列表中<br>此处是关键，先得将原来的仓库指定为 upstream，命令为：<br><code>$ git remote add upstream git@github.com:geeeeeeeeek/git-recipes.git</code><br>此处可使用 <code>git remote -v</code> 查看远程分支列表</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origingit@github.com:morethink/git-recipes.git (fetch)</span><br><span class="line">origingit@github.com:morethink/git-recipes.git (push)</span><br><span class="line">upstreamgit@github.com:geeeeeeeeek/git-recipes.git (fetch)</span><br><span class="line">upstreamgit@github.com:geeeeeeeeek/git-recipes.git (push)</span><br></pre></td></tr></table></figure></li><li><p>fetch 源分支的新版本到本地<br><code>$ git fetch upstream</code></p></li><li>切换到本地master分支<br><code>$ git checkout master</code></li><li>合并两个版本的代码<br><code>$ git merge upstream/master</code></li><li>将合并后的代码 push 到 GitHub 上去<br><code>$ git push origin master</code></li></ol><p><strong>参考文档：</strong></p><ol><li>添加远程分支<br><a href="https://help.github.com/articles/configuring-a-remote-for-a-fork/" target="_blank" rel="noopener">https://help.github.com/articles/configuring-a-remote-for-a-fork/</a></li><li>完成同步<br><a href="https://help.github.com/articles/syncing-a-fork/" target="_blank" rel="noopener">https://help.github.com/articles/syncing-a-fork/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们fork一个项目后，在我们使用代码的时候就会以我们本地为准，不会跟随我们fork前的项目，如果需要同步对方的代码，需要进行同步操作。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://www.morethink.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="https://www.morethink.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>常见web攻击总结</title>
    <link href="https://www.morethink.cn/%E5%B8%B8%E8%A7%81web%E6%94%BB%E5%87%BB%E6%80%BB%E7%BB%93/"/>
    <id>https://www.morethink.cn/常见web攻击总结/</id>
    <published>2018-04-06T16:00:00.000Z</published>
    <updated>2018-04-07T10:17:36.145Z</updated>
    
    <content type="html"><![CDATA[<p>搞Web开发离不开安全这个话题，确保网站或者网页应用的安全性，是每个开发人员都应该了解的事。本篇主要简单介绍在Web领域几种常见的攻击手段及Java Web中的预防方式。</p><ul><li><a href="#XSS">XSS</a></li><li><a href="#SQL注入">SQL注入</a></li><li><a href="#DDOS">DDOS</a></li><li><a href="#CSRF">CSRF</a></li></ul><a id="more"></a><p>项目地址： <a href="https://github.com/morethink/web-security" target="_blank" rel="noopener">https://github.com/morethink/web-security</a></p><h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><h2 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h2><p>XSS攻击：跨站脚本攻击(Cross-Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。XSS是一种常见的web安全漏洞，它允许攻击者将恶意代码植入到提供给其它用户使用的页面中。不同于大多数攻击(一般只涉及攻击者和受害者)，XSS涉及到三方，即攻击者、客户端与Web应用。XSS的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。</p><p>XSS通常可以分为两大类：</p><ol><li>存储型XSS，主要出现在让用户输入数据，供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等。应用程序从数据库中查询数据，在页面中显示出来，攻击者在相关页面输入恶意的脚本数据后，用户浏览此类页面时就可能受到攻击。这个流程简单可以描述为：<code>恶意用户的Html输入Web程序-&gt;进入数据库-&gt;Web程序-&gt;用户浏览器</code>。</li><li>反射型XSS，主要做法是将脚本代码加入URL地址的请求参数里，请求参数进入程序后在页面直接输出，用户点击类似的恶意链接就可能受到攻击。</li></ol><p>比如说我写了一个网站，然后攻击者在上面发布了一个文章，内容是这样的 <code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>,如果我没有对他的内容进行处理，直接存储到数据库，那么下一次当其他用户访问他的这篇文章的时候，服务器从数据库读取后然后响应给客户端，浏览器执行了这段脚本，就会将cookie展现出来，这就是典型的存储型XSS。</p><p>如图：<br><img src="https://images.morethink.cn/a1c6ebf6de227e086d0289f34d8c5f76.png" alt=""></p><h2 id="如何预防XSS"><a href="#如何预防XSS" class="headerlink" title="如何预防XSS"></a>如何预防XSS</h2><p>答案很简单，坚决不要相信用户的任何输入，并过滤掉输入中的所有特殊字符。这样就能消灭绝大部分的XSS攻击。</p><p>目前防御XSS主要有如下几种方式：</p><ol><li>过滤特殊字符<br>避免XSS的方法之一主要是将用户所提供的内容进行过滤(如上面的<code>script</code>标签)。</li><li>使用HTTP头指定类型<br><code>w.Header().Set(&quot;Content-Type&quot;,&quot;text/javascript&quot;)</code><br>这样就可以让浏览器解析javascript代码，而不会是html输出。</li></ol><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="什么是SQL注入"><a href="#什么是SQL注入" class="headerlink" title="什么是SQL注入"></a>什么是SQL注入</h2><p>攻击者成功的向服务器提交恶意的SQL查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。</p><p>举例：<code>&#39; OR &#39;1&#39;=&#39;1</code></p><p>这是最常见的 SQL注入攻击，当我们输如用户名 admin ，然后密码输如<code>&#39; OR &#39;1&#39;=1=&#39;1</code>的时候，我们在查询用户名和密码是否正确的时候，本来要执行的是<code>SELECT * FROM user WHERE username=&#39;&#39; and password=&#39;&#39;</code>,经过参数拼接后，会执行 SQL语句 <code>SELECT * FROM user WHERE username=&#39;&#39; and password=&#39;&#39; OR &#39;1&#39;=&#39;1&#39;</code>，这个时候1=1是成立，自然就跳过验证了。<br>如下图所示：</p><p><img src="https://images.morethink.cn/69855b1538333659f26afc281feb4e30.png" alt=""></p><p>但是如果再严重一点，密码输如的是<code>&#39;;DROP TABLE user;--</code>，那么 SQL命令为<code>SELECT *  FROM user WHERE username=&#39;admin&#39; and password=&#39;&#39;;drop table user;--&#39;</code> 这个时候我们就直接把这个表给删除了。</p><h2 id="如何预防SQL注入"><a href="#如何预防SQL注入" class="headerlink" title="如何预防SQL注入"></a>如何预防SQL注入</h2><ul><li>在Java中，我们可以使用预编译语句(PreparedStatement)，这样的话即使我们使用 SQL语句伪造成参数，到了服务端的时候，这个伪造 SQL语句的参数也只是简单的字符，并不能起到攻击的作用。</li><li>对进入数据库的特殊字符（<code>&#39;&quot;\尖括号&amp;*</code>;等）进行转义处理，或编码转换。</li><li>在应用发布之前建议使用专业的SQL注入检测工具进行检测，以及时修补被发现的SQL注入漏洞。网上有很多这方面的开源工具，例如sqlmap、SQLninja等。</li><li>避免网站打印出SQL错误信息，比如类型错误、字段不匹配等，把代码里的SQL语句暴露出来，以防止攻击者利用这些错误信息进行SQL注入。</li></ul><p>在上图展示中，使用了Java JDBC中的<code>PreparedStatement</code>预编译预防SQL注入，可以看到将所有输入都作为了字符串，避免执行恶意SQL。</p><h1 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h1><h2 id="什么是DDOS"><a href="#什么是DDOS" class="headerlink" title="什么是DDOS"></a>什么是DDOS</h2><p>DDOS：分布式拒绝服务攻击（Distributed Denial of Service），简单说就是发送大量请求是使服务器瘫痪。DDos攻击是在DOS攻击基础上的，可以通俗理解，dos是单挑，而ddos是群殴，因为现代技术的发展，dos攻击的杀伤力降低，所以出现了DDOS，攻击者借助公共网络，将大数量的计算机设备联合起来，向一个或多个目标进行攻击。</p><p>在技术角度上，DDoS攻击可以针对网络通讯协议的各层，手段大致有：TCP类的SYN Flood、ACK Flood，UDP类的Fraggle、Trinoo，DNS Query Flood，ICMP Flood，Slowloris类等等。一般会根据攻击目标的情况，针对性的把技术手法混合，以达到最低的成本最难防御的目的，并且可以进行合理的节奏控制，以及隐藏保护攻击资源。</p><p>下面介绍一下TCP协议中的SYN攻击。</p><h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><p>在三次握手过程中，服务器发送 <code>SYN-ACK</code> 之后，收到客户端的 <code>ACK</code> 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 <code>SYN_RCVD</code> 状态。当收到 ACK 后，服务器才能转入 <code>ESTABLISHED</code> 状态.</p><p><code>SYN</code>攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送<code>SYN</code>包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的<code>SYN</code>包将长时间占用未连接队列，正常的<code>SYN</code>请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p><h2 id="如何预防DDOS"><a href="#如何预防DDOS" class="headerlink" title="如何预防DDOS"></a>如何预防DDOS</h2><p>阿里巴巴的安全团队在实战中发现，DDoS 防御产品的核心是检测技术和清洗技术。检测技术就是检测网站是否正在遭受 DDoS 攻击，而清洗技术就是清洗掉异常流量。而检测技术的核心在于对业务深刻的理解，才能快速精确判断出是否真的发生了 DDoS 攻击。清洗技术对检测来讲，不同的业务场景下要求的粒度不一样。</p><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h2 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h2><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p><p>你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p><h2 id="CSRF的原理"><a href="#CSRF的原理" class="headerlink" title="CSRF的原理"></a>CSRF的原理</h2><p>下图简单阐述了CSRF攻击的思<br><img src="https://images.morethink.cn/138ad4f05b47533bf46904dc165167cc.png" alt=""></p><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><ol><li>登录受信任网站A，并在本地生成Cookie。</li><li>在不登出A的情况下，访问危险网站B。</li></ol><p>看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：</p><ol><li>你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</li><li>你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</li><li>上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li></ol><p>下面讲一讲java解决CSRF攻击的方式。</p><h2 id="模拟CSRF攻击"><a href="#模拟CSRF攻击" class="headerlink" title="模拟CSRF攻击"></a>模拟CSRF攻击</h2><h3 id="登录A网站"><a href="#登录A网站" class="headerlink" title="登录A网站"></a>登录A网站</h3><p>用户名和密码都是admin。</p><p><code>http://localhost:8081/login.html</code>:<br><img src="https://images.morethink.cn/e298f8ef08869557b8fb60034f06bb80.png" alt=""></p><h3 id="你有权限删除1号帖子"><a href="#你有权限删除1号帖子" class="headerlink" title="你有权限删除1号帖子"></a>你有权限删除1号帖子</h3><p><code>http://localhost:8081/deletePost.html</code>:<br><img src="https://images.morethink.cn/897d358f2677d053bb9555ff69d112ac.png" alt=""></p><h3 id="登录有CSRF攻击A网站的B网站"><a href="#登录有CSRF攻击A网站的B网站" class="headerlink" title="登录有CSRF攻击A网站的B网站"></a>登录有CSRF攻击A网站的B网站</h3><p><code>http://localhost:8082/deletePost.html</code>:</p><p><img src="https://images.morethink.cn/csrf-attack.gif" alt=""></p><p>明显看到B网站是8082端口，A网站是8081端口，但是B网站的删除2号帖子功能依然实现。</p><h2 id="如何预防CSRF攻击"><a href="#如何预防CSRF攻击" class="headerlink" title="如何预防CSRF攻击"></a>如何预防CSRF攻击</h2><p>简单来说，CSRF 就是网站 A 对用户建立信任关系后，在网站 B 上利用这种信任关系，跨站点向网站 A 发起一些伪造的用户操作请求，以达到攻击的目的。</p><p>而之所以可以完成攻击是因为B向A发起攻击的时候会把A网站的cookie带给A网站，也就是说cookie已经不安全了。</p><h3 id="通过Synchronizer-Tokens"><a href="#通过Synchronizer-Tokens" class="headerlink" title="通过Synchronizer Tokens"></a>通过Synchronizer Tokens</h3><p>Synchronizer Tokens： 在表单里隐藏一个随机变化的 csrf_token csrf_token 提交到后台进行验证，如果验证通过则可以继续执行操作。这种情况有效的主要原因是网站 B 拿不到网站 A 表单里的 csrf_token</p><p>这种方式的使用条件是PHP和JSP等。因为cookie已经不安全了，因此把csrf_token值存储在session中，然后每次表单提交时都从session取出来放到form表单的隐藏域中，这样B网站不可以得到这个存储到session中的值。</p><p>下面是JSP的：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;input type="hidden" name="random_form" value=&lt;%=random%&gt;&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure></p><p>但是我现在的情况是html，不是JSP，并不能动态的从session中取出csrf_token值。只能采用加密的方式了。</p><h3 id="Hash加密cookie中csrf-token值"><a href="#Hash加密cookie中csrf-token值" class="headerlink" title="Hash加密cookie中csrf_token值"></a>Hash加密cookie中csrf_token值</h3><p>这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了。</p><p>我采用的hash加密方法是JS实现Java的HashCode方法，得到hash值，这个比较简单。也可以采用其他的hash算法。</p><p>前端向后台传递hash之后的csrf_token值和cookie中的csrf_token值，后台拿到cookie中的csrf_token值后得到hashCode值然后与前端传过来的值进行比较，一样则通过。</p><h4 id="你有权限删除3号帖子"><a href="#你有权限删除3号帖子" class="headerlink" title="你有权限删除3号帖子"></a>你有权限删除3号帖子</h4><p><code>http://localhost:8081/deletePost.html</code></p><p><img src="https://images.morethink.cn/2ac5eab98780646c6c36dcdc98fa50c7.png" alt=""></p><h4 id="B网站的他已经没有权限了"><a href="#B网站的他已经没有权限了" class="headerlink" title="B网站的他已经没有权限了"></a>B网站的他已经没有权限了</h4><p>我们通过UserFilter.java给攻击者返回的是403错误，表示服务器理解用户客户端的请求但拒绝处理。</p><p><code>http://localhost:8082/deletePost.html</code>:<br><img src="https://images.morethink.cn/csrf-attack-fail-failure.gif" alt=""></p><p>攻击者不能删除4号帖子。</p><p>前端代码：</p><p>deletePost.html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>deletePost<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">deletePost</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> url = <span class="string">'/post/'</span> + <span class="built_in">document</span>.getElementById(<span class="string">"postId"</span>).value;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> csrf_token = <span class="built_in">document</span>.cookie.replace(<span class="regexp">/(?:(?:^|.*;\s*)csrf_token\s*\=\s*([^;]*).*$)|^.*$/</span>, <span class="string">"$1"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'csrf_token='</span> + csrf_token);</span></span><br><span class="line"><span class="javascript">            $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                type: <span class="string">"post"</span>,<span class="comment">//请求方式</span></span></span><br><span class="line"><span class="javascript">                url: url,  <span class="comment">//发送请求地址</span></span></span><br><span class="line"><span class="javascript">                timeout: <span class="number">30000</span>,<span class="comment">//超时时间：30秒</span></span></span><br><span class="line"><span class="undefined">                data: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="string">"_method"</span>: <span class="string">"delete"</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">"csrf_token"</span>: hash(csrf_token) <span class="comment">// 对csrf_token进行hash加密</span></span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="javascript">                dataType: <span class="string">"json"</span>,<span class="comment">//设置返回数据的格式</span></span></span><br><span class="line"><span class="javascript">                success: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (result.message == <span class="string">"success"</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        $(<span class="string">"#result"</span>).text(<span class="string">"删除成功"</span>);</span></span><br><span class="line"><span class="javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                        $(<span class="string">"#result"</span>).text(<span class="string">"删除失败"</span>);</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="javascript">                error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//请求出错的处理</span></span></span><br><span class="line"><span class="javascript">                    $(<span class="string">"#result"</span>).text(<span class="string">"请求出错"</span>);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// javascript的String到int(32位)的hash算法</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">str</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> hash = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (str.length == <span class="number">0</span>) <span class="keyword">return</span> hash;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span></span><br><span class="line"><span class="undefined">                char = str.charCodeAt(i);</span></span><br><span class="line"><span class="undefined">                hash = ((hash &lt;&lt; 5) - hash) + char;</span></span><br><span class="line"><span class="javascript">                hash = hash &amp; hash; <span class="comment">// Convert to 32bit integer</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> hash;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>删除帖子<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">帖子编号 ： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"postId"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"deletePost();"</span>&gt;</span>deletePost<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后台代码：</p><p>UserInterceptor.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.morethink.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.morethink.util.JsonUtil;</span><br><span class="line"><span class="keyword">import</span> cn.morethink.util.Result;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李文浩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/1/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        System.out.println(method);</span><br><span class="line">        <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">"POST"</span>) || method.equalsIgnoreCase(<span class="string">"DELETE"</span>)</span><br><span class="line">                || method.equalsIgnoreCase(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line">            String csrf_token = request.getParameter(<span class="string">"csrf_token"</span>);</span><br><span class="line">            Cookie[] cookies = request.getCookies();</span><br><span class="line">            <span class="keyword">if</span> (cookies != <span class="keyword">null</span> &amp;&amp; cookies.length &gt; <span class="number">0</span> &amp;&amp; csrf_token != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cookie.getName().equals(<span class="string">"csrf_token"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (Integer.valueOf(csrf_token) == cookie.getValue().hashCode()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Result result = <span class="keyword">new</span> Result(<span class="string">"403"</span>, <span class="string">"你还想攻击我??????????"</span>, <span class="string">""</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.write(JsonUtil.toJson(result));</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>cookie必须要设置PATH才可以生效，否则在下一次请求的时候无法带给服务器。</li><li>Spring Boot 出现启动找不到主类的问题时可以mvn clean一下。</li><li>Filter设置response.sendError(403)在Spring Boot没有效果。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面一共提到了4种攻击方式，分别是XSS攻击（关键是脚本，利用恶意脚本发起攻击），SQL注入（关键是通过用SQL语句伪造参数发出攻击），DDOS攻击（关键是发出大量请求，最后令服务器崩溃），CSRF攻击（关键是借助本地cookie进行认证，伪造发送请求）。</p><p><strong>参考文档</strong>：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/24249045" target="_blank" rel="noopener">XSS实战：我是如何拿下你的百度账号</a></li><li><a href="http://www.cnblogs.com/-new/p/7135814.html" target="_blank" rel="noopener">总结几种常见web攻击手段及其防御方式</a></li><li><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈CSRF攻击方式</a></li><li><a href="http://blog.csdn.net/zzhongcy/article/details/20133883" target="_blank" rel="noopener">jQueue 动态设置form表单的action属性的值和方法</a></li><li><a href="https://www.thinksaas.cn/group/topic/304242/" target="_blank" rel="noopener">javascript的String到int(32位)的hash算法</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搞Web开发离不开安全这个话题，确保网站或者网页应用的安全性，是每个开发人员都应该了解的事。本篇主要简单介绍在Web领域几种常见的攻击手段及Java Web中的预防方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#XSS&quot;&gt;XSS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#SQL注入&quot;&gt;SQL注入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#DDOS&quot;&gt;DDOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#CSRF&quot;&gt;CSRF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Web安全" scheme="https://www.morethink.cn/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Git同时push到多个远程仓库</title>
    <link href="https://www.morethink.cn/Git%E5%90%8C%E6%97%B6push%E5%88%B0%E5%A4%9A%E4%B8%AA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>https://www.morethink.cn/Git同时push到多个远程仓库/</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-05-23T16:31:10.718Z</updated>
    
    <content type="html"><![CDATA[<p>添加第二个远程地址时使用以下命令：<br><code>git remote set-url --add origin git@github.com:morethink/programming.git</code></p><p>查看远程分支：<code>git remote -v</code></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">origingit@git.coding.net:morethink/programming.git (fetch)</span><br><span class="line">origingit@git.coding.net:morethink/programming.git (push)</span><br><span class="line">originhexo@MyHost2:/var/repo/gitbook.git (push)</span><br></pre></td></tr></table></figure><p>也可以同时 push 到多个远程地址：<code>git push origin master</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Everything up-to-date</span><br><span class="line">Everything up-to-date</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;添加第二个远程地址时使用以下命令：&lt;br&gt;&lt;code&gt;git remote set-url --add origin git@github.com:morethink/programming.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看远程分支：&lt;code&gt;git remote -v&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://www.morethink.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="https://www.morethink.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>二叉树从右边看到的节点</title>
    <link href="https://www.morethink.cn/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%8E%E5%8F%B3%E8%BE%B9%E7%9C%8B%E5%88%B0%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://www.morethink.cn/二叉树从右边看到的节点/</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2018-06-29T09:32:08.288Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 LeetCode <a href="https://leetcode.com/problems/binary-tree-right-side-view/description/" target="_blank" rel="noopener">Binary Tree Right Side View</a> 解法的探讨。</p><p>题目：<br>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.<br><a id="more"></a><br>For example:<br>Given the following binary tree,<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure></p><p>You should return [1, 3, 4].</p><p>解法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为题目的二叉树并不是满二叉树，所以采用层序遍历的方式。</span></span><br><span class="line"><span class="comment"> * 将以前层序遍历中一个个出队的方式变为一层层出队，</span></span><br><span class="line"><span class="comment"> * 这样就能定位最右边的节点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="comment">//将每一层的节点都出队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode treeNode = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(treeNode.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(treeNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(treeNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 LeetCode &lt;a href=&quot;https://leetcode.com/problems/binary-tree-right-side-view/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Binary Tree Right Side View&lt;/a&gt; 解法的探讨。&lt;/p&gt;
&lt;p&gt;题目：&lt;br&gt;Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.morethink.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="https://www.morethink.cn/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>求小于n的素数个数</title>
    <link href="https://www.morethink.cn/%E6%B1%82%E5%B0%8F%E4%BA%8En%E7%9A%84%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0/"/>
    <id>https://www.morethink.cn/求小于n的素数个数/</id>
    <published>2018-03-10T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.192Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 LeetCode <a href="https://leetcode.com/problems/count-primes/description/" target="_blank" rel="noopener">Count Primes</a> 解法的探讨。</p><p>题目：<br>Count the number of prime numbers less than a non-negative number, n.</p><p>尽管题目并没有要我们写一个最优的算法，但是身为一个程序员，优化应该是一种习惯，在编程的过程中，随着思考进行优化。只要求我们满足给定的时间和空间即可。</p><p>如果你只能想出一个最简单的方法，难道你会有什么竞争力吗？</p><a id="more"></a><h1 id="穷举"><a href="#穷举" class="headerlink" title="穷举"></a>穷举</h1><p>最开始我用的就是这个方法，可以说这是最简单的一种方法了，而且最开始，我就是想的这种方法，说明：我没有对这个问题进行思考，没有去优化它，而作为一个程序员，如何提高效率是拿到一个问题首先要思考的事情。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i - <span class="number">1</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取开始时</span></span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"The num is "</span> + <span class="keyword">new</span> L_204_Count_Primes().countPrimes(<span class="number">2000000</span>));</span><br><span class="line">    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//获取结束时间</span></span><br><span class="line">    System.out.println(<span class="string">"程序运行时间： "</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间太长，已经不能计算。</p></blockquote><h1 id="只能是奇数且小于-sqrt-n"><a href="#只能是奇数且小于-sqrt-n" class="headerlink" title="只能是奇数且小于$\sqrt{n}$"></a>只能是奇数且小于$\sqrt{n}$</h1><p>思考后发现</p><ol><li>素数一定是奇数</li><li>若 n=ab 是个合数（其中 a 与 b ≠ 1）, 则其中一个约数 a 或 b 必定至大为  $\sqrt{n}$.</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= (<span class="keyword">int</span>) Math.sqrt(i); j++)</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The num is 148933<br>程序运行时间： 1124ms</p></blockquote><h1 id="试除法：数学知识的运用"><a href="#试除法：数学知识的运用" class="headerlink" title="试除法：数学知识的运用"></a>试除法：数学知识的运用</h1><p>查阅 <a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">算术基本定理</a>可知：</p><blockquote><p><strong>算术基本定理</strong> :<br>每个大于1的整数均可写成一个以上的素数之乘积，且除了质约数的排序不同外是唯一的</p></blockquote><p>也就是说我们可以每个数来除以得到的素数，这样可大大减少运行次数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0 1 不算做素数,2一定是素数</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.size() &amp;&amp; list.get(j) &lt;= (<span class="keyword">int</span>) Math.sqrt(n); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % list.get(j) == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The num is 148933<br>程序运行时间： 383ms</p></blockquote><h1 id="筛选法"><a href="#筛选法" class="headerlink" title="筛选法"></a>筛选法</h1><blockquote><p>埃拉托斯特尼筛法，简称埃氏筛，也有人称素数筛。这是一种简单且历史悠久的筛法，用来找出一定范围内所有的素数。</p><p>所使用的原理是从2开始，将每个素数的各个倍数，标记成合数。一个素数的各个倍数，是一个差为此素数本身的等差数列。此为这个筛法和试除法不同的关键之处，后者是以素数来测试每个待测数能否被整除。</p></blockquote><p>筛选法的策略是将素数的倍数全部筛掉，剩下的就是素数了，下图很生动的体现了筛选的过程：</p><p><img src="https://images.morethink.cn/dcp5x843_338cbm3tmg7_b.gif" alt="" title="筛选法"></p><p>筛选的过程是先筛掉非素数，针对本文的题目，每筛掉一个，素数数量-1即可，上面说过素数的一个特点，除了2，其它的素数都是奇数，所以我们只需在奇数范围内筛选就可以了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes4</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//false代表素数，true代表非素数</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="comment">//0不是素数</span></span><br><span class="line">    flags[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//1不是素数</span></span><br><span class="line">    flags[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> num = n - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= (<span class="keyword">int</span>) Math.sqrt(n); i++) &#123;</span><br><span class="line">        <span class="comment">//当i为素数时，i的所有倍数都不是素数</span></span><br><span class="line">        <span class="keyword">if</span> (!flags[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!flags[j]) &#123;</span><br><span class="line">                    flags[j] = <span class="keyword">true</span>;</span><br><span class="line">                    num--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The num is 148933<br>程序运行时间： 43ms</p></blockquote><p>全部代码放在：<br> <a href="https://github.com/morethink/algorithm/blob/master/src/algorithm/leetcode/L_204_Count_Primes.java" target="_blank" rel="noopener">https://github.com/morethink/algorithm/blob/master/src/algorithm/leetcode/L_204_Count_Primes.java</a></p><p><strong>参考文档</strong>：</p><ol><li><a href="https://program-think.blogspot.com/2011/12/prime-algorithm-1.html" target="_blank" rel="noopener">求质数算法的N种境界[1] - 试除法和初级筛法</a></li><li><a href="http://blog.csdn.net/ghsau/article/details/78768157" target="_blank" rel="noopener"> 求素数个数</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95" target="_blank" rel="noopener">埃拉托斯特尼筛法</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 LeetCode &lt;a href=&quot;https://leetcode.com/problems/count-primes/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Count Primes&lt;/a&gt; 解法的探讨。&lt;/p&gt;
&lt;p&gt;题目：&lt;br&gt;Count the number of prime numbers less than a non-negative number, n.&lt;/p&gt;
&lt;p&gt;尽管题目并没有要我们写一个最优的算法，但是身为一个程序员，优化应该是一种习惯，在编程的过程中，随着思考进行优化。只要求我们满足给定的时间和空间即可。&lt;/p&gt;
&lt;p&gt;如果你只能想出一个最简单的方法，难道你会有什么竞争力吗？&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.morethink.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="素数" scheme="https://www.morethink.cn/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java实现单链表的快速排序和归并排序</title>
    <link href="https://www.morethink.cn/Java%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.morethink.cn/Java实现单链表的快速排序和归并排序/</id>
    <published>2018-02-17T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.182Z</updated>
    
    <content type="html"><![CDATA[<p>本文描述了LeetCode 148题 <a href="https://leetcode.com/problems/sort-list/description/" target="_blank" rel="noopener">sort-list</a> 的解法。</p><p>题目描述如下:<br>Sort a linked list in O(n log n) time using constant space complexity.</p><p>题目要求我们在O(n log n)时间复杂度下完成对单链表的排序，我们知道平均时间复杂度为O(n log n)的排序方法有快速排序、归并排序和堆排序。而一般是用数组来实现二叉堆，当然可以用二叉树来实现，但是这么做太麻烦，还得花费额外的空间构建二叉树，于是不采用堆排序。<br><a id="more"></a><br>故本文采用快速排序和归并排序来对单链表进行排序。</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>在一般实现的快速排序中，我们通过首尾指针来对元素进行切分，下面采用快排的另一种方法来对元素进行切分。</p><p>我们只需要两个指针p1和p2，这两个指针均往next方向移动，移动的过程中保持p1之前的key都小于选定的key，p1和p2之间的key都大于选定的key，那么当p2走到末尾时交换p1与key值便完成了一次切分。</p><p>图示如下：<br><img src="http://img.blog.csdn.net/20140326225106296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZG91ZmVpX2Njc3Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用快速排序</span></span><br><span class="line">   quickSort(head, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(ListNode head, ListNode end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head != end) &#123;</span><br><span class="line">        ListNode node = partion(head, end);</span><br><span class="line">        quickSort(head, node);</span><br><span class="line">        quickSort(node.next, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">partion</span><span class="params">(ListNode head, ListNode end)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = head, p2 = head.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//走到末尾才停</span></span><br><span class="line">    <span class="keyword">while</span> (p2 != end) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//大于key值时，p1向前走一步，交换p1与p2的值</span></span><br><span class="line">        <span class="keyword">if</span> (p2.val &lt; head.val) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> temp = p1.val;</span><br><span class="line">            p1.val = p2.val;</span><br><span class="line">            p2.val = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当有序时，不交换p1和key值</span></span><br><span class="line">    <span class="keyword">if</span> (p1 != head) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = p1.val;</span><br><span class="line">        p1.val = head.val;</span><br><span class="line">        head.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序应该算是链表排序最佳的选择了，保证了最好和最坏时间复杂度都是nlogn，而且它在数组排序中广受诟病的空间复杂度在链表排序中也从O(n)降到了O(1)。</p><p>归并排序的一般步骤为：</p><ol><li>将待排序数组（链表）取中点并一分为二；</li><li>递归地对左半部分进行归并排序；</li><li>递归地对右半部分进行归并排序；</li><li>将两个半部分进行合并（merge）,得到结果。</li></ol><p>首先用快慢指针(快慢指针思路，快指针一次走两步，慢指针一次走一步，快指针在链表末尾时，慢指针恰好在链表中点)的方法找到链表中间节点，然后递归的对两个子链表排序，把两个排好序的子链表合并成一条有序的链表。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用归并排序</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取中间结点</span></span><br><span class="line">    ListNode mid = getMid(head);</span><br><span class="line">    ListNode right = mid.next;</span><br><span class="line">    mid.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="keyword">return</span> mergeSort(sortList(head), sortList(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取链表的中间结点,偶数时取中间第一个</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">getMid</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针</span></span><br><span class="line">    ListNode slow = head, quick = head;</span><br><span class="line">    <span class="comment">//快2步，慢一步</span></span><br><span class="line">    <span class="keyword">while</span> (quick.next != <span class="keyword">null</span> &amp;&amp; quick.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        quick = quick.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 归并两个有序的链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeSort</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = head1, p2 = head2, head;</span><br><span class="line">   <span class="comment">//得到头节点的指向</span></span><br><span class="line">    <span class="keyword">if</span> (head1.val &lt; head2.val) &#123;</span><br><span class="line">        head = head1;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = head2;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode p = head;</span><br><span class="line">    <span class="comment">//比较链表中的值</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p1.val &lt;= p2.val) &#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二条链表空了</span></span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一条链表空了</span></span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码放在：<br><a href="https://github.com/morethink/algorithm/blob/master/src/algorithm/leetcode/SortList.java" target="_blank" rel="noopener">https://github.com/morethink/algorithm/blob/master/src/algorithm/leetcode/SortList.java</a></p><p><strong>参考文档</strong>：</p><ol><li><a href="http://www.cnblogs.com/TenosDoIt/p/3666585.html" target="_blank" rel="noopener">链表排序（冒泡、选择、插入、快排、归并、希尔、堆排序）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文描述了LeetCode 148题 &lt;a href=&quot;https://leetcode.com/problems/sort-list/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sort-list&lt;/a&gt; 的解法。&lt;/p&gt;
&lt;p&gt;题目描述如下:&lt;br&gt;Sort a linked list in O(n log n) time using constant space complexity.&lt;/p&gt;
&lt;p&gt;题目要求我们在O(n log n)时间复杂度下完成对单链表的排序，我们知道平均时间复杂度为O(n log n)的排序方法有快速排序、归并排序和堆排序。而一般是用数组来实现二叉堆，当然可以用二叉树来实现，但是这么做太麻烦，还得花费额外的空间构建二叉树，于是不采用堆排序。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.morethink.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="https://www.morethink.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="排序" scheme="https://www.morethink.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java实现八大排序算法</title>
    <link href="https://www.morethink.cn/Java%E5%AE%9E%E7%8E%B0%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://www.morethink.cn/Java实现八大排序算法/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-06-23T07:56:08.363Z</updated>
    
    <content type="html"><![CDATA[<p>本文对常见的排序算法进行了总结。</p><p>常见排序算法如下：</p><ol><li><a href="#直接插入排序">直接插入排序</a></li><li><a href="#希尔排序">希尔排序</a></li><li><a href="#简单选择排序">简单选择排序</a></li><li><a href="#堆排序">堆排序</a></li><li><a href="#冒泡排序">冒泡排序</a></li><li><a href="#快速排序">快速排序</a></li><li><a href="#归并排序">归并排序</a></li><li><a href="#基数排序">基数排序</a></li></ol><a id="more"></a><p>它们都属于内部排序，也就是只考虑数据量较小仅需要使用内存的排序算法，他们之间关系如下：<br>$$<br>\begin{cases}内部排序 \begin{cases}插入排序\begin{cases}直接插入排序\希尔排序\end{cases}\选择排序\begin{cases}简单选择排序\堆排序\end{cases}\交换排序\begin{cases}冒泡排序\快速排序 \end{cases}\归并排序\<br>基数排序\end{cases}\外部排序 \end{cases}<br>$$</p><p><strong>稳定与非稳定</strong>:</p><p>如果一个排序算法能够保留数组中重复元素的相对位置则可以被称为是 <strong>稳定</strong> 的。反之，则是 <strong>非稳定</strong> 的。</p><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了要给插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><p>动态效果如下：</p><p><img src="https://images.morethink.cn/28749729-ca072084-7503-11e7-881c-92aa915ce369.gif" alt=""></p><p><strong>注意</strong>：<br>如果 <em>比较操作</em> 的代价比 <em>交换操作</em> 大的话，可以采用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95" target="_blank" rel="noopener">二分查找法</a>来减少 <em>比较操作</em> 的数目。该算法可以认为是 <strong>插入排序</strong> 的一个变种，称为<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">二分查找插入排序</a>。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过交换进行插入排序，借鉴冒泡排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">                a[j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过将较大的元素都向右移动而不总是交换两个元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = a[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; num &lt; a[j]; j--) &#123;</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>直接插入排序复杂度如下：</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><h2 id="比较与总结"><a href="#比较与总结" class="headerlink" title="比较与总结"></a>比较与总结</h2><p>插入排序所需的时间取决于输入元素的初始顺序。例如，对一个很大且其中的元素已经有序(或接近有序)的数组进行排序将会比随机顺序的数组或是逆序数组进行排序要快得多。</p><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序，也称 <strong>递减增量排序算法</strong>，是插入排序的一种更高效的改进版本。希尔排序是 <strong>非稳定排序算法</strong>。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一</li></ul><p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h2 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h2><p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。</p><p>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是<strong>初次取数组长度的一半</strong>为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97" target="_blank" rel="noopener">维基百科</a>。</p><h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><ol><li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li><li>按增量序列个数 k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><p>效果如下：</p><p><img src="https://images.morethink.cn/4697893fd8a952d01956e192640c1c3c.png" alt=""></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面参考《算法》中给出的步长选择策略，《算法》中给出的解释是</p><blockquote><p>下面代码中递增序列的计算和使用都很简单，和复杂递增序列的性能接近。当可以证明复杂的序列在最坏情况下的性能要好于我们所使用的递增序列。更加优秀的递增序列有待我们去发现。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = a.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; length / <span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; h &gt;= <span class="number">1</span>; h /= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - h; i += h) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + h; j &gt; <span class="number">0</span>; j -= h) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[j - h]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                    a[j] = a[j - h];</span><br><span class="line">                    a[j - h] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>以下是希尔排序复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog2 n)</td><td>O(nlog2 n)</td><td>O(nlog2 n)</td><td>O(1)</td></tr></tbody></table><h2 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h2><p>希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。</p><h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><h2 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h2><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n个元素的表进行排序总共进行至多 n-1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><h2 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h2><ol><li>从未排序序列中，找到关键字最小的元素</li><li>如果最小元素不是未排序序列的第一个元素，将其和未排序序列第一个元素互换</li><li>重复1、2步，直到排序结束。</li></ol><p>动图效果如下所示：<br><img src="https://images.morethink.cn/28749720-90304278-7503-11e7-9bc8-e3b56539d8bf.gif" alt=""></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="comment">//选出之后待排序中值最小的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最小值不等于当前值时进行交换</span></span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[min];</span><br><span class="line">            a[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>以下是选择排序复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><h2 id="总结与思考-1"><a href="#总结与思考-1" class="headerlink" title="总结与思考"></a>总结与思考</h2><p>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²/2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><blockquote><p>1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd) 和威廉姆斯(J．Williams) 在1964年共同发明了著名的堆排序算法(Heap Sort).</p></blockquote><p>堆的定义如下：$n$个元素的序列{k1,k2,..,kn}<br>当且仅当满足下关系时，称之为堆。</p><p><img src="https://images.morethink.cn/a59e9c9d21c72944dac53b59b745a5cc.png" alt=""></p><p>把此序列对应的二维数组看成一个完全二叉树。那么堆的含义就是：<strong>完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。</strong> 由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。</p><h2 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h2><p>此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p><h2 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h2><ol><li>先将初始序列$K[1..n]$建成一个大顶堆, 那么此时第一个元素$K_1$最大, 此堆为初始的无序区.</li><li>再将关键字最大的记录$K_1$ (即堆顶, 第一个元素)和无序区的最后一个记录 $K_n$ 交换, 由此得到新的无序区$K[1..n-1]$和有序区$K[n]$, 且满足$K[1..n-1].keys \leqslant K[n].key$</li><li>交换$K_1$ 和 $K_n$ 后, 堆顶可能违反堆性质, 因此需将$K[1..n-1]$调整为堆. 然后重复步骤2, 直到无序区只有一个元素时停止。</li></ol><p>动图效果如下所示：</p><p><img src="https://images.morethink.cn/heap_sort_gif.gif" alt="堆排序过程"></p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。</p><p>总结起来就是定义了以下几种操作：</p><ul><li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ul><p>对于堆节点的访问：</p><ul><li>父节点i的左子节点在位置：<code>(2*i+1)</code>;</li><li>父节点i的右子节点在位置：<code>(2*i+2)</code>;</li><li>子节点i的父节点在位置：<code>floor((i-1)/2)</code>;</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        max_heapify(a, i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//堆顶元素(第一个元素)与Kn交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = a[i];</span><br><span class="line">        a[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  将数组堆化</span></span><br><span class="line"><span class="comment"> *  i = 第一个非叶子节点。</span></span><br><span class="line"><span class="comment"> *  从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。</span></span><br><span class="line"><span class="comment"> *  叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//左子节点位置</span></span><br><span class="line">        child = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//右子节点存在且大于左子节点，child变成右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (child != n &amp;&amp; a[child] &lt; a[child + <span class="number">1</span>]) &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换父节点与左右子节点中的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[child]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[child];</span><br><span class="line">            a[child] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ol><li>建立堆的过程, 从length/2 一直处理到0, 时间复杂度为O(n);</li><li>调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);</li><li>堆排序的过程由n次第2步完成, 时间复杂度为O(nlgn).</li></ol><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>$O(n \log_{2}n)$</td><td>$O(n \log_{2}n)$</td><td>$O(n \log_{2}n)$</td><td>$O(1)$</td></tr></tbody></table><h2 id="总结与思考-2"><a href="#总结与思考-2" class="headerlink" title="总结与思考"></a>总结与思考</h2><p><strong>由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列</strong>。 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序。</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><blockquote><p>我想对于它每个学过C语言的都会了解，这可能是很多人接触的第一个排序算法。</p></blockquote><h2 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h2><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h2 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h2><p>冒泡排序算法的运作如下：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p><img src="https://images.morethink.cn/bubble.gif" alt=""></p><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//外层循环控制比较的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//内层循环控制到达位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//前面的元素比后面大就交换</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>以下是冒泡排序算法复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</p><h2 id="总结与思考-3"><a href="#总结与思考-3" class="headerlink" title="总结与思考"></a>总结与思考</h2><p>由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><h2 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h2><p>快速排序的基本思想：<strong>挖坑填数+分治法</strong>。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好。</p><h2 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h2><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：</p><ol><li>从数列中挑出一个元素，称为”基准”（pivot）。</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p><img src="https://images.morethink.cn/quick-sort.gif" alt=""></p><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><p>用伪代码描述如下：</p><ol><li><code>i = L; j = R;</code> 将基准数挖出形成第一个坑<code>a[i]</code>。</li><li><code>j--</code>，由后向前找比它小的数，找到后挖出此数填前一个坑<code>a[i]</code>中。</li><li><code>i++</code>，由前向后找比它大的数，找到后也挖出此数填到前一个坑<code>a[j]</code>中。</li><li>再重复执行2，3二步，直到<code>i==j</code>，将基准数填入<code>a[i]</code>中</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已经排完</span></span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = low;</span><br><span class="line">    <span class="keyword">int</span> right = high;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存基准值</span></span><br><span class="line">    <span class="keyword">int</span> pivot = a[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">//从后向前找到比基准小的元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= pivot)</span><br><span class="line">            right--;</span><br><span class="line">        a[left] = a[right];</span><br><span class="line">        <span class="comment">//从前往后找到比基准大的元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= pivot)</span><br><span class="line">            left++;</span><br><span class="line">        a[right] = a[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放置基准值，准备分治递归快排</span></span><br><span class="line">    a[left] = pivot;</span><br><span class="line">    sort(a, low, left - <span class="number">1</span>);</span><br><span class="line">    sort(a, left + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是递归版的快速排序：通过把基准插入到合适的位置来实现分治，并递归地对分治后的两个划分继续快排。那么非递归版的快排如何实现呢？</p><p>因为 <strong>递归的本质是栈</strong> ，所以我们非递归实现的过程中，可以借助栈来保存中间变量就可以实现非递归了。在这里中间变量也就是通过Pritation函数划分区间之后分成左右两部分的首尾指针，只需要保存这两部分的首尾指针即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortByStack</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始状态的左右指针入栈</span></span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    stack.push(a.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//出栈进行划分</span></span><br><span class="line">        <span class="keyword">int</span> high = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> low = stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivotIndex = partition(a, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存中间变量</span></span><br><span class="line">        <span class="keyword">if</span> (pivotIndex &gt; low) &#123;</span><br><span class="line">            stack.push(low);</span><br><span class="line">            stack.push(pivotIndex - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pivotIndex &lt; high &amp;&amp; pivotIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            stack.push(pivotIndex + <span class="number">1</span>);</span><br><span class="line">            stack.push(high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = low;</span><br><span class="line">    <span class="keyword">int</span> right = high;</span><br><span class="line">    <span class="comment">//保存基准的值</span></span><br><span class="line">    <span class="keyword">int</span> pivot = a[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">//从后向前找到比基准小的元素，插入到基准位置中</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= pivot) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[left] = a[right];</span><br><span class="line">        <span class="comment">//从前往后找到比基准大的元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= pivot) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        a[right] = a[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准值，准备分治递归快排</span></span><br><span class="line">    a[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h2><h3 id="切换到插入排序"><a href="#切换到插入排序" class="headerlink" title="切换到插入排序"></a>切换到插入排序</h3><p>和大多数递归排序算法一样，改进快速排序性能的一个简单方法基于以下两点：</p><ul><li>对于小数组，快速排序比插入排序慢</li><li>因为递归，快速排序的sort()方法在小数组中叶会调用自己</li></ul><p>因此，在排序小数组时应该切换到插入排序。</p><h3 id="三者取中法"><a href="#三者取中法" class="headerlink" title="三者取中法"></a>三者取中法</h3><p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。</p><h3 id="三向快速排序"><a href="#三向快速排序" class="headerlink" title="三向快速排序"></a>三向快速排序</h3><p>实际应用中经常会出现含有大量重复元素的数组。例如，一个元素全部重复的子数组就不需要继续排序了，但我们的算法还会继续将它切分为更小的数组。在有大量重复元素的情况下，快速排序的递归性会使元素全部重复的子数组经常出现，这就有很大的改进潜力，经当前实现的线性对数级的性能提高到线性级别。</p><p><strong>算法描述</strong>：</p><ul><li>在lt之前的(lo~lt-1)都小于中间值</li><li>在gt之前的(gt+1~hi)都大于中间值</li><li>在lt~i-1的都等于中间值</li><li>在i~gt的都还不确定（最终i会大于gt，即不确定的将不复存在）</li></ul><p><img src="https://images.morethink.cn/9f4bd508a48664b472e5644e48c2be4b.png" alt=""></p><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortThreeWay</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> v = a[lo], lt = lo, i = lo + <span class="number">1</span>, gt = hi;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; v) &#123;</span><br><span class="line">            swap(a, i++, lt++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; v) &#123;</span><br><span class="line">            swap(a, i, gt--);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortThreeWay(a, lo, lt - <span class="number">1</span>);</span><br><span class="line">    sortThreeWay(a, gt + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>以下是快速排序算法复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n²)</td><td>O(1)（原地分区递归版）</td></tr></tbody></table><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p><h2 id="基本思想-6"><a href="#基本思想-6" class="headerlink" title="基本思想"></a>基本思想</h2><p>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p><img src="https://images.morethink.cn/merge.gif" alt="这个图很有概括性，来自维基"></p><h2 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h2><p><strong>归并排序可通过两种方式实现</strong>:</p><ul><li>自上而下的递归</li><li>自下而上的迭代</li></ul><p><strong>递归法</strong>（假设序列共有n个元素）：</p><ol><li>将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</li><li>将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</li><li>重复步骤2，直到所有元素排序完毕。</li></ol><p><img src="https://images.morethink.cn/merging-sort.gif" alt=""></p><p><strong>迭代法</strong></p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><p>归并排序其实要做两件事：</p><ul><li>分解：将序列每次折半拆分</li><li>合并：将划分后的序列段两两排序合并</li></ul><p>因此，归并排序实际上就是两个操作，拆分+合并</p><p>下面是递归的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并所需的辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一次性分配空间</span></span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//将左半边排序</span></span><br><span class="line">        sort(a, low, mid);</span><br><span class="line">        <span class="comment">//将右半边排序</span></span><br><span class="line">        sort(a, mid + <span class="number">1</span>, high);</span><br><span class="line">        merge(a, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法先将所有元素复制到aux[]中，然后在归并会a[]中。方法咋归并时(第二个for循环)</span></span><br><span class="line"><span class="comment">     * 进行了4个条件判断：</span></span><br><span class="line"><span class="comment">     * - 左半边用尽(取右半边的元素)</span></span><br><span class="line"><span class="comment">     * - 右半边用尽(取左半边的元素)</span></span><br><span class="line"><span class="comment">     * - 右半边的当前元素小于左半边的当前元素(取右半边的元素)</span></span><br><span class="line"><span class="comment">     * - 右半边的当前元素大于等于左半边的当前元素(取左半边的元素)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> low</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> high</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将a[low..mid]和a[mid+1..high]归并</span></span><br><span class="line">        <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = low; k &lt;= high; k++) &#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = low; k &lt;= high; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">                a[k] = aux[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; high) &#123;</span><br><span class="line">                a[k] = aux[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[j] &lt; aux[i]) &#123;</span><br><span class="line">                a[k] = aux[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a[k] = aux[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>以下是归并排序算法复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n)</td></tr></tbody></table><p>从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。</p><h2 id="总结与思考-4"><a href="#总结与思考-4" class="headerlink" title="总结与思考"></a>总结与思考</h2><p>归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需时间和NlogN成正比，它的主要缺点则是他所需的额外空间和N成正比。</p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）, 排序器每次只能看到一个列。它是基于元素值的每个位上的字符来排序的。 对于数字而言就是分别基于个位，十位， 百位或千位等等数字来排序。</p><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h2 id="基本思想-7"><a href="#基本思想-7" class="headerlink" title="基本思想"></a>基本思想</h2><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>基数排序按照优先从高位或低位来排序有两种实现方案：</p><ul><li><p><strong>MSD（Most significant digital） 从最左侧高位开始进行排序</strong>。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。<em>MSD方式适用于位数多的序列</em>。</p></li><li><p><strong>LSD （Least significant digital）从最右侧低位开始进行排序</strong>。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。<em>LSD方式适用于位数少的序列</em>。</p></li></ul><p><img src="https://images.morethink.cn/radix-sort_sample.gif" alt="基数排序LSD动图演示"></p><h2 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h2><p>我们以LSD为例，从最低位开始，具体算法描述如下：</p><ol><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ol><h2 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h2><p>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p><ul><li><p><strong>分配</strong>：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</p></li><li><p><strong>收集</strong>：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取得数组中的最大数，并取得位数</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; arr[i]) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxDigit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (max / <span class="number">10</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigit++;</span><br><span class="line">        max = max / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//申请一个桶空间</span></span><br><span class="line">    <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从低位到高位，对每一位遍历，将所有元素分配到桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bktLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];        <span class="comment">//存储各个桶中存储元素的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配：将所有元素分配到桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> whichBucket = (arr[j] % base) / (base / <span class="number">10</span>);</span><br><span class="line">            buckets[whichBucket][bktLen[whichBucket]] = arr[j];</span><br><span class="line">            bktLen[whichBucket]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; buckets.length; b++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; bktLen[b]; p++) &#123;</span><br><span class="line">                arr[k++] = buckets[b][p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Sorting: "</span> + Arrays.toString(arr));</span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>以下是基数排序算法复杂度，其中k为最大数的位数：</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(d*(n+r))</td><td>O(d*(n+r))</td><td>O(d*(n+r))</td><td>O(n+r)</td></tr></tbody></table><p>其中，<strong>d 为位数，r 为基数，n 为原数组个数</strong>。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 <code>O(d*(n + r))</code>。</p><h2 id="总结和思考"><a href="#总结和思考" class="headerlink" title="总结和思考"></a>总结和思考</h2><p>基数排序更适合用于对时间, 字符串等这些 <strong>整体权值未知的数据</strong> 进行排序。</p><p>基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ol><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ol><h1 id="八大排序算法总结"><a href="#八大排序算法总结" class="headerlink" title="八大排序算法总结"></a>八大排序算法总结</h1><p>各种排序性能对比如下:</p><table><thead><tr><th>排序类型</th><th>平均情况</th><th>最好情况</th><th>最坏情况</th><th>辅助空间</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>直接插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>折半插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n^1.3)</td><td>O(nlogn)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n²)</td><td>O(nlog₂n)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n²)</td><td>O(n+k)</td><td>(不)稳定</td></tr><tr><td>基数排序</td><td>O(d(n+k))</td><td>O(d(n+k))</td><td>O(d(n+kd))</td><td>O(n+kd)</td><td>稳定</td></tr></tbody></table><p>从时间复杂度来说：</p><ol><li>平方阶O(n²)排序：<strong>各类简单排序：直接插入、直接选择和冒泡排序</strong></li><li>线性对数阶O(nlog₂n)排序：<strong>快速排序、堆排序和归并排序</strong></li><li>O(n1+§))排序，§是介于0和1之间的常数：<strong>希尔排序</strong></li><li>线性阶O(n)排序：<strong>基数排序，此外还有桶、箱排序</strong></li></ol><p>论是否有序的影响：</p><ul><li>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</li><li>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；</li><li>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</li></ul><p><img src="https://images.morethink.cn/sort-comparison.png" alt=""></p><p>代码放在 <a href="https://github.com/morethink/algorithm/tree/master/src/algorithm/sort" target="_blank" rel="noopener">https://github.com/morethink/algorithm/tree/master/src/algorithm/sort</a></p><p><strong>参考资料</strong>：</p><ol><li>《算法》第四版</li><li>维基百科</li><li><a href="https://itimetraveler.github.io/2017/07/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/#%E4%B8%83%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merging-Sort%EF%BC%89" target="_blank" rel="noopener">八大排序算法总结与java实现</a></li><li><a href="https://segmentfault.com/a/1190000010413296#articleHeader33" target="_blank" rel="noopener">前端面试必备——十大经典排序算法</a></li><li><a href="https://www.jianshu.com/p/8c915179fd02" target="_blank" rel="noopener">必须知道的八大种排序算法【java实现】</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对常见的排序算法进行了总结。&lt;/p&gt;
&lt;p&gt;常见排序算法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#直接插入排序&quot;&gt;直接插入排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#希尔排序&quot;&gt;希尔排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#简单选择排序&quot;&gt;简单选择排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#堆排序&quot;&gt;堆排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#冒泡排序&quot;&gt;冒泡排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#快速排序&quot;&gt;快速排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#归并排序&quot;&gt;归并排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#基数排序&quot;&gt;基数排序&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.morethink.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.morethink.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java实现二分查找算法</title>
    <link href="https://www.morethink.cn/Java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>https://www.morethink.cn/Java实现二分查找算法/</id>
    <published>2018-01-28T16:00:00.000Z</published>
    <updated>2018-06-16T15:01:46.349Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找（binary search），也称折半搜索，是一种在 <strong>有序数组</strong> 中 <strong>查找某一特定元素</strong> 的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p><ul><li><strong>时间复杂度</strong>:折半搜索每次把搜索区域减少一半，时间复杂度为O(log n)。（n代表集合中元素的个数）</li><li><strong>空间复杂度</strong>: O(1)。虽以递归形式定义，但是尾递归，可改写为循环。</li></ul><a id="more"></a><h1 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h1><p><img src="https://images.morethink.cn/binary-search.gif" alt="binary-search" title="二分查找"></p><h1 id="代码描述"><a href="#代码描述" class="headerlink" title="代码描述"></a>代码描述</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarysearch</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (array[mid] &gt; target)</span><br><span class="line">        <span class="keyword">return</span> binarysearch(array, low, mid - <span class="number">1</span>, target);</span><br><span class="line">    <span class="keyword">if</span> (array[mid] &lt; target)</span><br><span class="line">        <span class="keyword">return</span> binarysearch(array, mid + <span class="number">1</span>, high, target);</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearchWithoutRecursion</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; key)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找中值的计算"><a href="#二分查找中值的计算" class="headerlink" title="二分查找中值的计算"></a>二分查找中值的计算</h1><p>这是一个经典的话题，如何计算二分查找中的中值？大家一般给出了两种计算方法：</p><ul><li>算法一： <code>mid = (low + high) / 2</code></li><li>算法二： <code>mid = low + (high – low)/2</code></li></ul><p>乍看起来，算法一简洁，算法二提取之后，跟算法一没有什么区别。但是实际上，区别是存在的。算法一的做法，在极端情况下，(low + high)存在着溢出的风险，进而得到错误的mid结果，导致程序错误。而算法二能够保证计算出来的mid，一定大于low，小于high，不存在溢出的问题。</p><h1 id="二分查找法的缺陷"><a href="#二分查找法的缺陷" class="headerlink" title="二分查找法的缺陷"></a>二分查找法的缺陷</h1><p>二分查找法的O(log n)让它成为十分高效的算法。不过它的缺陷却也是那么明显的。就在它的限定之上：必须有序，我们很难保证我们的数组都是有序的。当然可以在构建数组的时候进行排序，可是又落到了第二个瓶颈上：它必须是数组。</p><p>数组读取效率是O(1)，可是它的插入和删除某个元素的效率却是O(n)。因而导致构建有序数组变成低效的事情。</p><p>解决这些缺陷问题更好的方法应该是使用二叉查找树了，最好自然是自平衡二叉查找树了，既能高效的（O(n log n)）构建有序元素集合，又能如同二分查找法一样快速（O(log n)）的搜寻目标数。</p><p><strong>参考资料</strong>：</p><ol><li><a href="http://www.cnblogs.com/ider/archive/2012/04/01/binary_search.html" target="_blank" rel="noopener">二分查找法的实现和应用汇总</a></li><li><a href="http://hedengcheng.com/?p=595" target="_blank" rel="noopener">二分查找(Binary Search)需要注意的问题，以及在数据库内核中的实现</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二分查找（binary search），也称折半搜索，是一种在 &lt;strong&gt;有序数组&lt;/strong&gt; 中 &lt;strong&gt;查找某一特定元素&lt;/strong&gt; 的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;:折半搜索每次把搜索区域减少一半，时间复杂度为O(log n)。（n代表集合中元素的个数）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: O(1)。虽以递归形式定义，但是尾递归，可改写为循环。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.morethink.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="https://www.morethink.cn/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Win10下通过IIS调试ASP程序遇到的问题和解决方案</title>
    <link href="https://www.morethink.cn/Win10-through-the-IIS-debugging-ASP-program/"/>
    <id>https://www.morethink.cn/Win10-through-the-IIS-debugging-ASP-program/</id>
    <published>2018-01-05T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.188Z</updated>
    
    <content type="html"><![CDATA[<p>最近维护了以前别人的写的一个ASP的系统，记录一下调试过程中的问题和解决方案。</p><h1 id="环境篇"><a href="#环境篇" class="headerlink" title="环境篇"></a>环境篇</h1><h1 id="万维网发布服务-W3SVC-已经停止"><a href="#万维网发布服务-W3SVC-已经停止" class="headerlink" title="万维网发布服务(W3SVC)已经停止"></a>万维网发布服务(W3SVC)已经停止</h1><p><strong>问题</strong>：<br>万维网发布服务(W3SVC)已经停止。除非万维网发布服务(W3SVC)正在运行,否则无法启动网站。</p><a id="more"></a><p><img src="https://images.morethink.cn/d479322a25d8c93f9bf481695af50858.png" alt=""></p><p><strong>解决方法</strong>：</p><p>需要先启动整个应用。</p><p><img src="https://images.morethink.cn/31b0292ddbc24480229d1fbce590bb8e.png" alt=""></p><h1 id="IIS服务"><a href="#IIS服务" class="headerlink" title="IIS服务"></a>IIS服务</h1><p>控制面板&gt;&gt;程序和功能&gt;&gt;启动或关闭Windows功能&gt;&gt;IIS服务<br><img src="https://images.morethink.cn/729c9c06256b9029cadf7e00cbbfc667.png" alt=""></p><p>但是这样仅仅是开启了IIS服务，会出现Http500错误，不能运行ASP程序，因为IIS服务器默认并没有帮我们配置ASP或者ASP.NET环境，需要自己手动配置(在此过程中，我启动过多次电脑)。</p><h1 id="配置ASP环境"><a href="#配置ASP环境" class="headerlink" title="配置ASP环境"></a>配置ASP环境</h1><p>ASP配置如下：<br><img src="https://images.morethink.cn/a1339b7725b29585940ccd745fcd7512.png" alt=""></p><p>如果需要ASP.NET，需要如下配置：</p><p><img src="https://images.morethink.cn/8e827a63559409b25937857d136e236f.png" alt=""></p><h1 id="IIS7中出现An-error-occurred-on-the-server-when-processing-the-URL错误"><a href="#IIS7中出现An-error-occurred-on-the-server-when-processing-the-URL错误" class="headerlink" title="IIS7中出现An error occurred on the server when processing the URL错误"></a>IIS7中出现An error occurred on the server when processing the URL错误</h1><p><strong>错误描述</strong>：<br>An error occurred on the server when processing the URL. Please contact the system administrator.If you are the system administrator please click here to find out more about this error.</p><ol><li>打开控制面板→管理工具→Internet 信息服务(IIS)管理器→双击“ASP”图标<br><img src="https://images.morethink.cn/4cc9001c24f9705e91f4257074f8673c.png" alt=""></li><li>在左边的窗口中找到你的网站，然后在右边的窗口中展开“调试属性”，把“将错误发送到浏览器”设为True即可<br><img src="https://images.morethink.cn/4a629fd49cf2edefc97cc61a7f1d0d4f.png" alt=""></li></ol><p>此时你再运行ASP程序时就会看到具体的错误了，然后再根据错误提示进行相应的修改即可。</p><h1 id="代码篇"><a href="#代码篇" class="headerlink" title="代码篇"></a>代码篇</h1><h1 id="ADODB-Connection-错误-‘800a0e7a’"><a href="#ADODB-Connection-错误-‘800a0e7a’" class="headerlink" title="ADODB.Connection 错误 ‘800a0e7a’"></a>ADODB.Connection 错误 ‘800a0e7a’</h1><p><strong>具体错误</strong>：<br>ADODB.Connection 错误 ‘800a0e7a’<br>未找到提供程序。该程序可能未正确安装。</p><p><strong>原因</strong>：</p><p>因为系统是64位的win10，所以会出现这个问题。</p><p><strong>解决办法</strong>：<br>找到IIS应用程序池，“设置应用程序池默认属性”-&gt;“常规”-&gt;”启用 32 位应用程序”，设置为 True。</p><p><img src="https://images.morethink.cn/bb814d72e30f1a99899cc7e919fa774e.png" alt=""><br>height=”100%” width=”100%”</p><p>style=”width:757px; height:455px;”<br>这样问题就解决了。</p><h1 id="ADODB-Recordset-错误-‘800a0cc1’"><a href="#ADODB-Recordset-错误-‘800a0cc1’" class="headerlink" title="ADODB.Recordset 错误 ‘800a0cc1’"></a>ADODB.Recordset 错误 ‘800a0cc1’</h1><p><strong>描述</strong>：<br>ADODB.Recordset 错误 ‘800a0cc1’<br>在对应所需名称或序数的集合中，未找到项目。</p><p><strong>解决</strong>：<br>一般是字段写错了或者，你的数据库没有这个字段。</p><h1 id="iframe自适应"><a href="#iframe自适应" class="headerlink" title="iframe自适应"></a>iframe自适应</h1><p>JS代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//iframe高度自适应</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IFrameReSize</span>(<span class="params">iframename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pTar = <span class="built_in">document</span>.getElementByIdx_x_x(iframename);</span><br><span class="line">    <span class="keyword">if</span> (pTar) &#123; <span class="comment">//ff</span></span><br><span class="line">        <span class="keyword">if</span> (pTar.contentDocument &amp;&amp; pTar.contentDocument.body.offsetHeight) &#123;</span><br><span class="line">            pTar.height = pTar.contentDocument.body.offsetHeight;</span><br><span class="line">        &#125; <span class="comment">//ie</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pTar.Document &amp;&amp; pTar.Document.body.scrollHeight) &#123;</span><br><span class="line"></span><br><span class="line">            pTar.height = pTar.Document.body.scrollHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//iframe宽度自适应</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IFrameReSizeWidth</span>(<span class="params">iframename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pTar = <span class="built_in">document</span>.getElementByIdx_x_x(iframename);</span><br><span class="line">    <span class="keyword">if</span> (pTar) &#123; <span class="comment">//ff</span></span><br><span class="line">        <span class="keyword">if</span> (pTar.contentDocument &amp;&amp; pTar.contentDocument.body.offsetWidth) &#123;</span><br><span class="line">            pTar.width = pTar.contentDocument.body.offsetWidth;</span><br><span class="line">        &#125; <span class="comment">//ie</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pTar.Document &amp;&amp; pTar.Document.body.scrollWidth) &#123;</span><br><span class="line">            pTar.width = pTar.Document.body.scrollWidth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Iframe框配置：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"Main.htm"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">height</span>=<span class="string">"100%"</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"mainFrame"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">onload</span>=<span class="string">'IFrameReSize("mainFrame");IFrameReSizeWidth("mainFrame");'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="ACCESS分页"><a href="#ACCESS分页" class="headerlink" title="ACCESS分页"></a>ACCESS分页</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> nid <span class="keyword">between</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">min</span>(nid) <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> top <span class="number">4</span> nid <span class="keyword">from</span> newsdata <span class="keyword">order</span> <span class="keyword">by</span> nid <span class="keyword">desc</span>))</span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">min</span>(nid) <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> top <span class="number">1</span> nid <span class="keyword">from</span> newsdata <span class="keyword">order</span> <span class="keyword">by</span> nid <span class="keyword">desc</span>))</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> nid <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>利用top和min函数分别找出分页的起始ID和结束ID，如果要按照升序排列，就要用top和max来找出起始ID和结束ID，之后在使用between语句直接选取。注意三个地方的排序方式必须一致，查询条件也必须一致。</p><p><strong>参考文档</strong>：</p><ol><li><a href="http://www.ljf.cn/archives/2281" target="_blank" rel="noopener">简单又高效的Access分页语句</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近维护了以前别人的写的一个ASP的系统，记录一下调试过程中的问题和解决方案。&lt;/p&gt;
&lt;h1 id=&quot;环境篇&quot;&gt;&lt;a href=&quot;#环境篇&quot; class=&quot;headerlink&quot; title=&quot;环境篇&quot;&gt;&lt;/a&gt;环境篇&lt;/h1&gt;&lt;h1 id=&quot;万维网发布服务-W3SVC-已经停止&quot;&gt;&lt;a href=&quot;#万维网发布服务-W3SVC-已经停止&quot; class=&quot;headerlink&quot; title=&quot;万维网发布服务(W3SVC)已经停止&quot;&gt;&lt;/a&gt;万维网发布服务(W3SVC)已经停止&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：&lt;br&gt;万维网发布服务(W3SVC)已经停止。除非万维网发布服务(W3SVC)正在运行,否则无法启动网站。&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="https://www.morethink.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="IIS" scheme="https://www.morethink.cn/tags/IIS/"/>
    
      <category term="ASP" scheme="https://www.morethink.cn/tags/ASP/"/>
    
  </entry>
  
  <entry>
    <title>Nginx几种负载均衡算法及配置实例</title>
    <link href="https://www.morethink.cn/Nginx-several-load-balancing-algorithm/"/>
    <id>https://www.morethink.cn/Nginx-several-load-balancing-algorithm/</id>
    <published>2018-01-04T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.184Z</updated>
    
    <content type="html"><![CDATA[<p>本文装载自： <a href="https://yq.aliyun.com/articles/114683" target="_blank" rel="noopener">https://yq.aliyun.com/articles/114683</a></p><p>Nginx负载均衡（工作在七层“应用层”）功能主要是通过upstream模块实现，Nginx负载均衡默认对后端服务器有健康检测的能力，仅限于端口检测，在后端服务器比较少的情况下负载均衡能力表现突出。</p><p>Nginx的几种负载均衡算法：<br><a id="more"></a></p><ol><li>轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，则自动剔除故障机器，使用户访问不受影响。</li><li>weight：指定轮询权重，weight值越大，分配到的几率就越高，主要用于后端每台服务器性能不均衡的情况。</li><li>ip_hash：每个请求按访问IP的哈希结果分配，这样每个访客固定访问一个后端服务器，可以有效的解决动态网页存在的session共享问题。</li><li>fair（第三方）：更智能的一个负载均衡算法，此算法可以根据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。如果想要使用此调度算法，需要Nginx的upstream_fair模块。</li><li>url_hash（第三方）：按访问URL的哈希结果来分配请求，使每个URL定向到同一台后端服务器，可以进一步提高后端缓存服务器的效率。如果想要使用此调度算法，需要Nginx的hash软件包。</li></ol><p>在upstream模块中，可以通过server命令指定后端服务器的IP地址和端口，同时还可以设置每台后端服务器在负载均衡调度中的状态，常用的状态有以下几种：</p><ol><li>down：表示当前server暂时不参与负载均衡。</li><li>backup：预留的备份机，当其他所有非backup机器出现故障或者繁忙的时候，才会请求backup机器，这台机器的访问压力最轻。</li><li>max_fails：允许请求的失败次数，默认为1，配合fail_timeout一起使用</li><li>fail_timeout：经历max_fails次失败后，暂停服务的时间，默认为10s（某个server连接失败了max_fails次，则nginx会认为该server不工作了。同时，在接下来的 fail_timeout时间内，nginx不再将请求分发给失效的server。）</li></ol><p>下面是一个负载均衡的配置示例，这里只列出http配置段，省略了其他部分配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream whsirserver &#123;</span><br><span class="line">    server 192.168.0.120:80 weight=5 max_fails=3 fail_timeout=20s;</span><br><span class="line">    server 192.168.0.121:80 weight=1 max_fails=3 fail_timeout=20s;</span><br><span class="line">    server 192.168.0.122:80 weight=3 max_fails=3 fail_timeout=20s;</span><br><span class="line">    server 192.168.0.123:80 weight=4 max_fails=3 fail_timeout=20s;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.whsir.com;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    root /data/www;</span><br><span class="line">        location / &#123;</span><br><span class="line">        proxy_pass http://whsirserver;</span><br><span class="line">        proxy_next_upstream http_500 http_502 error timeout invalid_header;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>upstream负载均衡开始，通过upstream指定了一个负载均衡器的名称为whsirserver，这个名称可以自己定义，在后面proxy_pass直接调用即可。</p><p>proxy_next_upstream参数用来定义故障转移策略，当后端服务器节点返回500、502和执行超时等错误时，自动将请求转发到upstream负载均衡器中的另一台服务器，实现故障转移。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文装载自： &lt;a href=&quot;https://yq.aliyun.com/articles/114683&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://yq.aliyun.com/articles/114683&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Nginx负载均衡（工作在七层“应用层”）功能主要是通过upstream模块实现，Nginx负载均衡默认对后端服务器有健康检测的能力，仅限于端口检测，在后端服务器比较少的情况下负载均衡能力表现突出。&lt;/p&gt;
&lt;p&gt;Nginx的几种负载均衡算法：&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="https://www.morethink.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Nginx" scheme="https://www.morethink.cn/tags/Nginx/"/>
    
      <category term="负载均衡" scheme="https://www.morethink.cn/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java解决CSRF问题</title>
    <link href="https://www.morethink.cn/Java%E8%A7%A3%E5%86%B3CSRF%E9%97%AE%E9%A2%98/"/>
    <id>https://www.morethink.cn/Java解决CSRF问题/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-04-04T06:33:50.274Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址： <a href="https://github.com/morethink/web-security-csrf" target="_blank" rel="noopener">https://github.com/morethink/web-security-csrf</a></p><h1 id="CSRF是什么？"><a href="#CSRF是什么？" class="headerlink" title="CSRF是什么？"></a>CSRF是什么？</h1><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p><h1 id="CSRF可以做什么？"><a href="#CSRF可以做什么？" class="headerlink" title="CSRF可以做什么？"></a>CSRF可以做什么？</h1><p>你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p><a id="more"></a><h1 id="CSRF的原理"><a href="#CSRF的原理" class="headerlink" title="CSRF的原理"></a>CSRF的原理</h1><p>下图简单阐述了CSRF攻击的思<br><img src="https://images.morethink.cn/138ad4f05b47533bf46904dc165167cc.png" alt=""></p><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><ol><li>登录受信任网站A，并在本地生成Cookie。</li><li>在不登出A的情况下，访问危险网站B。</li></ol><p>看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：</p><ol><li>你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</li><li>你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</li><li>上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li></ol><p>下面讲一讲java解决CSRF攻击的方式。</p><h1 id="模拟CSRF攻击"><a href="#模拟CSRF攻击" class="headerlink" title="模拟CSRF攻击"></a>模拟CSRF攻击</h1><h2 id="登录A网站"><a href="#登录A网站" class="headerlink" title="登录A网站"></a>登录A网站</h2><p>用户名和密码都是admin。</p><p><code>http://localhost:8081/login.html</code>:<br><img src="https://images.morethink.cn/e298f8ef08869557b8fb60034f06bb80.png" alt=""></p><h2 id="你有权限删除1号帖子"><a href="#你有权限删除1号帖子" class="headerlink" title="你有权限删除1号帖子"></a>你有权限删除1号帖子</h2><p><code>http://localhost:8081/deletePost.html</code>:<br><img src="https://images.morethink.cn/897d358f2677d053bb9555ff69d112ac.png" alt=""></p><h2 id="登录有CSRF攻击A网站的B网站"><a href="#登录有CSRF攻击A网站的B网站" class="headerlink" title="登录有CSRF攻击A网站的B网站"></a>登录有CSRF攻击A网站的B网站</h2><p><code>http://localhost:8082/deletePost.html</code>:</p><p><img src="https://images.morethink.cn/csrf-attack.gif" alt=""></p><p>明显看到B网站是8082端口，A网站是8081端口，但是B网站的删除2号帖子功能依然实现。</p><h1 id="预防CSRF攻击"><a href="#预防CSRF攻击" class="headerlink" title="预防CSRF攻击"></a>预防CSRF攻击</h1><p>简单来说，CSRF 就是网站 A 对用户建立信任关系后，在网站 B 上利用这种信任关系，跨站点向网站 A 发起一些伪造的用户操作请求，以达到攻击的目的。</p><p>而之所以可以完成攻击是因为B向A发起攻击的时候会把A网站的cookie带给A网站，也就是说cookie已经不安全了。</p><h2 id="通过Synchronizer-Tokens"><a href="#通过Synchronizer-Tokens" class="headerlink" title="通过Synchronizer Tokens"></a>通过Synchronizer Tokens</h2><p>Synchronizer Tokens： 在表单里隐藏一个随机变化的 csrf_token csrf_token 提交到后台进行验证，如果验证通过则可以继续执行操作。这种情况有效的主要原因是网站 B 拿不到网站 A 表单里的 csrf_token</p><p>这种方式的使用条件是PHP和JSP等。因为cookie已经不安全了，因此把csrf_token值存储在session中，然后每次表单提交时都从session取出来放到form表单的隐藏域中，这样B网站不可以得到这个存储到session中的值。</p><p>下面是JSP的：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;input type="hidden" name="random_form" value=&lt;%=random%&gt;&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure></p><p>但是我现在的情况是html，不是JSP，并不能动态的从session中取出csrf_token值。只能采用加密的方式了。</p><h2 id="Hash加密cookie中csrf-token值"><a href="#Hash加密cookie中csrf-token值" class="headerlink" title="Hash加密cookie中csrf_token值"></a>Hash加密cookie中csrf_token值</h2><p>这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了。</p><p>我采用的hash加密方法是JS实现Java的HashCode方法，得到hash值，这个比较简单。也可以采用其他的hash算法。</p><p>前端向后台传递hash之后的csrf_token值和cookie中的csrf_token值，后台拿到cookie中的csrf_token值后得到hashCode值然后与前端传过来的值进行比较，一样则通过。</p><h3 id="你有权限删除3号帖子"><a href="#你有权限删除3号帖子" class="headerlink" title="你有权限删除3号帖子"></a>你有权限删除3号帖子</h3><p><code>http://localhost:8081/deletePost.html</code></p><p><img src="https://images.morethink.cn/2ac5eab98780646c6c36dcdc98fa50c7.png" alt=""></p><h3 id="B网站的他已经没有权限了"><a href="#B网站的他已经没有权限了" class="headerlink" title="B网站的他已经没有权限了"></a>B网站的他已经没有权限了</h3><p>我们通过UserFilter.java给攻击者返回的是403错误，表示服务器理解用户客户端的请求但拒绝处理。</p><p><code>http://localhost:8082/deletePost.html</code>:<br><img src="https://images.morethink.cn/csrf-attack-fail-failure.gif" alt=""></p><p>攻击者不能删除4号帖子。</p><p>前端代码：</p><p>deletePost.html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>deletePost<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function deletePost() &#123;</span></span><br><span class="line"><span class="undefined">            var url = '/post/' + document.getElementById("postId").value;</span></span><br><span class="line"><span class="undefined">            var csrf_token = document.cookie.replace(/(?:(?:^|.*;\s*)csrf_token\s*\=\s*([^;]*).*$)|^.*$/, "$1");</span></span><br><span class="line"><span class="undefined">            console.log('csrf_token=' + csrf_token);</span></span><br><span class="line"><span class="undefined">            $.ajax(&#123;</span></span><br><span class="line"><span class="undefined">                type: "post",//请求方式</span></span><br><span class="line"><span class="undefined">                url: url,  //发送请求地址</span></span><br><span class="line"><span class="undefined">                timeout: 30000,//超时时间：30秒</span></span><br><span class="line"><span class="undefined">                data: &#123;</span></span><br><span class="line"><span class="undefined">                    "_method": "delete",</span></span><br><span class="line"><span class="undefined">                    "csrf_token": hash(csrf_token) // 对csrf_token进行hash加密</span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="undefined">                dataType: "json",//设置返回数据的格式</span></span><br><span class="line"><span class="undefined">                success: function (result) &#123;</span></span><br><span class="line"><span class="undefined">                    if (result.message == "success") &#123;</span></span><br><span class="line"><span class="undefined">//                    window.location.href = "index.html";</span></span><br><span class="line"><span class="undefined">                        $("#result").text("删除成功");</span></span><br><span class="line"><span class="undefined">                    &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                        $("#result").text("删除失败");</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="undefined">                error: function () &#123; //请求出错的处理</span></span><br><span class="line"><span class="undefined">                    $("#result").text("请求出错");</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        // javascript的String到int(32位)的hash算法</span></span><br><span class="line"><span class="undefined">        function hash(str) &#123;</span></span><br><span class="line"><span class="undefined">            var hash = 0;</span></span><br><span class="line"><span class="undefined">            if (str.length == 0) return hash;</span></span><br><span class="line"><span class="undefined">            for (i = 0; i &lt; str.length; i++) &#123;</span></span><br><span class="line"><span class="undefined">                char = str.charCodeAt(i);</span></span><br><span class="line"><span class="undefined">                hash = ((hash &lt;&lt; 5) - hash) + char;</span></span><br><span class="line"><span class="undefined">                hash = hash &amp; hash; // Convert to 32bit integer</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            return hash;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>删除帖子<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">帖子编号 ： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"postId"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"deletePost();"</span>&gt;</span>deletePost<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后台代码：</p><p>UserInterceptor.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.morethink.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.morethink.util.JsonUtil;</span><br><span class="line"><span class="keyword">import</span> cn.morethink.util.Result;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李文浩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/1/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        System.out.println(method);</span><br><span class="line">        <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">"POST"</span>) || method.equalsIgnoreCase(<span class="string">"DELETE"</span>)</span><br><span class="line">                || method.equalsIgnoreCase(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line">            String csrf_token = request.getParameter(<span class="string">"csrf_token"</span>);</span><br><span class="line">            System.out.println(csrf_token + <span class="string">"1222222222222222222222222222222222222222222222"</span>);</span><br><span class="line">            Cookie[] cookies = request.getCookies();</span><br><span class="line">            <span class="keyword">if</span> (cookies != <span class="keyword">null</span> &amp;&amp; cookies.length &gt; <span class="number">0</span> &amp;&amp; csrf_token != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cookie.getName().equals(<span class="string">"csrf_token"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (Integer.valueOf(csrf_token) == cookie.getValue().hashCode()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Result result = <span class="keyword">new</span> Result(<span class="string">"403"</span>, <span class="string">"你还想攻击我??????????"</span>, <span class="string">""</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.write(JsonUtil.toJson(result));</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>cookie必须要设置PATH才可以生效，否则在下一次请求的时候无法带给服务器。</li><li>Spring Boot 出现启动找不到主类的问题时可以mvn clean一下。</li><li>Filter设置response.sendError(403)在Spring Boot没有效果。</li></ol><p><strong>参考文档</strong>：</p><ol><li><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈CSRF攻击方式</a></li><li><a href="http://blog.csdn.net/zzhongcy/article/details/20133883" target="_blank" rel="noopener">jQueue 动态设置form表单的action属性的值和方法</a></li><li><a href="https://www.thinksaas.cn/group/topic/304242/" target="_blank" rel="noopener">javascript的String到int(32位)的hash算法</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目地址： &lt;a href=&quot;https://github.com/morethink/web-security-csrf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/morethink/web-security-csrf&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;CSRF是什么？&quot;&gt;&lt;a href=&quot;#CSRF是什么？&quot; class=&quot;headerlink&quot; title=&quot;CSRF是什么？&quot;&gt;&lt;/a&gt;CSRF是什么？&lt;/h1&gt;&lt;p&gt;CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。&lt;/p&gt;
&lt;h1 id=&quot;CSRF可以做什么？&quot;&gt;&lt;a href=&quot;#CSRF可以做什么？&quot; class=&quot;headerlink&quot; title=&quot;CSRF可以做什么？&quot;&gt;&lt;/a&gt;CSRF可以做什么？&lt;/h1&gt;&lt;p&gt;你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。&lt;/p&gt;
    
    </summary>
    
      <category term="Web安全" scheme="https://www.morethink.cn/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="CSRF" scheme="https://www.morethink.cn/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>Nginx Https配置不带www跳转www</title>
    <link href="https://www.morethink.cn/Nginx-Https-no-www-jump-www/"/>
    <id>https://www.morethink.cn/Nginx-Https-no-www-jump-www/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.183Z</updated>
    
    <content type="html"><![CDATA[<p>把 morethink.cn和<a href="http://www.morethink.cn合并到一个server上去，使用301永久重定向。" target="_blank" rel="noopener">www.morethink.cn合并到一个server上去，使用301永久重定向。</a><br>然后将 <a href="https://morethink.cn" target="_blank" rel="noopener">https://morethink.cn</a> 转到 <a href="https://www.morethink.cn">https://www.morethink.cn</a> 去。不过要在配置文件的 <code>server</code> <a href="https://www.morethink.cn">https://www.morethink.cn</a><br>上配置default_server ssl;。<br>301永久重定向可以把搜索引擎的权重全部集中到 <a href="https://www.morethink.cn">https://www.morethink.cn</a> 上。</p><a id="more"></a><p>配置如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name morethink.cn,www.morethink.cn;</span><br><span class="line">    return 301 https://www.morethink.cn$request_uri;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name morethink.cn;</span><br><span class="line">    return 301 https://www.morethink.cn$request_uri;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 default_server ssl;</span><br><span class="line">    server_name  www.morethink.cn;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate 1_www.morethink.cn_bundle.crt;</span><br><span class="line">    ssl_certificate_key 2_www.morethink.cn.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    root         /var/www/hexo;</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">        location = /40x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考文档</strong>：</p><ol><li><a href="https://cloud.tencent.com/document/product/400/4143" target="_blank" rel="noopener">腾讯云 Nginx Https 证书安装指引</a></li><li><a href="https://docs.lvrui.io/2017/04/01/nginx%E9%85%8D%E7%BD%AEhttp%E5%BC%BA%E5%88%B6%E8%B7%B3%E8%BD%AChttps/" target="_blank" rel="noopener">nginx配置http强制跳转https</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把 morethink.cn和&lt;a href=&quot;http://www.morethink.cn合并到一个server上去，使用301永久重定向。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.morethink.cn合并到一个server上去，使用301永久重定向。&lt;/a&gt;&lt;br&gt;然后将 &lt;a href=&quot;https://morethink.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://morethink.cn&lt;/a&gt; 转到 &lt;a href=&quot;https://www.morethink.cn&quot;&gt;https://www.morethink.cn&lt;/a&gt; 去。不过要在配置文件的 &lt;code&gt;server&lt;/code&gt; &lt;a href=&quot;https://www.morethink.cn&quot;&gt;https://www.morethink.cn&lt;/a&gt;&lt;br&gt;上配置default_server ssl;。&lt;br&gt;301永久重定向可以把搜索引擎的权重全部集中到 &lt;a href=&quot;https://www.morethink.cn&quot;&gt;https://www.morethink.cn&lt;/a&gt; 上。&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="https://www.morethink.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Https" scheme="https://www.morethink.cn/tags/Https/"/>
    
      <category term="Nginx" scheme="https://www.morethink.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>面试中的Https</title>
    <link href="https://www.morethink.cn/Https/"/>
    <id>https://www.morethink.cn/Https/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.179Z</updated>
    
    <content type="html"><![CDATA[<p>在Http协议中有可能存在信息窃听或身份伪装的安全问题。使用HTTPS通信机制可以有效地防止这些问题。</p><h1 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h1><h2 id="Http的缺点"><a href="#Http的缺点" class="headerlink" title="Http的缺点"></a>Http的缺点</h2><ul><li>通信使用明文(不加密)，内容可能会被窃听。</li><li>不验证通信方的身份，因此有可能遭遇伪装。</li><li>无法验证报文的完整性，所以有可能已遭篡改。</li></ul><p>这些问题不仅在Http上出现，其他未加密的协议中也会存在这类问题。</p><a id="more"></a><h2 id="什么是Https"><a href="#什么是Https" class="headerlink" title="什么是Https"></a>什么是Https</h2><p>Https并非是应用层的一种新的协议。只是Http通信接口部分用SSL(Secure Socket Layer)和TLS(Transport Layer Security)协议而已。</p><p>通常，Http直接和TCP通信。当使用SSL时，则演变成先和SSL协议通信，再由SSL和TCP通信了。简言之，所谓Https，就是身披SSL这层协议外壳的Http。</p><p><img src="https://images.morethink.cn/0163388a23291dcc361c869f6f8ebc86.png" alt="" title="什么是Https"></p><h2 id="Https有什么作用"><a href="#Https有什么作用" class="headerlink" title="Https有什么作用"></a>Https有什么作用</h2><p><code>Http+加密+认证+完整性保护 = Https</code></p><p>Https有以下作用：</p><ul><li><strong>内容加密</strong> 建立一个信息安全通道，来保证数据传输的安全。</li><li><strong>身份认证</strong> 确认网站的真实性。</li><li><strong>数据完整性</strong> 防止内容被第三方冒充或者篡改。</li></ul><p>下面就是Https的整个架构，现在的https基本都使用TLS了，因为更加安全。</p><h1 id="Https-加密"><a href="#Https-加密" class="headerlink" title="Https 加密"></a>Https 加密</h1><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，<strong>加密密钥和解密密钥是相同的</strong>，所以也称这种加密算法为秘密密钥算法或单密钥算法。</p><p>但是我们使用对称加密加密Http通信内容会有一个问题，因为客户端和服务器在通信过程中都必须知道秘钥，而在发送秘钥的过程中又有可能被第三方监听，从而获取到秘钥。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密很好地解决了对称加密的困难。</p><p>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey），并且加密密钥和解密密钥是成对出现的。非对称加密算法在加密和解密过程使用了不同的密钥，非对称加密也称为公钥加密，在密钥对中，其中一个密钥是对外公开的，所有人都可以获取到，称为公钥，其中一个密钥是不公开的称为私钥。 <strong>用公钥加密的只能用私钥解开，用私钥加密的只能用公钥解开</strong>。</p><p>非对称加密的特性决定了服务器用私钥加密的内容并不是真正的加密，因为公钥所有人都有，所以服务器的密文能被所有人解析。但私钥只掌握在服务器手上，这就带来了两个巨大的优势:</p><ol><li>服务器下发的内容不可能被伪造，因为别人都没有私钥，所以无法加密。强行加密的后果是客户端用公钥无法解开。</li><li>任何人用公钥加密的内容都是绝对安全的，因为私钥只有服务器有，也就是只有真正的服务器可以看到被加密的原文。</li></ol><p><strong>注意</strong>：<br>想要根据密文和公钥，恢复信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。</p><p>因此，Https采用对称加密和非对称加密两者并用的混合加密机制。</p><p><strong>也就是说，Https通过非对称加密来传递对称加密的秘钥</strong>。</p><p>那为什么不直接采用非对称加密来加密通信内容？</p><p>非对称加密处理起来比对称加密更为复杂，因此若在通信时使用非对称加密，效率比较低。</p><h2 id="证书的私钥加密公钥"><a href="#证书的私钥加密公钥" class="headerlink" title="证书的私钥加密公钥"></a>证书的私钥加密公钥</h2><p>遗憾的是，非对称加密还是存在一些问题的。那就是无法保证公钥本身就是货真价实的公钥。比如，正准备和某台服务器建立非对称加密下的通信时，如何证明收到的公钥就是原来预想的那台服务器发行的公钥。或许在公开秘钥传输过程中，真正的公钥已经被人替换了。</p><p>那怎么办？<br>再加密一次。</p><p><strong>每一个使用 HTTPS 的服务器都必须去专门的证书机构注册一个证书，证书中存储了用数字证书机构私钥加密的公钥。这样客户端用数字证书机构的公钥解密就可以了</strong>。</p><p>而数字证书机构的公钥会直接内置在各大操作系统(或者浏览器)的出厂设置里。所以各个公司要先去数字证书机构认证，申请证书，然后操作系统只会存储数字证书机构的公钥。因为数字证书机构数量有限，所以操作系统厂商相对来说容易管理。</p><p><strong>总结</strong>：<br>Https通过非对称加密(通常是RSA算法)加密对称加密的秘钥，然后使用证书机构的私钥加密非对称加密的公钥，而证书机构的公钥会内置在浏览器里，从而保证即使被第三方监听，也可以保证安全。</p><h1 id="SSL-与-TLS"><a href="#SSL-与-TLS" class="headerlink" title="SSL 与 TLS"></a>SSL 与 TLS</h1><h2 id="SSL-Secure-Socket-Layer，安全套接字层"><a href="#SSL-Secure-Socket-Layer，安全套接字层" class="headerlink" title="SSL (Secure Socket Layer，安全套接字层)"></a>SSL (Secure Socket Layer，安全套接字层)</h2><p>SSL为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取，当前为3.0版本。</p><p>SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p><h2 id="TLS-Transport-Layer-Security，传输层安全协议"><a href="#TLS-Transport-Layer-Security，传输层安全协议" class="headerlink" title="TLS (Transport Layer Security，传输层安全协议)"></a>TLS (Transport Layer Security，传输层安全协议)</h2><p>用于两个应用程序之间提供保密性和数据完整性。<br>TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</p><h2 id="SSL-TLS协议作用"><a href="#SSL-TLS协议作用" class="headerlink" title="SSL/TLS协议作用"></a>SSL/TLS协议作用</h2><ul><li>认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>加密数据以防止数据中途被窃取；</li><li>维护数据的完整性，确保数据在传输过程中不被改变。</li></ul><h2 id="TLS比SSL的优势"><a href="#TLS比SSL的优势" class="headerlink" title="TLS比SSL的优势"></a>TLS比SSL的优势</h2><ol><li>对于消息认证使用密钥散列法：TLS 使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC 功能更安全。</li><li>增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。</li><li>改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。</li><li>一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。</li><li>特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。</li></ol><h1 id="SSL-TLS的握手过程"><a href="#SSL-TLS的握手过程" class="headerlink" title="SSL/TLS的握手过程"></a>SSL/TLS的握手过程</h1><p>SSL与TLS握手整个过程如下图所示，下面会详细介绍每一步的具体内容：</p><p><img src="https://images.morethink.cn/ea844ad80d80956a30095d5e4f39fd7b.png" alt="" title="https握手流程图"></p><h2 id="客户端首次发出请求"><a href="#客户端首次发出请求" class="headerlink" title="客户端首次发出请求"></a>客户端首次发出请求</h2><p>由于客户端(如浏览器)对一些加解密算法的支持程度不一样，但是在TLS协议传输过程中必须使用同一套加解密算法才能保证数据能够正常的加解密。在TLS握手阶段，客户端首先要告知服务端，自己支持哪些加密算法，所以客户端需要将本地支持的加密套件(Cipher Suite)的列表传送给服务端。除此之外，客户端还要产生一个随机数，这个随机数一方面需要在客户端保存，另一方面需要传送给服务端，客户端的随机数需要跟服务端产生的随机数结合起来产生后面要讲到的 Master Secret 。</p><p><strong>客户端需要提供如下信息</strong>：</p><ul><li>支持的协议版本，比如TLS 1.0版</li><li>一个客户端生成的随机数，稍后用于生成”对话密钥”</li><li>支持的加密方法，比如RSA公钥加密</li><li>支持的压缩方法</li></ul><h2 id="服务端首次回应"><a href="#服务端首次回应" class="headerlink" title="服务端首次回应"></a>服务端首次回应</h2><p>服务端在接收到客户端的Client Hello之后，服务端需要确定加密协议的版本，以及加密的算法，然后也生成一个随机数，以及将自己的证书发送给客户端一并发送给客户端，这里的随机数是整个过程的第二个随机数。</p><p><strong>服务端需要提供的信息</strong>：</p><ul><li>协议的版本</li><li>加密的算法</li><li>随机数</li><li>服务器证书</li></ul><h2 id="客户端再次回应"><a href="#客户端再次回应" class="headerlink" title="客户端再次回应"></a>客户端再次回应</h2><p>客户端首先会对服务器下发的证书进行验证，验证通过之后，则会继续下面的操作，客户端再次产生一个随机数（第三个随机数），然后使用服务器证书中的公钥进行加密，以及放一个ChangeCipherSpec消息即编码改变的消息，还有整个前面所有消息的hash值，进行服务器验证，然后用新秘钥加密一段数据一并发送到服务器，确保正式通信前无误。</p><p>客户端使用前面的两个随机数以及刚刚新生成的新随机数，使用与服务器确定的加密算法，生成一个Session Secret。</p><h2 id="服务器再次响应"><a href="#服务器再次响应" class="headerlink" title="服务器再次响应"></a>服务器再次响应</h2><p>服务端在接收到客户端传过来的第三个随机数的 加密数据之后，使用私钥对这段加密数据进行解密，并对数据进行验证，也会使用跟客户端同样的方式生成秘钥，一切准备好之后，也会给客户端发送一个 ChangeCipherSpec，告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和 Session Secret加密数据了。之后，服务端也会使用 Session Secret 加密一段 Finish 消息发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。</p><h2 id="后续客户端与服务器间通信"><a href="#后续客户端与服务器间通信" class="headerlink" title="后续客户端与服务器间通信"></a>后续客户端与服务器间通信</h2><p>确定秘钥之后，服务器与客户端之间就会通过商定的秘钥加密消息了，进行通讯了。整个握手过程也就基本完成了。</p><blockquote><p><strong>值得特别提出的是</strong>：</p><p>SSL协议在握手阶段使用的是非对称加密，在传输阶段使用的是对称加密，也就是说在SSL上传送的数据是使用对称密钥加密的！因为非对称加密的速度缓慢，耗费资源。其实当客户端和主机使用非对称加密方式建立连接后，客户端和主机已经决定好了在传输过程使用的对称加密算法和关键的对称加密密钥，由于这个过程本身是安全可靠的，也即对称加密密钥是不可能被窃取盗用的，因此，保证了在传输过程中对数据进行对称加密也是安全可靠的，因为除了客户端和主机之外，不可能有第三方窃取并解密出对称加密密钥！如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。</p></blockquote><h1 id="session的恢复"><a href="#session的恢复" class="headerlink" title="session的恢复"></a>session的恢复</h1><p>有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。</p><h2 id="session-ID"><a href="#session-ID" class="headerlink" title="session ID"></a>session ID</h2><p>session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的”对话密钥”，而不必重新生成一把。</p><p>session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。</p><h2 id="session-ticket"><a href="#session-ticket" class="headerlink" title="session ticket"></a>session ticket</h2><p>客户端发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。</p><p><strong>目前只有Firefox和Chrome浏览器支持</strong>。</p><h1 id="Https的劣势"><a href="#Https的劣势" class="headerlink" title="Https的劣势"></a>Https的劣势</h1><p><strong>对数据进行加解密决定了它比http慢</strong>。需要进行非对称的加解密，且需要三次握手。首次连接比较慢点，当然现在也有很多的优化。</p><p>出于安全考虑，浏览器不会在本地保存HTTPS缓存。实际上，只要在HTTP头中使用特定命令，HTTPS是可以缓存的。Firefox默认只在内存中缓存HTTPS。但是，只要头命令中有Cache-Control: Public，缓存就会被写到硬盘上。 IE只要http头允许就可以缓存https内容，缓存策略与是否使用HTTPS协议无关。</p><h1 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h1><ul><li>https协议需要到CA申请证书。</li><li>http是超文本传输协议，信息是明文传输；https 则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li><li>http默认使用80端口，https默认使用443端口</li></ul><h1 id="Python等爬虫怎么处理Https"><a href="#Python等爬虫怎么处理Https" class="headerlink" title="Python等爬虫怎么处理Https"></a>Python等爬虫怎么处理Https</h1><p>https拿爬虫毫无办法，或者说https就不是为了反爬虫的。https的作用是保证服务源授信。比如你访问支付宝，网络被劫持了，你看到的就是个假网站，一旦你登录，账号就泄露了。但用https就能保证你访问的一定是真的支付宝网站，这是由CA证书保证的。回过来再说爬虫，爬虫伪造的是客户端，https是不能保证客户端是授信的，你只要按照ssl协议进行通信，该怎么爬数据还是怎么爬。</p><p>https协议里数据的传输是需要经过加密的,在这个过程中，就给爬虫带来了抓包问题，抓出来的数据也是经过加密的，不能解析。</p><p>理论上是不行了，因为https保证的就是数据在传输过程中不会被盗取。但解决起来也很简单，就是设置个代理伪装一下，代价就是你要安装个假证书，当然这也肯定是无所谓的。</p><p><strong>参考文档</strong>：</p><ol><li><a href="http://www.wxtlife.com/2016/03/27/详解https是如何确保安全的？/" target="_blank" rel="noopener">详解https是如何确保安全的？</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></li><li><a href="http://fullstack.blog/2017/03/12/%E4%B9%9D%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E6%82%89HTTPS/#" target="_blank" rel="noopener">九个问题从入门到熟悉HTTPS</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></li><li><a href="https://www.zhihu.com/question/54504923" target="_blank" rel="noopener">爬虫 https python？</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Http协议中有可能存在信息窃听或身份伪装的安全问题。使用HTTPS通信机制可以有效地防止这些问题。&lt;/p&gt;
&lt;h1 id=&quot;Https&quot;&gt;&lt;a href=&quot;#Https&quot; class=&quot;headerlink&quot; title=&quot;Https&quot;&gt;&lt;/a&gt;Https&lt;/h1&gt;&lt;h2 id=&quot;Http的缺点&quot;&gt;&lt;a href=&quot;#Http的缺点&quot; class=&quot;headerlink&quot; title=&quot;Http的缺点&quot;&gt;&lt;/a&gt;Http的缺点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通信使用明文(不加密)，内容可能会被窃听。&lt;/li&gt;
&lt;li&gt;不验证通信方的身份，因此有可能遭遇伪装。&lt;/li&gt;
&lt;li&gt;无法验证报文的完整性，所以有可能已遭篡改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些问题不仅在Http上出现，其他未加密的协议中也会存在这类问题。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="https://www.morethink.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Https" scheme="https://www.morethink.cn/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>面试中的DNS</title>
    <link href="https://www.morethink.cn/DNS/"/>
    <id>https://www.morethink.cn/DNS/</id>
    <published>2017-12-25T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。</p><p>DNS基于UDP服务，端口53。该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。</p><a id="more"></a><h1 id="递归查询与迭代查询"><a href="#递归查询与迭代查询" class="headerlink" title="递归查询与迭代查询"></a>递归查询与迭代查询</h1><h2 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h2><p>递归查询是一种DNS 服务器的查询模式，在该模式下DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS 服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。</p><p><img src="https://images.morethink.cn/af0045f9f3bdd144a2afc434cb8146f7.png" alt="" title="DNS递归查询"></p><h2 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h2><p>DNS 服务器另外一种查询方式为迭代查询，DNS 服务器会向客户机提供其他能够解析查询请求的DNS 服务器地址，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台DNS 服务器地址，客户机再向这台DNS 服务器提交请求，依次循环直到返回查询的结果为止。<br><img src="https://images.morethink.cn/9550ed36f993d88f2d54e5d9c6c9f487.png" alt="" title="DNS迭代查询"></p><p><strong>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询</strong>。</p><h1 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h1><p>DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。</p><p>DNS劫持症状：在某些地区的用户在成功连接宽带后，首次打开任何页面都指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。</p><p><strong>解决方法</strong></p><p>对于DNS劫持，可以采用使用国外免费公用的DNS服务器解决。例如OpenDNS（208.67.222.222）或GoogleDNS（8.8.8.8）。</p><p><strong>总结</strong></p><p>DNS劫持就是指用户访问一个被标记的地址时，DNS服务器故意将此地址指向一个错误的IP地址的行为。范例，网通、电信、铁通的某些用户有时候会发现自己打算访问一个地址，却被转向了各种推送广告等网站，这就是DNS劫持。</p><h1 id="DNS污染"><a href="#DNS污染" class="headerlink" title="DNS污染"></a>DNS污染</h1><p>DNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。</p><p>其工作方式是：由于通常的DNS查询没有任何认证机制，而且DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改，通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。</p><p>DNS污染发生在用户请求的第一步上，直接从协议上对用户的DNS请求进行干扰。<br>DNS污染症状：目前一些被禁止访问的网站很多就是通过DNS污染来实现的，例如YouTube、Facebook等网站。</p><p><strong>解决办法</strong>：</p><p>对于DNS污染，可以说，个人用户很难单单靠设置解决，通常可以使用VPN或者域名远程解析的方法解决，但这大多需要购买付费的VPN或SSH等，也可以通过修改Hosts的方法，手动设置域名正确的IP地址。</p><p><strong>总结</strong>：</p><p>DNS污染，指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。范例，访问Youtube、Facebook之类网站等出现的状况。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DNS&quot;&gt;&lt;a href=&quot;#DNS&quot; class=&quot;headerlink&quot; title=&quot;DNS&quot;&gt;&lt;/a&gt;DNS&lt;/h1&gt;&lt;p&gt;当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。&lt;/p&gt;
&lt;p&gt;DNS基于UDP服务，端口53。该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="https://www.morethink.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Java使用Openoffice将word、ppt转换为PDF</title>
    <link href="https://www.morethink.cn/Java-openoffice-pdf/"/>
    <id>https://www.morethink.cn/Java-openoffice-pdf/</id>
    <published>2017-12-24T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.180Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目中要实现WORD的文件预览功能，我们可以通过将WORD转换成PDF或者HTML，然后通过浏览器预览。</p><h1 id="OpenOffice"><a href="#OpenOffice" class="headerlink" title="OpenOffice"></a>OpenOffice</h1><p>OpenOffice.org 是一套跨平台的办公室软件套件，能在 Windows、Linux、MacOS X (X11)、和 Solaris 等操作系统上执行。它与各个主要的办公室软件套件兼容。OpenOffice.org 是自由软件，任何人都可以免费下载、使用、及推广它。</p><a id="more"></a><p><strong>下载地址</strong></p><p><a href="http://www.openoffice.org/" target="_blank" rel="noopener">http://www.openoffice.org/</a></p><h1 id="JodConverter"><a href="#JodConverter" class="headerlink" title="JodConverter"></a>JodConverter</h1><p>jodconverter-2.2.2.zip 下载地址：<br><a href="http://sourceforge.net/projects/jodconverter/files/JODConverter/" target="_blank" rel="noopener">http://sourceforge.net/projects/jodconverter/files/JODConverter/</a></p><h1 id="Word转换"><a href="#Word转换" class="headerlink" title="Word转换"></a>Word转换</h1><p><strong>启动OpenOffice的服务</strong></p><p>进入openoffice安装目录，通过cmd启动一个soffice服务，启动的命令是<code>soffice -headless -accept=&quot;socket,host=127.0.0.1,port=8100;urp;&quot;</code>。</p><p>如果觉得后台运行OpenOffice服务比较麻烦，可以通过</p><h1 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PDFDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">officeToPDF</span><span class="params">(String sourceFile, String destFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            File inputFile = <span class="keyword">new</span> File(sourceFile);</span><br><span class="line">            <span class="keyword">if</span> (!inputFile.exists()) &#123;</span><br><span class="line">                <span class="comment">// 找不到源文件, 则返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果目标路径不存在, 则新建该路径</span></span><br><span class="line">            File outputFile = <span class="keyword">new</span> File(destFile);</span><br><span class="line">            <span class="keyword">if</span> (!outputFile.getParentFile().exists()) &#123;</span><br><span class="line">                outputFile.getParentFile().mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果目标文件存在，则删除</span></span><br><span class="line">            <span class="keyword">if</span> (outputFile.exists()) &#123;</span><br><span class="line">                outputFile.delete();</span><br><span class="line">            &#125;</span><br><span class="line">            DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm"</span>);</span><br><span class="line">            OpenOfficeConnection connection = <span class="keyword">new</span> SocketOpenOfficeConnection(<span class="string">"127.0.0.1"</span>, <span class="number">8100</span>);</span><br><span class="line">            connection.connect();</span><br><span class="line">            <span class="comment">//用于测试openOffice连接时间</span></span><br><span class="line">            System.out.println(<span class="string">"连接时间:"</span> + df.format(<span class="keyword">new</span> Date()));</span><br><span class="line">            DocumentConverter converter = <span class="keyword">new</span> StreamOpenOfficeDocumentConverter(</span><br><span class="line">                    connection);</span><br><span class="line">            converter.convert(inputFile, outputFile);</span><br><span class="line">            <span class="comment">//测试word转PDF的转换时间</span></span><br><span class="line">            System.out.println(<span class="string">"转换时间:"</span> + df.format(<span class="keyword">new</span> Date()));</span><br><span class="line">            connection.disconnect();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ConnectException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.err.println(<span class="string">"openOffice连接失败！请检查IP,端口"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        officeToPDF(<span class="string">"E:\\test.docx"</span>, <span class="string">"E:\\test.pdf"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Word、ppt转Html"><a href="#Word、ppt转Html" class="headerlink" title="Word、ppt转Html"></a>Word、ppt转Html</h1><p>只需要将后缀名从<code>.pdf</code>改为<code>.html</code>即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    officeToPDF(<span class="string">"E:\\test.docx"</span>, <span class="string">"E:\\test.html"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h1><p><strong>Maven依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.artofsolving<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jodconverter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openoffice<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jurt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openoffice<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ridl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openoffice<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>juh<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openoffice<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>unoil<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-jdk14<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Maven只有 2.2.1版本，2.2.1版本有一个问题，那就是不兼容docx和pptx，如果你们不使用jodconverter-2.2.2 中lib，而想要使用2.2.1版本，需要修改一下 <code>BasicDocumentFormatRegistry</code> 类中的 <code>getFormatByFileExtension</code>方法：</p><ol><li>新建包 <code>com.artofsolving.jodconverter</code></li><li>新建类<code>BasicDocumentFormatRegistry</code>，复制下面代码</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.artofsolving.jodconverter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李文浩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/12/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicDocumentFormatRegistry</span> <span class="keyword">implements</span> <span class="title">DocumentFormatRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List documentFormats = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicDocumentFormatRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDocumentFormat</span><span class="params">(DocumentFormat documentFormat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.documentFormats.add(documentFormat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List <span class="title">getDocumentFormats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.documentFormats;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DocumentFormat <span class="title">getFormatByFileExtension</span><span class="params">(String extension)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (extension == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extension.indexOf(<span class="string">"doc"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                extension = <span class="string">"doc"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (extension.indexOf(<span class="string">"ppt"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                extension = <span class="string">"ppt"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (extension.indexOf(<span class="string">"xls"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                extension = <span class="string">"xls"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String lowerExtension = extension.toLowerCase();</span><br><span class="line">            Iterator it = <span class="keyword">this</span>.documentFormats.iterator();</span><br><span class="line"></span><br><span class="line">            DocumentFormat format;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!it.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                format = (DocumentFormat)it.next();</span><br><span class="line">            &#125; <span class="keyword">while</span>(!format.getFileExtension().equals(lowerExtension));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> format;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DocumentFormat <span class="title">getFormatByMimeType</span><span class="params">(String mimeType)</span> </span>&#123;</span><br><span class="line">        Iterator it = <span class="keyword">this</span>.documentFormats.iterator();</span><br><span class="line"></span><br><span class="line">        DocumentFormat format;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!it.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            format = (DocumentFormat)it.next();</span><br><span class="line">        &#125; <span class="keyword">while</span>(!format.getMimeType().equals(mimeType));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> format;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是增加的部分，仅仅增加了将docx按照doc的处理方式处理。而2.2.2版本已经默认增加了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (extension.indexOf(<span class="string">"doc"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    extension = <span class="string">"doc"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (extension.indexOf(<span class="string">"ppt"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    extension = <span class="string">"ppt"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (extension.indexOf(<span class="string">"xls"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    extension = <span class="string">"xls"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考文档</strong>：</p><ol><li><a href="http://blog.csdn.net/yjclsx/article/details/51445546" target="_blank" rel="noopener">Java实现在线预览–openOffice实现</a></li><li><a href="http://blog.csdn.net/qq_33571718/article/details/51154472" target="_blank" rel="noopener">Java项目中使用OpenOffice转PDF</a></li><li><a href="http://blog.csdn.net/make_a_difference/article/details/53771136###;" target="_blank" rel="noopener">java使用openoffice将office系列文档转换为PDF</a></li><li><a href="http://www.cnblogs.com/xxyfhjl/p/6773786.html" target="_blank" rel="noopener">java 如何将 word,excel,ppt如何转pdf–jacob</a></li><li><a href="http://www.cnblogs.com/xxyfhjl/p/6775137.html" target="_blank" rel="noopener">java 如何将 word,excel,ppt如何转pdf –openoffice (1)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近项目中要实现WORD的文件预览功能，我们可以通过将WORD转换成PDF或者HTML，然后通过浏览器预览。&lt;/p&gt;
&lt;h1 id=&quot;OpenOffice&quot;&gt;&lt;a href=&quot;#OpenOffice&quot; class=&quot;headerlink&quot; title=&quot;OpenOffice&quot;&gt;&lt;/a&gt;OpenOffice&lt;/h1&gt;&lt;p&gt;OpenOffice.org 是一套跨平台的办公室软件套件，能在 Windows、Linux、MacOS X (X11)、和 Solaris 等操作系统上执行。它与各个主要的办公室软件套件兼容。OpenOffice.org 是自由软件，任何人都可以免费下载、使用、及推广它。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.morethink.cn/categories/Java/"/>
    
    
      <category term="PDF" scheme="https://www.morethink.cn/tags/PDF/"/>
    
  </entry>
  
</feed>
