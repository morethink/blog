<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>More Think</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.morethink.cn/"/>
  <updated>2018-04-01T09:29:00.106Z</updated>
  <id>https://www.morethink.cn/</id>
  
  <author>
    <name>李文浩</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树从右边看到的节点</title>
    <link href="https://www.morethink.cn/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%8E%E5%8F%B3%E8%BE%B9%E7%9C%8B%E5%88%B0%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://www.morethink.cn/二叉树从右边看到的节点/</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2018-04-01T09:29:00.106Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 LeetCode <a href="https://leetcode.com/problems/binary-tree-right-side-view/description/" target="_blank" rel="noopener">Binary Tree Right Side View</a> 解法的探讨。</p><p>题目：<br>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.<br><a id="more"></a><br>For example:<br>Given the following binary tree,<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure></p><p>You should return [1, 3, 4].</p><p>解法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为题目的二叉树并不是满二叉树，所以采用层序遍历的方式。</span></span><br><span class="line"><span class="comment"> * 将以前层序遍历中一个个出队的方式变为一层层出队，</span></span><br><span class="line"><span class="comment"> * 这样就能定位最右边的节点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="comment">//将每一层的节点都出队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode treeNode = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(treeNode.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(treeNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(treeNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 LeetCode &lt;a href=&quot;https://leetcode.com/problems/binary-tree-right-side-view/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Binary Tree Right Side View&lt;/a&gt; 解法的探讨。&lt;/p&gt;
&lt;p&gt;题目：&lt;br&gt;Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.morethink.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://www.morethink.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>求小于n的素数个数</title>
    <link href="https://www.morethink.cn/%E6%B1%82%E5%B0%8F%E4%BA%8En%E7%9A%84%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0/"/>
    <id>https://www.morethink.cn/求小于n的素数个数/</id>
    <published>2018-03-10T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.192Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 LeetCode <a href="https://leetcode.com/problems/count-primes/description/" target="_blank" rel="noopener">Count Primes</a> 解法的探讨。</p><p>题目：<br>Count the number of prime numbers less than a non-negative number, n.</p><p>尽管题目并没有要我们写一个最优的算法，但是身为一个程序员，优化应该是一种习惯，在编程的过程中，随着思考进行优化。只要求我们满足给定的时间和空间即可。</p><p>如果你只能想出一个最简单的方法，难道你会有什么竞争力吗？</p><a id="more"></a><h1 id="穷举"><a href="#穷举" class="headerlink" title="穷举"></a>穷举</h1><p>最开始我用的就是这个方法，可以说这是最简单的一种方法了，而且最开始，我就是想的这种方法，说明：我没有对这个问题进行思考，没有去优化它，而作为一个程序员，如何提高效率是拿到一个问题首先要思考的事情。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i - <span class="number">1</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取开始时</span></span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"The num is "</span> + <span class="keyword">new</span> L_204_Count_Primes().countPrimes(<span class="number">2000000</span>));</span><br><span class="line">    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//获取结束时间</span></span><br><span class="line">    System.out.println(<span class="string">"程序运行时间： "</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间太长，已经不能计算。</p></blockquote><h1 id="只能是奇数且小于-sqrt-n"><a href="#只能是奇数且小于-sqrt-n" class="headerlink" title="只能是奇数且小于$\sqrt{n}$"></a>只能是奇数且小于$\sqrt{n}$</h1><p>思考后发现</p><ol><li>素数一定是奇数</li><li>若 n=ab 是个合数（其中 a 与 b ≠ 1）, 则其中一个约数 a 或 b 必定至大为  $\sqrt{n}$.</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= (<span class="keyword">int</span>) Math.sqrt(i); j++)</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The num is 148933<br>程序运行时间： 1124ms</p></blockquote><h1 id="试除法：数学知识的运用"><a href="#试除法：数学知识的运用" class="headerlink" title="试除法：数学知识的运用"></a>试除法：数学知识的运用</h1><p>查阅 <a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">算术基本定理</a>可知：</p><blockquote><p><strong>算术基本定理</strong> :<br>每个大于1的整数均可写成一个以上的素数之乘积，且除了质约数的排序不同外是唯一的</p></blockquote><p>也就是说我们可以每个数来除以得到的素数，这样可大大减少运行次数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0 1 不算做素数,2一定是素数</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.size() &amp;&amp; list.get(j) &lt;= (<span class="keyword">int</span>) Math.sqrt(n); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % list.get(j) == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The num is 148933<br>程序运行时间： 383ms</p></blockquote><h1 id="筛选法"><a href="#筛选法" class="headerlink" title="筛选法"></a>筛选法</h1><blockquote><p>埃拉托斯特尼筛法，简称埃氏筛，也有人称素数筛。这是一种简单且历史悠久的筛法，用来找出一定范围内所有的素数。</p><p>所使用的原理是从2开始，将每个素数的各个倍数，标记成合数。一个素数的各个倍数，是一个差为此素数本身的等差数列。此为这个筛法和试除法不同的关键之处，后者是以素数来测试每个待测数能否被整除。</p></blockquote><p>筛选法的策略是将素数的倍数全部筛掉，剩下的就是素数了，下图很生动的体现了筛选的过程：</p><p><img src="https://images.morethink.cn/dcp5x843_338cbm3tmg7_b.gif" alt="" title="筛选法"></p><p>筛选的过程是先筛掉非素数，针对本文的题目，每筛掉一个，素数数量-1即可，上面说过素数的一个特点，除了2，其它的素数都是奇数，所以我们只需在奇数范围内筛选就可以了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes4</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//false代表素数，true代表非素数</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="comment">//0不是素数</span></span><br><span class="line">    flags[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//1不是素数</span></span><br><span class="line">    flags[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> num = n - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= (<span class="keyword">int</span>) Math.sqrt(n); i++) &#123;</span><br><span class="line">        <span class="comment">//当i为素数时，i的所有倍数都不是素数</span></span><br><span class="line">        <span class="keyword">if</span> (!flags[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!flags[j]) &#123;</span><br><span class="line">                    flags[j] = <span class="keyword">true</span>;</span><br><span class="line">                    num--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The num is 148933<br>程序运行时间： 43ms</p></blockquote><p>全部代码放在：<br> <a href="https://github.com/morethink/algorithm/blob/master/src/algorithm/leetcode/L_204_Count_Primes.java" target="_blank" rel="noopener">https://github.com/morethink/algorithm/blob/master/src/algorithm/leetcode/L_204_Count_Primes.java</a></p><p><strong>参考文档</strong>：</p><ol><li><a href="https://program-think.blogspot.com/2011/12/prime-algorithm-1.html" target="_blank" rel="noopener">求质数算法的N种境界[1] - 试除法和初级筛法</a></li><li><a href="http://blog.csdn.net/ghsau/article/details/78768157" target="_blank" rel="noopener"> 求素数个数</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95" target="_blank" rel="noopener">埃拉托斯特尼筛法</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 LeetCode &lt;a href=&quot;https://leetcode.com/problems/count-primes/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Count Primes&lt;/a&gt; 解法的探讨。&lt;/p&gt;
&lt;p&gt;题目：&lt;br&gt;Count the number of prime numbers less than a non-negative number, n.&lt;/p&gt;
&lt;p&gt;尽管题目并没有要我们写一个最优的算法，但是身为一个程序员，优化应该是一种习惯，在编程的过程中，随着思考进行优化。只要求我们满足给定的时间和空间即可。&lt;/p&gt;
&lt;p&gt;如果你只能想出一个最简单的方法，难道你会有什么竞争力吗？&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.morethink.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="素数" scheme="https://www.morethink.cn/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java实现单链表的快速排序和归并排序</title>
    <link href="https://www.morethink.cn/Java%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.morethink.cn/Java实现单链表的快速排序和归并排序/</id>
    <published>2018-02-17T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.182Z</updated>
    
    <content type="html"><![CDATA[<p>本文描述了LeetCode 148题 <a href="https://leetcode.com/problems/sort-list/description/" target="_blank" rel="noopener">sort-list</a> 的解法。</p><p>题目描述如下:<br>Sort a linked list in O(n log n) time using constant space complexity.</p><p>题目要求我们在O(n log n)时间复杂度下完成对单链表的排序，我们知道平均时间复杂度为O(n log n)的排序方法有快速排序、归并排序和堆排序。而一般是用数组来实现二叉堆，当然可以用二叉树来实现，但是这么做太麻烦，还得花费额外的空间构建二叉树，于是不采用堆排序。<br><a id="more"></a><br>故本文采用快速排序和归并排序来对单链表进行排序。</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>在一般实现的快速排序中，我们通过首尾指针来对元素进行切分，下面采用快排的另一种方法来对元素进行切分。</p><p>我们只需要两个指针p1和p2，这两个指针均往next方向移动，移动的过程中保持p1之前的key都小于选定的key，p1和p2之间的key都大于选定的key，那么当p2走到末尾时交换p1与key值便完成了一次切分。</p><p>图示如下：<br><img src="http://img.blog.csdn.net/20140326225106296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZG91ZmVpX2Njc3Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用快速排序</span></span><br><span class="line">   quickSort(head, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(ListNode head, ListNode end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head != end) &#123;</span><br><span class="line">        ListNode node = partion(head, end);</span><br><span class="line">        quickSort(head, node);</span><br><span class="line">        quickSort(node.next, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">partion</span><span class="params">(ListNode head, ListNode end)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = head, p2 = head.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//走到末尾才停</span></span><br><span class="line">    <span class="keyword">while</span> (p2 != end) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//大于key值时，p1向前走一步，交换p1与p2的值</span></span><br><span class="line">        <span class="keyword">if</span> (p2.val &lt; head.val) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> temp = p1.val;</span><br><span class="line">            p1.val = p2.val;</span><br><span class="line">            p2.val = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当有序时，不交换p1和key值</span></span><br><span class="line">    <span class="keyword">if</span> (p1 != head) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = p1.val;</span><br><span class="line">        p1.val = head.val;</span><br><span class="line">        head.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序应该算是链表排序最佳的选择了，保证了最好和最坏时间复杂度都是nlogn，而且它在数组排序中广受诟病的空间复杂度在链表排序中也从O(n)降到了O(1)。</p><p>归并排序的一般步骤为：</p><ol><li>将待排序数组（链表）取中点并一分为二；</li><li>递归地对左半部分进行归并排序；</li><li>递归地对右半部分进行归并排序；</li><li>将两个半部分进行合并（merge）,得到结果。</li></ol><p>首先用快慢指针(快慢指针思路，快指针一次走两步，慢指针一次走一步，快指针在链表末尾时，慢指针恰好在链表中点)的方法找到链表中间节点，然后递归的对两个子链表排序，把两个排好序的子链表合并成一条有序的链表。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用归并排序</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取中间结点</span></span><br><span class="line">    ListNode mid = getMid(head);</span><br><span class="line">    ListNode right = mid.next;</span><br><span class="line">    mid.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="keyword">return</span> mergeSort(sortList(head), sortList(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取链表的中间结点,偶数时取中间第一个</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">getMid</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针</span></span><br><span class="line">    ListNode slow = head, quick = head;</span><br><span class="line">    <span class="comment">//快2步，慢一步</span></span><br><span class="line">    <span class="keyword">while</span> (quick.next != <span class="keyword">null</span> &amp;&amp; quick.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        quick = quick.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 归并两个有序的链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeSort</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = head1, p2 = head2, head;</span><br><span class="line">   <span class="comment">//得到头节点的指向</span></span><br><span class="line">    <span class="keyword">if</span> (head1.val &lt; head2.val) &#123;</span><br><span class="line">        head = head1;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = head2;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode p = head;</span><br><span class="line">    <span class="comment">//比较链表中的值</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p1.val &lt;= p2.val) &#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二条链表空了</span></span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一条链表空了</span></span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码放在：<br><a href="https://github.com/morethink/algorithm/blob/master/src/algorithm/leetcode/SortList.java" target="_blank" rel="noopener">https://github.com/morethink/algorithm/blob/master/src/algorithm/leetcode/SortList.java</a></p><p><strong>参考文档</strong>：</p><ol><li><a href="http://www.cnblogs.com/TenosDoIt/p/3666585.html" target="_blank" rel="noopener">链表排序（冒泡、选择、插入、快排、归并、希尔、堆排序）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文描述了LeetCode 148题 &lt;a href=&quot;https://leetcode.com/problems/sort-list/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sort-list&lt;/a&gt; 的解法。&lt;/p&gt;
&lt;p&gt;题目描述如下:&lt;br&gt;Sort a linked list in O(n log n) time using constant space complexity.&lt;/p&gt;
&lt;p&gt;题目要求我们在O(n log n)时间复杂度下完成对单链表的排序，我们知道平均时间复杂度为O(n log n)的排序方法有快速排序、归并排序和堆排序。而一般是用数组来实现二叉堆，当然可以用二叉树来实现，但是这么做太麻烦，还得花费额外的空间构建二叉树，于是不采用堆排序。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.morethink.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.morethink.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="链表" scheme="https://www.morethink.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java实现八大排序算法</title>
    <link href="https://www.morethink.cn/Java%E5%AE%9E%E7%8E%B0%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://www.morethink.cn/Java实现八大排序算法/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.181Z</updated>
    
    <content type="html"><![CDATA[<p>本文对常见的排序算法进行了总结。</p><p>常见排序算法如下：</p><ol><li><a href="#直接插入排序">直接插入排序</a></li><li><a href="#希尔排序">希尔排序</a></li><li><a href="#简单选择排序">简单选择排序</a></li><li><a href="#堆排序">堆排序</a></li><li><a href="#冒泡排序">冒泡排序</a></li><li><a href="#快速排序">快速排序</a></li><li><a href="#归并排序">归并排序</a></li><li><a href="#基数排序">基数排序</a></li></ol><a id="more"></a><p>它们都属于内部排序，也就是只考虑数据量较小仅需要使用内存的排序算法，他们之间关系如下：</p><p><img src="https://images.morethink.cn/3d3cc5f92a9b88b9def40b8aeab71af2.png" alt=""></p><p><strong>稳定与非稳定</strong>:</p><p>如果一个排序算法能够保留数组中重复元素的相对位置则可以被称为是 <strong>稳定</strong> 的。反之，则是 <strong>非稳定</strong> 的。</p><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了要给插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><p>动态效果如下：</p><p><img src="https://images.morethink.cn/28749729-ca072084-7503-11e7-881c-92aa915ce369.gif" alt=""></p><p><strong>注意</strong>：<br>如果 <em>比较操作</em> 的代价比 <em>交换操作</em> 大的话，可以采用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95" target="_blank" rel="noopener">二分查找法</a>来减少 <em>比较操作</em> 的数目。该算法可以认为是 <strong>插入排序</strong> 的一个变种，称为<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">二分查找插入排序</a>。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过交换进行插入排序，借鉴冒泡排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">                a[j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过将较大的元素都向右移动而不总是交换两个元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = a[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; num &lt; a[j]; j--) &#123;</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>直接插入排序复杂度如下：</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><h2 id="比较与总结"><a href="#比较与总结" class="headerlink" title="比较与总结"></a>比较与总结</h2><p>插入排序所需的时间取决于输入元素的初始顺序。例如，对一个很大且其中的元素已经有序(或接近有序)的数组进行排序将会比随机顺序的数组或是逆序数组进行排序要快得多。</p><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序，也称 <strong>递减增量排序算法</strong>，是插入排序的一种更高效的改进版本。希尔排序是 <strong>非稳定排序算法</strong>。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一</li></ul><p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h2 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h2><p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。</p><p>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是<strong>初次取数组长度的一半</strong>为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97" target="_blank" rel="noopener">维基百科</a>。</p><h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><ol><li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li><li>按增量序列个数 k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><p>效果如下：</p><p><img src="https://images.morethink.cn/4697893fd8a952d01956e192640c1c3c.png" alt=""></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面参考《算法》中给出的步长选择策略，《算法》中给出的解释是</p><blockquote><p>下面代码中递增序列的计算和使用都很简单，和复杂递增序列的性能接近。当可以证明复杂的序列在最坏情况下的性能要好于我们所使用的递增序列。更加优秀的递增序列有待我们去发现。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = a.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; length / <span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; h &gt;= <span class="number">1</span>; h /= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - h; i += h) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + h; j &gt; <span class="number">0</span>; j -= h) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[j - h]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                    a[j] = a[j - h];</span><br><span class="line">                    a[j - h] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>以下是希尔排序复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog2 n)</td><td>O(nlog2 n)</td><td>O(nlog2 n)</td><td>O(1)</td></tr></tbody></table><h2 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h2><p>希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。</p><h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><h2 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h2><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n个元素的表进行排序总共进行至多 n-1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><h2 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h2><ol><li>从未排序序列中，找到关键字最小的元素</li><li>如果最小元素不是未排序序列的第一个元素，将其和未排序序列第一个元素互换</li><li>重复1、2步，直到排序结束。</li></ol><p>动图效果如下所示：<br><img src="https://images.morethink.cn/28749720-90304278-7503-11e7-9bc8-e3b56539d8bf.gif" alt=""></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="comment">//选出之后待排序中值最小的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最小值不等于当前值时进行交换</span></span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[min];</span><br><span class="line">            a[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>以下是选择排序复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><h2 id="总结与思考-1"><a href="#总结与思考-1" class="headerlink" title="总结与思考"></a>总结与思考</h2><p>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²/2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><blockquote><p>1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd) 和威廉姆斯(J．Williams) 在1964年共同发明了著名的堆排序算法(Heap Sort).</p></blockquote><p>堆的定义如下：$n$个元素的序列{k1,k2,..,kn}<br>当且仅当满足下关系时，称之为堆。</p><p><img src="https://images.morethink.cn/a59e9c9d21c72944dac53b59b745a5cc.png" alt=""></p><p>把此序列对应的二维数组看成一个完全二叉树。那么堆的含义就是：<strong>完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。</strong> 由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。</p><h2 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h2><p>此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p><h2 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h2><ol><li>先将初始序列$K[1..n]$建成一个大顶堆, 那么此时第一个元素$K_1$最大, 此堆为初始的无序区.</li><li>再将关键字最大的记录$K_1$ (即堆顶, 第一个元素)和无序区的最后一个记录 $K_n$ 交换, 由此得到新的无序区$K[1..n-1]$和有序区$K[n]$, 且满足$K[1..n-1].keys \leqslant K[n].key$</li><li>交换$K_1$ 和 $K_n$ 后, 堆顶可能违反堆性质, 因此需将$K[1..n-1]$调整为堆. 然后重复步骤2, 直到无序区只有一个元素时停止。</li></ol><p>动图效果如下所示：</p><p><img src="https://images.morethink.cn/heap_sort_gif.gif" alt="堆排序过程"></p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。</p><p>总结起来就是定义了以下几种操作：</p><ul><li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ul><p>对于堆节点的访问：</p><ul><li>父节点i的左子节点在位置：<code>(2*i+1)</code>;</li><li>父节点i的右子节点在位置：<code>(2*i+2)</code>;</li><li>子节点i的父节点在位置：<code>floor((i-1)/2)</code>;</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        max_heapify(a, i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//堆顶元素(第一个元素)与Kn交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = a[i];</span><br><span class="line">        a[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  将数组堆化</span></span><br><span class="line"><span class="comment"> *  i = 第一个非叶子节点。</span></span><br><span class="line"><span class="comment"> *  从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。</span></span><br><span class="line"><span class="comment"> *  叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//左子节点位置</span></span><br><span class="line">        child = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//右子节点存在且大于左子节点，child变成右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (child != n &amp;&amp; a[child] &lt; a[child + <span class="number">1</span>]) &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换父节点与左右子节点中的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[child]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[child];</span><br><span class="line">            a[child] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ol><li>建立堆的过程, 从length/2 一直处理到0, 时间复杂度为O(n);</li><li>调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);</li><li>堆排序的过程由n次第2步完成, 时间复杂度为O(nlgn).</li></ol><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>$O(n \log_{2}n)$</td><td>$O(n \log_{2}n)$</td><td>$O(n \log_{2}n)$</td><td>O(1)</td></tr></tbody></table><h2 id="总结与思考-2"><a href="#总结与思考-2" class="headerlink" title="总结与思考"></a>总结与思考</h2><p><strong>由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列</strong>。 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序。</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><blockquote><p>我想对于它每个学过C语言的都会了解，这可能是很多人接触的第一个排序算法。</p></blockquote><h2 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h2><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h2 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h2><p>冒泡排序算法的运作如下：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p><img src="https://images.morethink.cn/bubble.gif" alt=""></p><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//外层循环控制比较的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//内层循环控制到达位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//前面的元素比后面大就交换</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>以下是冒泡排序算法复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</p><h2 id="总结与思考-3"><a href="#总结与思考-3" class="headerlink" title="总结与思考"></a>总结与思考</h2><p>由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><h2 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h2><p>快速排序的基本思想：<strong>挖坑填数+分治法</strong>。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好。</p><h2 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h2><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：</p><ol><li>从数列中挑出一个元素，称为”基准”（pivot）。</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p><img src="https://images.morethink.cn/quick-sort.gif" alt=""></p><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><p>用伪代码描述如下：</p><ol><li><code>i = L; j = R;</code> 将基准数挖出形成第一个坑<code>a[i]</code>。</li><li><code>j--</code>，由后向前找比它小的数，找到后挖出此数填前一个坑<code>a[i]</code>中。</li><li><code>i++</code>，由前向后找比它大的数，找到后也挖出此数填到前一个坑<code>a[j]</code>中。</li><li>再重复执行2，3二步，直到<code>i==j</code>，将基准数填入<code>a[i]</code>中</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已经排完</span></span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = low;</span><br><span class="line">    <span class="keyword">int</span> right = high;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存基准值</span></span><br><span class="line">    <span class="keyword">int</span> pivot = a[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">//从后向前找到比基准小的元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= pivot)</span><br><span class="line">            right--;</span><br><span class="line">        a[left] = a[right];</span><br><span class="line">        <span class="comment">//从前往后找到比基准大的元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= pivot)</span><br><span class="line">            left++;</span><br><span class="line">        a[right] = a[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放置基准值，准备分治递归快排</span></span><br><span class="line">    a[left] = pivot;</span><br><span class="line">    sort(a, low, left - <span class="number">1</span>);</span><br><span class="line">    sort(a, left + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是递归版的快速排序：通过把基准插入到合适的位置来实现分治，并递归地对分治后的两个划分继续快排。那么非递归版的快排如何实现呢？</p><p>因为 <strong>递归的本质是栈</strong> ，所以我们非递归实现的过程中，可以借助栈来保存中间变量就可以实现非递归了。在这里中间变量也就是通过Pritation函数划分区间之后分成左右两部分的首尾指针，只需要保存这两部分的首尾指针即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortByStack</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始状态的左右指针入栈</span></span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    stack.push(a.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//出栈进行划分</span></span><br><span class="line">        <span class="keyword">int</span> high = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> low = stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivotIndex = partition(a, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存中间变量</span></span><br><span class="line">        <span class="keyword">if</span> (pivotIndex &gt; low) &#123;</span><br><span class="line">            stack.push(low);</span><br><span class="line">            stack.push(pivotIndex - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pivotIndex &lt; high &amp;&amp; pivotIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            stack.push(pivotIndex + <span class="number">1</span>);</span><br><span class="line">            stack.push(high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = low;</span><br><span class="line">    <span class="keyword">int</span> right = high;</span><br><span class="line">    <span class="comment">//保存基准的值</span></span><br><span class="line">    <span class="keyword">int</span> pivot = a[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">//从后向前找到比基准小的元素，插入到基准位置中</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= pivot) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[left] = a[right];</span><br><span class="line">        <span class="comment">//从前往后找到比基准大的元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= pivot) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        a[right] = a[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准值，准备分治递归快排</span></span><br><span class="line">    a[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h2><h3 id="切换到插入排序"><a href="#切换到插入排序" class="headerlink" title="切换到插入排序"></a>切换到插入排序</h3><p>和大多数递归排序算法一样，改进快速排序性能的一个简单方法基于以下两点：</p><ul><li>对于小数组，快速排序比插入排序慢</li><li>因为递归，快速排序的sort()方法在小数组中叶会调用自己</li></ul><p>因此，在排序小数组时应该切换到插入排序。</p><h3 id="三者取中法"><a href="#三者取中法" class="headerlink" title="三者取中法"></a>三者取中法</h3><p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。</p><h3 id="三向快速排序"><a href="#三向快速排序" class="headerlink" title="三向快速排序"></a>三向快速排序</h3><p>实际应用中经常会出现含有大量重复元素的数组。例如，一个元素全部重复的子数组就不需要继续排序了，但我们的算法还会继续将它切分为更小的数组。在有大量重复元素的情况下，快速排序的递归性会使元素全部重复的子数组经常出现，这就有很大的改进潜力，经当前实现的线性对数级的性能提高到线性级别。</p><p><strong>算法描述</strong>：</p><ul><li>在lt之前的(lo~lt-1)都小于中间值</li><li>在gt之前的(gt+1~hi)都大于中间值</li><li>在lt~i-1的都等于中间值</li><li>在i~gt的都还不确定（最终i会大于gt，即不确定的将不复存在）</li></ul><p><img src="https://images.morethink.cn/9f4bd508a48664b472e5644e48c2be4b.png" alt=""></p><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortThreeWay</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> v = a[lo], lt = lo, i = lo + <span class="number">1</span>, gt = hi;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; v) &#123;</span><br><span class="line">            swap(a, i++, lt++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; v) &#123;</span><br><span class="line">            swap(a, i, gt--);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortThreeWay(a, lo, lt - <span class="number">1</span>);</span><br><span class="line">    sortThreeWay(a, gt + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>以下是快速排序算法复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n²)</td><td>O(1)（原地分区递归版）</td></tr></tbody></table><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p><h2 id="基本思想-6"><a href="#基本思想-6" class="headerlink" title="基本思想"></a>基本思想</h2><p>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p><img src="https://images.morethink.cn/merge.gif" alt="这个图很有概括性，来自维基"></p><h2 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h2><p><strong>归并排序可通过两种方式实现</strong>:</p><ul><li>自上而下的递归</li><li>自下而上的迭代</li></ul><p><strong>递归法</strong>（假设序列共有n个元素）：</p><ol><li>将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</li><li>将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</li><li>重复步骤2，直到所有元素排序完毕。</li></ol><p><img src="https://images.morethink.cn/merging-sort.gif" alt=""></p><p><strong>迭代法</strong></p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><p>归并排序其实要做两件事：</p><ul><li>分解：将序列每次折半拆分</li><li>合并：将划分后的序列段两两排序合并</li></ul><p>因此，归并排序实际上就是两个操作，拆分+合并</p><p>下面是递归的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并所需的辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一次性分配空间</span></span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//将左半边排序</span></span><br><span class="line">        sort(a, low, mid);</span><br><span class="line">        <span class="comment">//将右半边排序</span></span><br><span class="line">        sort(a, mid + <span class="number">1</span>, high);</span><br><span class="line">        merge(a, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法先将所有元素复制到aux[]中，然后在归并会a[]中。方法咋归并时(第二个for循环)</span></span><br><span class="line"><span class="comment">     * 进行了4个条件判断：</span></span><br><span class="line"><span class="comment">     * - 左半边用尽(取右半边的元素)</span></span><br><span class="line"><span class="comment">     * - 右半边用尽(取左半边的元素)</span></span><br><span class="line"><span class="comment">     * - 右半边的当前元素小于左半边的当前元素(取右半边的元素)</span></span><br><span class="line"><span class="comment">     * - 右半边的当前元素大于等于左半边的当前元素(取左半边的元素)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> low</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> high</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将a[low..mid]和a[mid+1..high]归并</span></span><br><span class="line">        <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = low; k &lt;= high; k++) &#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = low; k &lt;= high; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">                a[k] = aux[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; high) &#123;</span><br><span class="line">                a[k] = aux[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[j] &lt; aux[i]) &#123;</span><br><span class="line">                a[k] = aux[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a[k] = aux[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>以下是归并排序算法复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n)</td></tr></tbody></table><p>从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。</p><h2 id="总结与思考-4"><a href="#总结与思考-4" class="headerlink" title="总结与思考"></a>总结与思考</h2><p>归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需时间和NlogN成正比，它的主要缺点则是他所需的额外空间和N成正比。</p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）, 排序器每次只能看到一个列。它是基于元素值的每个位上的字符来排序的。 对于数字而言就是分别基于个位，十位， 百位或千位等等数字来排序。</p><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h2 id="基本思想-7"><a href="#基本思想-7" class="headerlink" title="基本思想"></a>基本思想</h2><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>基数排序按照优先从高位或低位来排序有两种实现方案：</p><ul><li><p><strong>MSD（Most significant digital） 从最左侧高位开始进行排序</strong>。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。<em>MSD方式适用于位数多的序列</em>。</p></li><li><p><strong>LSD （Least significant digital）从最右侧低位开始进行排序</strong>。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。<em>LSD方式适用于位数少的序列</em>。</p></li></ul><p><img src="https://images.morethink.cn/radix-sort_sample.gif" alt="基数排序LSD动图演示"></p><h2 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h2><p>我们以LSD为例，从最低位开始，具体算法描述如下：</p><ol><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ol><h2 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h2><p>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p><ul><li><p><strong>分配</strong>：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</p></li><li><p><strong>收集</strong>：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取得数组中的最大数，并取得位数</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; arr[i]) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxDigit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (max / <span class="number">10</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigit++;</span><br><span class="line">        max = max / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//申请一个桶空间</span></span><br><span class="line">    <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从低位到高位，对每一位遍历，将所有元素分配到桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bktLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];        <span class="comment">//存储各个桶中存储元素的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配：将所有元素分配到桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> whichBucket = (arr[j] % base) / (base / <span class="number">10</span>);</span><br><span class="line">            buckets[whichBucket][bktLen[whichBucket]] = arr[j];</span><br><span class="line">            bktLen[whichBucket]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; buckets.length; b++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; bktLen[b]; p++) &#123;</span><br><span class="line">                arr[k++] = buckets[b][p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Sorting: "</span> + Arrays.toString(arr));</span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>以下是基数排序算法复杂度，其中k为最大数的位数：</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(d*(n+r))</td><td>O(d*(n+r))</td><td>O(d*(n+r))</td><td>O(n+r)</td></tr></tbody></table><p>其中，<strong>d 为位数，r 为基数，n 为原数组个数</strong>。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 <code>O(d*(n + r))</code>。</p><h2 id="总结和思考"><a href="#总结和思考" class="headerlink" title="总结和思考"></a>总结和思考</h2><p>基数排序更适合用于对时间, 字符串等这些 <strong>整体权值未知的数据</strong> 进行排序。</p><p>基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ol><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ol><h1 id="八大排序算法总结"><a href="#八大排序算法总结" class="headerlink" title="八大排序算法总结"></a>八大排序算法总结</h1><p>各种排序性能对比如下:</p><table><thead><tr><th>排序类型</th><th>平均情况</th><th>最好情况</th><th>最坏情况</th><th>辅助空间</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>直接插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>折半插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n^1.3)</td><td>O(nlogn)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n²)</td><td>O(nlog₂n)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n²)</td><td>O(n+k)</td><td>(不)稳定</td></tr><tr><td>基数排序</td><td>O(d(n+k))</td><td>O(d(n+k))</td><td>O(d(n+kd))</td><td>O(n+kd)</td><td>稳定</td></tr></tbody></table><p>从时间复杂度来说：</p><ol><li>平方阶O(n²)排序：<strong>各类简单排序：直接插入、直接选择和冒泡排序</strong></li><li>线性对数阶O(nlog₂n)排序：<strong>快速排序、堆排序和归并排序</strong></li><li>O(n1+§))排序，§是介于0和1之间的常数：<strong>希尔排序</strong></li><li>线性阶O(n)排序：<strong>基数排序，此外还有桶、箱排序</strong></li></ol><p>论是否有序的影响：</p><ul><li>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</li><li>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；</li><li>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</li></ul><p><img src="https://images.morethink.cn/sort-comparison.png" alt=""></p><p>代码放在 <a href="https://github.com/morethink/algorithm/tree/master/src/algorithm/sort" target="_blank" rel="noopener">https://github.com/morethink/algorithm/tree/master/src/algorithm/sort</a></p><p><strong>参考资料</strong>：</p><ol><li>《算法》第四版</li><li>维基百科</li><li><a href="https://itimetraveler.github.io/2017/07/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/#%E4%B8%83%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merging-Sort%EF%BC%89" target="_blank" rel="noopener">八大排序算法总结与java实现</a></li><li><a href="https://segmentfault.com/a/1190000010413296#articleHeader33" target="_blank" rel="noopener">前端面试必备——十大经典排序算法</a></li><li><a href="https://www.jianshu.com/p/8c915179fd02" target="_blank" rel="noopener">必须知道的八大种排序算法【java实现】</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对常见的排序算法进行了总结。&lt;/p&gt;
&lt;p&gt;常见排序算法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#直接插入排序&quot;&gt;直接插入排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#希尔排序&quot;&gt;希尔排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#简单选择排序&quot;&gt;简单选择排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#堆排序&quot;&gt;堆排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#冒泡排序&quot;&gt;冒泡排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#快速排序&quot;&gt;快速排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#归并排序&quot;&gt;归并排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#基数排序&quot;&gt;基数排序&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.morethink.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.morethink.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java实现二分查找算法</title>
    <link href="https://www.morethink.cn/Java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>https://www.morethink.cn/Java实现二分查找算法/</id>
    <published>2018-01-28T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.180Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找（binary search），也称折半搜索，是一种在 <strong>有序数组</strong> 中 <strong>查找某一特定元素</strong> 的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p><ul><li><strong>时间复杂度</strong>:折半搜索每次把搜索区域减少一半，时间复杂度为O(log n)。（n代表集合中元素的个数）</li><li><strong>空间复杂度</strong>: O(1)。虽以递归形式定义，但是尾递归，可改写为循环。</li></ul><a id="more"></a><h1 id="代码描述"><a href="#代码描述" class="headerlink" title="代码描述"></a>代码描述</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarysearch</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (array[mid] &gt; target)</span><br><span class="line">        <span class="keyword">return</span> binarysearch(array, low, mid - <span class="number">1</span>, target);</span><br><span class="line">    <span class="keyword">if</span> (array[mid] &lt; target)</span><br><span class="line">        <span class="keyword">return</span> binarysearch(array, mid + <span class="number">1</span>, high, target);</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearchWithoutRecursion</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; key)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找法的缺陷"><a href="#二分查找法的缺陷" class="headerlink" title="二分查找法的缺陷"></a>二分查找法的缺陷</h1><p>二分查找法的O(log n)让它成为十分高效的算法。不过它的缺陷却也是那么明显的。就在它的限定之上：必须有序，我们很难保证我们的数组都是有序的。当然可以在构建数组的时候进行排序，可是又落到了第二个瓶颈上：它必须是数组。</p><p>数组读取效率是O(1)，可是它的插入和删除某个元素的效率却是O(n)。因而导致构建有序数组变成低效的事情。</p><p>解决这些缺陷问题更好的方法应该是使用二叉查找树了，最好自然是自平衡二叉查找树了，既能高效的（O(n log n)）构建有序元素集合，又能如同二分查找法一样快速（O(log n)）的搜寻目标数。</p><p><strong>参考资料</strong>：</p><ol><li><a href="http://www.cnblogs.com/ider/archive/2012/04/01/binary_search.html" target="_blank" rel="noopener">二分查找法的实现和应用汇总</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二分查找（binary search），也称折半搜索，是一种在 &lt;strong&gt;有序数组&lt;/strong&gt; 中 &lt;strong&gt;查找某一特定元素&lt;/strong&gt; 的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;:折半搜索每次把搜索区域减少一半，时间复杂度为O(log n)。（n代表集合中元素的个数）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: O(1)。虽以递归形式定义，但是尾递归，可改写为循环。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.morethink.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="https://www.morethink.cn/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Win10下通过IIS调试ASP程序遇到的问题和解决方案</title>
    <link href="https://www.morethink.cn/Win10-through-the-IIS-debugging-ASP-program/"/>
    <id>https://www.morethink.cn/Win10-through-the-IIS-debugging-ASP-program/</id>
    <published>2018-01-05T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.188Z</updated>
    
    <content type="html"><![CDATA[<p>最近维护了以前别人的写的一个ASP的系统，记录一下调试过程中的问题和解决方案。</p><h1 id="环境篇"><a href="#环境篇" class="headerlink" title="环境篇"></a>环境篇</h1><h1 id="万维网发布服务-W3SVC-已经停止"><a href="#万维网发布服务-W3SVC-已经停止" class="headerlink" title="万维网发布服务(W3SVC)已经停止"></a>万维网发布服务(W3SVC)已经停止</h1><p><strong>问题</strong>：<br>万维网发布服务(W3SVC)已经停止。除非万维网发布服务(W3SVC)正在运行,否则无法启动网站。</p><a id="more"></a><p><img src="https://images.morethink.cn/d479322a25d8c93f9bf481695af50858.png" alt=""></p><p><strong>解决方法</strong>：</p><p>需要先启动整个应用。</p><p><img src="https://images.morethink.cn/31b0292ddbc24480229d1fbce590bb8e.png" alt=""></p><h1 id="IIS服务"><a href="#IIS服务" class="headerlink" title="IIS服务"></a>IIS服务</h1><p>控制面板&gt;&gt;程序和功能&gt;&gt;启动或关闭Windows功能&gt;&gt;IIS服务<br><img src="https://images.morethink.cn/729c9c06256b9029cadf7e00cbbfc667.png" alt=""></p><p>但是这样仅仅是开启了IIS服务，会出现Http500错误，不能运行ASP程序，因为IIS服务器默认并没有帮我们配置ASP或者ASP.NET环境，需要自己手动配置(在此过程中，我启动过多次电脑)。</p><h1 id="配置ASP环境"><a href="#配置ASP环境" class="headerlink" title="配置ASP环境"></a>配置ASP环境</h1><p>ASP配置如下：<br><img src="https://images.morethink.cn/a1339b7725b29585940ccd745fcd7512.png" alt=""></p><p>如果需要ASP.NET，需要如下配置：</p><p><img src="https://images.morethink.cn/8e827a63559409b25937857d136e236f.png" alt=""></p><h1 id="IIS7中出现An-error-occurred-on-the-server-when-processing-the-URL错误"><a href="#IIS7中出现An-error-occurred-on-the-server-when-processing-the-URL错误" class="headerlink" title="IIS7中出现An error occurred on the server when processing the URL错误"></a>IIS7中出现An error occurred on the server when processing the URL错误</h1><p><strong>错误描述</strong>：<br>An error occurred on the server when processing the URL. Please contact the system administrator.If you are the system administrator please click here to find out more about this error.</p><ol><li>打开控制面板→管理工具→Internet 信息服务(IIS)管理器→双击“ASP”图标<br><img src="https://images.morethink.cn/4cc9001c24f9705e91f4257074f8673c.png" alt=""></li><li>在左边的窗口中找到你的网站，然后在右边的窗口中展开“调试属性”，把“将错误发送到浏览器”设为True即可<br><img src="https://images.morethink.cn/4a629fd49cf2edefc97cc61a7f1d0d4f.png" alt=""></li></ol><p>此时你再运行ASP程序时就会看到具体的错误了，然后再根据错误提示进行相应的修改即可。</p><h1 id="代码篇"><a href="#代码篇" class="headerlink" title="代码篇"></a>代码篇</h1><h1 id="ADODB-Connection-错误-‘800a0e7a’"><a href="#ADODB-Connection-错误-‘800a0e7a’" class="headerlink" title="ADODB.Connection 错误 ‘800a0e7a’"></a>ADODB.Connection 错误 ‘800a0e7a’</h1><p><strong>具体错误</strong>：<br>ADODB.Connection 错误 ‘800a0e7a’<br>未找到提供程序。该程序可能未正确安装。</p><p><strong>原因</strong>：</p><p>因为系统是64位的win10，所以会出现这个问题。</p><p><strong>解决办法</strong>：<br>找到IIS应用程序池，“设置应用程序池默认属性”-&gt;“常规”-&gt;”启用 32 位应用程序”，设置为 True。</p><p><img src="https://images.morethink.cn/bb814d72e30f1a99899cc7e919fa774e.png" alt=""><br>height=”100%” width=”100%”</p><p>style=”width:757px; height:455px;”<br>这样问题就解决了。</p><h1 id="ADODB-Recordset-错误-‘800a0cc1’"><a href="#ADODB-Recordset-错误-‘800a0cc1’" class="headerlink" title="ADODB.Recordset 错误 ‘800a0cc1’"></a>ADODB.Recordset 错误 ‘800a0cc1’</h1><p><strong>描述</strong>：<br>ADODB.Recordset 错误 ‘800a0cc1’<br>在对应所需名称或序数的集合中，未找到项目。</p><p><strong>解决</strong>：<br>一般是字段写错了或者，你的数据库没有这个字段。</p><h1 id="iframe自适应"><a href="#iframe自适应" class="headerlink" title="iframe自适应"></a>iframe自适应</h1><p>JS代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//iframe高度自适应</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IFrameReSize</span>(<span class="params">iframename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pTar = <span class="built_in">document</span>.getElementByIdx_x_x(iframename);</span><br><span class="line">    <span class="keyword">if</span> (pTar) &#123; <span class="comment">//ff</span></span><br><span class="line">        <span class="keyword">if</span> (pTar.contentDocument &amp;&amp; pTar.contentDocument.body.offsetHeight) &#123;</span><br><span class="line">            pTar.height = pTar.contentDocument.body.offsetHeight;</span><br><span class="line">        &#125; <span class="comment">//ie</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pTar.Document &amp;&amp; pTar.Document.body.scrollHeight) &#123;</span><br><span class="line"></span><br><span class="line">            pTar.height = pTar.Document.body.scrollHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//iframe宽度自适应</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IFrameReSizeWidth</span>(<span class="params">iframename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pTar = <span class="built_in">document</span>.getElementByIdx_x_x(iframename);</span><br><span class="line">    <span class="keyword">if</span> (pTar) &#123; <span class="comment">//ff</span></span><br><span class="line">        <span class="keyword">if</span> (pTar.contentDocument &amp;&amp; pTar.contentDocument.body.offsetWidth) &#123;</span><br><span class="line">            pTar.width = pTar.contentDocument.body.offsetWidth;</span><br><span class="line">        &#125; <span class="comment">//ie</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pTar.Document &amp;&amp; pTar.Document.body.scrollWidth) &#123;</span><br><span class="line">            pTar.width = pTar.Document.body.scrollWidth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Iframe框配置：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"Main.htm"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">height</span>=<span class="string">"100%"</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"mainFrame"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">onload</span>=<span class="string">'IFrameReSize("mainFrame");IFrameReSizeWidth("mainFrame");'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="ACCESS分页"><a href="#ACCESS分页" class="headerlink" title="ACCESS分页"></a>ACCESS分页</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> nid <span class="keyword">between</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">min</span>(nid) <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> top <span class="number">4</span> nid <span class="keyword">from</span> newsdata <span class="keyword">order</span> <span class="keyword">by</span> nid <span class="keyword">desc</span>))</span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">min</span>(nid) <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> top <span class="number">1</span> nid <span class="keyword">from</span> newsdata <span class="keyword">order</span> <span class="keyword">by</span> nid <span class="keyword">desc</span>))</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> nid <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>利用top和min函数分别找出分页的起始ID和结束ID，如果要按照升序排列，就要用top和max来找出起始ID和结束ID，之后在使用between语句直接选取。注意三个地方的排序方式必须一致，查询条件也必须一致。</p><p><strong>参考文档</strong>：</p><ol><li><a href="http://www.ljf.cn/archives/2281" target="_blank" rel="noopener">简单又高效的Access分页语句</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近维护了以前别人的写的一个ASP的系统，记录一下调试过程中的问题和解决方案。&lt;/p&gt;
&lt;h1 id=&quot;环境篇&quot;&gt;&lt;a href=&quot;#环境篇&quot; class=&quot;headerlink&quot; title=&quot;环境篇&quot;&gt;&lt;/a&gt;环境篇&lt;/h1&gt;&lt;h1 id=&quot;万维网发布服务-W3SVC-已经停止&quot;&gt;&lt;a href=&quot;#万维网发布服务-W3SVC-已经停止&quot; class=&quot;headerlink&quot; title=&quot;万维网发布服务(W3SVC)已经停止&quot;&gt;&lt;/a&gt;万维网发布服务(W3SVC)已经停止&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：&lt;br&gt;万维网发布服务(W3SVC)已经停止。除非万维网发布服务(W3SVC)正在运行,否则无法启动网站。&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="https://www.morethink.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="IIS" scheme="https://www.morethink.cn/tags/IIS/"/>
    
      <category term="ASP" scheme="https://www.morethink.cn/tags/ASP/"/>
    
  </entry>
  
  <entry>
    <title>Nginx几种负载均衡算法及配置实例</title>
    <link href="https://www.morethink.cn/Nginx-several-load-balancing-algorithm/"/>
    <id>https://www.morethink.cn/Nginx-several-load-balancing-algorithm/</id>
    <published>2018-01-04T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.184Z</updated>
    
    <content type="html"><![CDATA[<p>本文装载自： <a href="https://yq.aliyun.com/articles/114683" target="_blank" rel="noopener">https://yq.aliyun.com/articles/114683</a></p><p>Nginx负载均衡（工作在七层“应用层”）功能主要是通过upstream模块实现，Nginx负载均衡默认对后端服务器有健康检测的能力，仅限于端口检测，在后端服务器比较少的情况下负载均衡能力表现突出。</p><p>Nginx的几种负载均衡算法：<br><a id="more"></a></p><ol><li>轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，则自动剔除故障机器，使用户访问不受影响。</li><li>weight：指定轮询权重，weight值越大，分配到的几率就越高，主要用于后端每台服务器性能不均衡的情况。</li><li>ip_hash：每个请求按访问IP的哈希结果分配，这样每个访客固定访问一个后端服务器，可以有效的解决动态网页存在的session共享问题。</li><li>fair（第三方）：更智能的一个负载均衡算法，此算法可以根据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。如果想要使用此调度算法，需要Nginx的upstream_fair模块。</li><li>url_hash（第三方）：按访问URL的哈希结果来分配请求，使每个URL定向到同一台后端服务器，可以进一步提高后端缓存服务器的效率。如果想要使用此调度算法，需要Nginx的hash软件包。</li></ol><p>在upstream模块中，可以通过server命令指定后端服务器的IP地址和端口，同时还可以设置每台后端服务器在负载均衡调度中的状态，常用的状态有以下几种：</p><ol><li>down：表示当前server暂时不参与负载均衡。</li><li>backup：预留的备份机，当其他所有非backup机器出现故障或者繁忙的时候，才会请求backup机器，这台机器的访问压力最轻。</li><li>max_fails：允许请求的失败次数，默认为1，配合fail_timeout一起使用</li><li>fail_timeout：经历max_fails次失败后，暂停服务的时间，默认为10s（某个server连接失败了max_fails次，则nginx会认为该server不工作了。同时，在接下来的 fail_timeout时间内，nginx不再将请求分发给失效的server。）</li></ol><p>下面是一个负载均衡的配置示例，这里只列出http配置段，省略了其他部分配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream whsirserver &#123;</span><br><span class="line">    server 192.168.0.120:80 weight=5 max_fails=3 fail_timeout=20s;</span><br><span class="line">    server 192.168.0.121:80 weight=1 max_fails=3 fail_timeout=20s;</span><br><span class="line">    server 192.168.0.122:80 weight=3 max_fails=3 fail_timeout=20s;</span><br><span class="line">    server 192.168.0.123:80 weight=4 max_fails=3 fail_timeout=20s;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.whsir.com;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    root /data/www;</span><br><span class="line">        location / &#123;</span><br><span class="line">        proxy_pass http://whsirserver;</span><br><span class="line">        proxy_next_upstream http_500 http_502 error timeout invalid_header;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>upstream负载均衡开始，通过upstream指定了一个负载均衡器的名称为whsirserver，这个名称可以自己定义，在后面proxy_pass直接调用即可。</p><p>proxy_next_upstream参数用来定义故障转移策略，当后端服务器节点返回500、502和执行超时等错误时，自动将请求转发到upstream负载均衡器中的另一台服务器，实现故障转移。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文装载自： &lt;a href=&quot;https://yq.aliyun.com/articles/114683&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://yq.aliyun.com/articles/114683&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Nginx负载均衡（工作在七层“应用层”）功能主要是通过upstream模块实现，Nginx负载均衡默认对后端服务器有健康检测的能力，仅限于端口检测，在后端服务器比较少的情况下负载均衡能力表现突出。&lt;/p&gt;
&lt;p&gt;Nginx的几种负载均衡算法：&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="https://www.morethink.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Nginx" scheme="https://www.morethink.cn/tags/Nginx/"/>
    
      <category term="负载均衡" scheme="https://www.morethink.cn/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java解决CSRF问题</title>
    <link href="https://www.morethink.cn/CSRF/"/>
    <id>https://www.morethink.cn/CSRF/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.177Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址： <a href="https://github.com/morethink/web-security-csrf" target="_blank" rel="noopener">https://github.com/morethink/web-security-csrf</a></p><h1 id="CSRF是什么？"><a href="#CSRF是什么？" class="headerlink" title="CSRF是什么？"></a>CSRF是什么？</h1><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p><h1 id="CSRF可以做什么？"><a href="#CSRF可以做什么？" class="headerlink" title="CSRF可以做什么？"></a>CSRF可以做什么？</h1><p>你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p><a id="more"></a><h1 id="CSRF的原理"><a href="#CSRF的原理" class="headerlink" title="CSRF的原理"></a>CSRF的原理</h1><p>下图简单阐述了CSRF攻击的思<br><img src="https://images.morethink.cn/138ad4f05b47533bf46904dc165167cc.png" alt=""></p><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><ol><li>登录受信任网站A，并在本地生成Cookie。</li><li>在不登出A的情况下，访问危险网站B。</li></ol><p>看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：</p><ol><li>你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</li><li>你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</li><li>上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li></ol><p>下面讲一讲java解决CSRF攻击的方式。</p><h1 id="模拟CSRF攻击"><a href="#模拟CSRF攻击" class="headerlink" title="模拟CSRF攻击"></a>模拟CSRF攻击</h1><h2 id="登录A网站"><a href="#登录A网站" class="headerlink" title="登录A网站"></a>登录A网站</h2><p>用户名和密码都是admin。</p><p><code>http://localhost:8081/login.html</code>:<br><img src="https://images.morethink.cn/e298f8ef08869557b8fb60034f06bb80.png" alt=""></p><h2 id="你有权限删除1号帖子"><a href="#你有权限删除1号帖子" class="headerlink" title="你有权限删除1号帖子"></a>你有权限删除1号帖子</h2><p><code>http://localhost:8081/deletePost.html</code>:<br><img src="https://images.morethink.cn/b8fc74747a493946fe9684ad4db6f546.png" alt=""></p><h2 id="登录有CSRF攻击A网站的B网站"><a href="#登录有CSRF攻击A网站的B网站" class="headerlink" title="登录有CSRF攻击A网站的B网站"></a>登录有CSRF攻击A网站的B网站</h2><p><code>http://localhost:8082/deletePost.html</code>:</p><p><img src="https://images.morethink.cn/csrf-attack.gif" alt=""></p><p>明显看到B网站是8082端口，A网站是8081端口，但是B网站的删除2号帖子功能依然实现。</p><h1 id="预防CSRF攻击"><a href="#预防CSRF攻击" class="headerlink" title="预防CSRF攻击"></a>预防CSRF攻击</h1><p>简单来说，CSRF 就是网站 A 对用户建立信任关系后，在网站 B 上利用这种信任关系，跨站点向网站 A 发起一些伪造的用户操作请求，以达到攻击的目的。</p><p>而之所以可以完成攻击是因为B向A发起攻击的时候会把A网站的cookie带给A网站，也就是说cookie已经不安全了。</p><h2 id="通过Synchronizer-Tokens"><a href="#通过Synchronizer-Tokens" class="headerlink" title="通过Synchronizer Tokens"></a>通过Synchronizer Tokens</h2><p>Synchronizer Tokens： 在表单里隐藏一个随机变化的 csrf_token csrf_token 提交到后台进行验证，如果验证通过则可以继续执行操作。这种情况有效的主要原因是网站 B 拿不到网站 A 表单里的 csrf_token</p><p>这种方式的使用条件是PHP和JSP等。因为cookie已经不安全了，因此把csrf_token值存储在session中，然后每次表单提交时都从session取出来放到form表单的隐藏域中，这样B网站不可以得到这个存储到session中的值。</p><p>下面是JSP的：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;input type="hidden" name="random_form" value=&lt;%=random%&gt;&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure></p><p>但是我现在的情况是html，不是JSP，并不能动态的从session中取出csrf_token值。只能采用加密的方式了。</p><h2 id="Hash加密cookie中csrf-token值"><a href="#Hash加密cookie中csrf-token值" class="headerlink" title="Hash加密cookie中csrf_token值"></a>Hash加密cookie中csrf_token值</h2><p>这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了。</p><p>我采用的hash加密方法是JS实现Java的HashCode方法，得到hash值，这个比较简单。也可以采用其他的hash算法。</p><p>前端向后台传递hash之后的csrf_token值和cookie中的csrf_token值，后台拿到cookie中的csrf_token值后得到hashCode值然后与前端传过来的值进行比较，一样则通过。</p><h3 id="你有权限删除1号帖子-1"><a href="#你有权限删除1号帖子-1" class="headerlink" title="你有权限删除1号帖子"></a>你有权限删除1号帖子</h3><p><code>http://localhost:8081/deletePost.html</code></p><p><img src="https://images.morethink.cn/2ac5eab98780646c6c36dcdc98fa50c7.png" alt=""></p><h3 id="B网站的他已经没有权限了"><a href="#B网站的他已经没有权限了" class="headerlink" title="B网站的他已经没有权限了"></a>B网站的他已经没有权限了</h3><p>我们通过UserFilter.java给攻击者返回的是403错误，表示服务器理解用户客户端的请求但拒绝处理。</p><p><code>http://localhost:8082/deletePost.html</code>:<br><img src="https://images.morethink.cn/csrf-attack-fail-failure.gif" alt=""></p><p>前端代码：</p><p>deletePost.html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>deletePost<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function deletePost() &#123;</span></span><br><span class="line"><span class="undefined">            var url = '/post/' + document.getElementById("postId").value;</span></span><br><span class="line"><span class="undefined">            var csrf_token = document.cookie.replace(/(?:(?:^|.*;\s*)csrf_token\s*\=\s*([^;]*).*$)|^.*$/, "$1");</span></span><br><span class="line"><span class="undefined">            console.log('csrf_token=' + csrf_token);</span></span><br><span class="line"><span class="undefined">            $.ajax(&#123;</span></span><br><span class="line"><span class="undefined">                type: "post",//请求方式</span></span><br><span class="line"><span class="undefined">                url: url,  //发送请求地址</span></span><br><span class="line"><span class="undefined">                timeout: 30000,//超时时间：30秒</span></span><br><span class="line"><span class="undefined">                data: &#123;</span></span><br><span class="line"><span class="undefined">                    "_method": "delete",</span></span><br><span class="line"><span class="undefined">                    "csrf_token": hash(csrf_token) // 对csrf_token进行hash加密</span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="undefined">                dataType: "json",//设置返回数据的格式</span></span><br><span class="line"><span class="undefined">                success: function (result) &#123;</span></span><br><span class="line"><span class="undefined">                    if (result.message == "success") &#123;</span></span><br><span class="line"><span class="undefined">//                    window.location.href = "index.html";</span></span><br><span class="line"><span class="undefined">                        $("#result").text("删除成功");</span></span><br><span class="line"><span class="undefined">                    &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                        $("#result").text("删除失败");</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="undefined">                error: function () &#123; //请求出错的处理</span></span><br><span class="line"><span class="undefined">                    $("#result").text("请求出错");</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        // javascript的String到int(32位)的hash算法</span></span><br><span class="line"><span class="undefined">        function hash(str) &#123;</span></span><br><span class="line"><span class="undefined">            var hash = 0;</span></span><br><span class="line"><span class="undefined">            if (str.length == 0) return hash;</span></span><br><span class="line"><span class="undefined">            for (i = 0; i &lt; str.length; i++) &#123;</span></span><br><span class="line"><span class="undefined">                char = str.charCodeAt(i);</span></span><br><span class="line"><span class="undefined">                hash = ((hash &lt;&lt; 5) - hash) + char;</span></span><br><span class="line"><span class="undefined">                hash = hash &amp; hash; // Convert to 32bit integer</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            return hash;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>删除帖子<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">帖子编号 ： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"postId"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"deletePost();"</span>&gt;</span>deletePost<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后台代码：</p><p>UserInterceptor.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.morethink.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.morethink.util.JsonUtil;</span><br><span class="line"><span class="keyword">import</span> cn.morethink.util.Result;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李文浩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/1/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        System.out.println(method);</span><br><span class="line">        <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">"POST"</span>) || method.equalsIgnoreCase(<span class="string">"DELETE"</span>)</span><br><span class="line">                || method.equalsIgnoreCase(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line">            String csrf_token = request.getParameter(<span class="string">"csrf_token"</span>);</span><br><span class="line">            System.out.println(csrf_token + <span class="string">"1222222222222222222222222222222222222222222222"</span>);</span><br><span class="line">            Cookie[] cookies = request.getCookies();</span><br><span class="line">            <span class="keyword">if</span> (cookies != <span class="keyword">null</span> &amp;&amp; cookies.length &gt; <span class="number">0</span> &amp;&amp; csrf_token != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cookie.getName().equals(<span class="string">"csrf_token"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (Integer.valueOf(csrf_token) == cookie.getValue().hashCode()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Result result = <span class="keyword">new</span> Result(<span class="string">"403"</span>, <span class="string">"你还想攻击我??????????"</span>, <span class="string">""</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.write(JsonUtil.toJson(result));</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>cookie必须要设置PATH才可以生效，否则在下一次请求的时候无法带给服务器。</li><li>Spring Boot 出现启动找不到主类的问题时可以mvn clean一下。</li><li>Filter设置response.sendError(403)在Spring Boot没有效果。</li></ol><p><strong>参考文档</strong>：</p><ol><li><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈CSRF攻击方式</a></li><li><a href="http://blog.csdn.net/zzhongcy/article/details/20133883" target="_blank" rel="noopener">jQueue 动态设置form表单的action属性的值和方法</a></li><li><a href="https://www.thinksaas.cn/group/topic/304242/" target="_blank" rel="noopener">javascript的String到int(32位)的hash算法</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目地址： &lt;a href=&quot;https://github.com/morethink/web-security-csrf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/morethink/web-security-csrf&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;CSRF是什么？&quot;&gt;&lt;a href=&quot;#CSRF是什么？&quot; class=&quot;headerlink&quot; title=&quot;CSRF是什么？&quot;&gt;&lt;/a&gt;CSRF是什么？&lt;/h1&gt;&lt;p&gt;CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。&lt;/p&gt;
&lt;h1 id=&quot;CSRF可以做什么？&quot;&gt;&lt;a href=&quot;#CSRF可以做什么？&quot; class=&quot;headerlink&quot; title=&quot;CSRF可以做什么？&quot;&gt;&lt;/a&gt;CSRF可以做什么？&lt;/h1&gt;&lt;p&gt;你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。&lt;/p&gt;
    
    </summary>
    
      <category term="Web安全" scheme="https://www.morethink.cn/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="CSRF" scheme="https://www.morethink.cn/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>Nginx Https配置不带www跳转www</title>
    <link href="https://www.morethink.cn/Nginx-Https-no-www-jump-www/"/>
    <id>https://www.morethink.cn/Nginx-Https-no-www-jump-www/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.183Z</updated>
    
    <content type="html"><![CDATA[<p>把 morethink.cn和www.morethink.cn合并到一个server上去，使用301永久重定向。<br>然后将 <a href="https://morethink.cn" target="_blank" rel="noopener">https://morethink.cn</a> 转到 <a href="https://www.morethink.cn">https://www.morethink.cn</a> 去。不过要在配置文件的 <code>server</code> <a href="https://www.morethink.cn">https://www.morethink.cn</a><br>上配置default_server ssl;。<br>301永久重定向可以把搜索引擎的权重全部集中到 <a href="https://www.morethink.cn">https://www.morethink.cn</a> 上。</p><a id="more"></a><p>配置如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name morethink.cn,www.morethink.cn;</span><br><span class="line">    return 301 https://www.morethink.cn$request_uri;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name morethink.cn;</span><br><span class="line">    return 301 https://www.morethink.cn$request_uri;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 default_server ssl;</span><br><span class="line">    server_name  www.morethink.cn;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate 1_www.morethink.cn_bundle.crt;</span><br><span class="line">    ssl_certificate_key 2_www.morethink.cn.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    root         /var/www/hexo;</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">        location = /40x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考文档</strong>：</p><ol><li><a href="https://cloud.tencent.com/document/product/400/4143" target="_blank" rel="noopener">腾讯云 Nginx Https 证书安装指引</a></li><li><a href="https://docs.lvrui.io/2017/04/01/nginx%E9%85%8D%E7%BD%AEhttp%E5%BC%BA%E5%88%B6%E8%B7%B3%E8%BD%AChttps/" target="_blank" rel="noopener">nginx配置http强制跳转https</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把 morethink.cn和www.morethink.cn合并到一个server上去，使用301永久重定向。&lt;br&gt;然后将 &lt;a href=&quot;https://morethink.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://morethink.cn&lt;/a&gt; 转到 &lt;a href=&quot;https://www.morethink.cn&quot;&gt;https://www.morethink.cn&lt;/a&gt; 去。不过要在配置文件的 &lt;code&gt;server&lt;/code&gt; &lt;a href=&quot;https://www.morethink.cn&quot;&gt;https://www.morethink.cn&lt;/a&gt;&lt;br&gt;上配置default_server ssl;。&lt;br&gt;301永久重定向可以把搜索引擎的权重全部集中到 &lt;a href=&quot;https://www.morethink.cn&quot;&gt;https://www.morethink.cn&lt;/a&gt; 上。&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="https://www.morethink.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Https" scheme="https://www.morethink.cn/tags/Https/"/>
    
      <category term="Nginx" scheme="https://www.morethink.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>面试中的Https</title>
    <link href="https://www.morethink.cn/Https/"/>
    <id>https://www.morethink.cn/Https/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.179Z</updated>
    
    <content type="html"><![CDATA[<p>在Http协议中有可能存在信息窃听或身份伪装的安全问题。使用HTTPS通信机制可以有效地防止这些问题。</p><h1 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h1><h2 id="Http的缺点"><a href="#Http的缺点" class="headerlink" title="Http的缺点"></a>Http的缺点</h2><ul><li>通信使用明文(不加密)，内容可能会被窃听。</li><li>不验证通信方的身份，因此有可能遭遇伪装。</li><li>无法验证报文的完整性，所以有可能已遭篡改。</li></ul><p>这些问题不仅在Http上出现，其他未加密的协议中也会存在这类问题。</p><a id="more"></a><h2 id="什么是Https"><a href="#什么是Https" class="headerlink" title="什么是Https"></a>什么是Https</h2><p>Https并非是应用层的一种新的协议。只是Http通信接口部分用SSL(Secure Socket Layer)和TLS(Transport Layer Security)协议而已。</p><p>通常，Http直接和TCP通信。当使用SSL时，则演变成先和SSL协议通信，再由SSL和TCP通信了。简言之，所谓Https，就是身披SSL这层协议外壳的Http。</p><p><img src="https://images.morethink.cn/0163388a23291dcc361c869f6f8ebc86.png" alt="" title="什么是Https"></p><h2 id="Https有什么作用"><a href="#Https有什么作用" class="headerlink" title="Https有什么作用"></a>Https有什么作用</h2><p><code>Http+加密+认证+完整性保护 = Https</code></p><p>Https有以下作用：</p><ul><li><strong>内容加密</strong> 建立一个信息安全通道，来保证数据传输的安全。</li><li><strong>身份认证</strong> 确认网站的真实性。</li><li><strong>数据完整性</strong> 防止内容被第三方冒充或者篡改。</li></ul><p>下面就是Https的整个架构，现在的https基本都使用TLS了，因为更加安全。</p><h1 id="Https-加密"><a href="#Https-加密" class="headerlink" title="Https 加密"></a>Https 加密</h1><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，<strong>加密密钥和解密密钥是相同的</strong>，所以也称这种加密算法为秘密密钥算法或单密钥算法。</p><p>但是我们使用对称加密加密Http通信内容会有一个问题，因为客户端和服务器在通信过程中都必须知道秘钥，而在发送秘钥的过程中又有可能被第三方监听，从而获取到秘钥。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密很好地解决了对称加密的困难。</p><p>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey），并且加密密钥和解密密钥是成对出现的。非对称加密算法在加密和解密过程使用了不同的密钥，非对称加密也称为公钥加密，在密钥对中，其中一个密钥是对外公开的，所有人都可以获取到，称为公钥，其中一个密钥是不公开的称为私钥。 <strong>用公钥加密的只能用私钥解开，用私钥加密的只能用公钥解开</strong>。</p><p>非对称加密的特性决定了服务器用私钥加密的内容并不是真正的加密，因为公钥所有人都有，所以服务器的密文能被所有人解析。但私钥只掌握在服务器手上，这就带来了两个巨大的优势:</p><ol><li>服务器下发的内容不可能被伪造，因为别人都没有私钥，所以无法加密。强行加密的后果是客户端用公钥无法解开。</li><li>任何人用公钥加密的内容都是绝对安全的，因为私钥只有服务器有，也就是只有真正的服务器可以看到被加密的原文。</li></ol><p><strong>注意</strong>：<br>想要根据密文和公钥，恢复信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。</p><p>因此，Https采用对称加密和非对称加密两者并用的混合加密机制。</p><p><strong>也就是说，Https通过非对称加密来传递对称加密的秘钥</strong>。</p><p>那为什么不直接采用非对称加密来加密通信内容？</p><p>非对称加密处理起来比对称加密更为复杂，因此若在通信时使用非对称加密，效率比较低。</p><h2 id="证书的私钥加密公钥"><a href="#证书的私钥加密公钥" class="headerlink" title="证书的私钥加密公钥"></a>证书的私钥加密公钥</h2><p>遗憾的是，非对称加密还是存在一些问题的。那就是无法保证公钥本身就是货真价实的公钥。比如，正准备和某台服务器建立非对称加密下的通信时，如何证明收到的公钥就是原来预想的那台服务器发行的公钥。或许在公开秘钥传输过程中，真正的公钥已经被人替换了。</p><p>那怎么办？<br>再加密一次。</p><p><strong>每一个使用 HTTPS 的服务器都必须去专门的证书机构注册一个证书，证书中存储了用数字证书机构私钥加密的公钥。这样客户端用数字证书机构的公钥解密就可以了</strong>。</p><p>而数字证书机构的公钥会直接内置在各大操作系统(或者浏览器)的出厂设置里。所以各个公司要先去数字证书机构认证，申请证书，然后操作系统只会存储数字证书机构的公钥。因为数字证书机构数量有限，所以操作系统厂商相对来说容易管理。</p><p><strong>总结</strong>：<br>Https通过非对称加密(通常是RSA算法)加密对称加密的秘钥，然后使用证书机构的私钥加密非对称加密的公钥，而证书机构的公钥会内置在浏览器里，从而保证即使被第三方监听，也可以保证安全。</p><h1 id="SSL-与-TLS"><a href="#SSL-与-TLS" class="headerlink" title="SSL 与 TLS"></a>SSL 与 TLS</h1><h2 id="SSL-Secure-Socket-Layer，安全套接字层"><a href="#SSL-Secure-Socket-Layer，安全套接字层" class="headerlink" title="SSL (Secure Socket Layer，安全套接字层)"></a>SSL (Secure Socket Layer，安全套接字层)</h2><p>SSL为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取，当前为3.0版本。</p><p>SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p><h2 id="TLS-Transport-Layer-Security，传输层安全协议"><a href="#TLS-Transport-Layer-Security，传输层安全协议" class="headerlink" title="TLS (Transport Layer Security，传输层安全协议)"></a>TLS (Transport Layer Security，传输层安全协议)</h2><p>用于两个应用程序之间提供保密性和数据完整性。<br>TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</p><h2 id="SSL-TLS协议作用"><a href="#SSL-TLS协议作用" class="headerlink" title="SSL/TLS协议作用"></a>SSL/TLS协议作用</h2><ul><li>认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>加密数据以防止数据中途被窃取；</li><li>维护数据的完整性，确保数据在传输过程中不被改变。</li></ul><h2 id="TLS比SSL的优势"><a href="#TLS比SSL的优势" class="headerlink" title="TLS比SSL的优势"></a>TLS比SSL的优势</h2><ol><li>对于消息认证使用密钥散列法：TLS 使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC 功能更安全。</li><li>增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。</li><li>改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。</li><li>一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。</li><li>特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。</li></ol><h1 id="SSL-TLS的握手过程"><a href="#SSL-TLS的握手过程" class="headerlink" title="SSL/TLS的握手过程"></a>SSL/TLS的握手过程</h1><p>SSL与TLS握手整个过程如下图所示，下面会详细介绍每一步的具体内容：</p><p><img src="https://images.morethink.cn/ea844ad80d80956a30095d5e4f39fd7b.png" alt="" title="https握手流程图"></p><h2 id="客户端首次发出请求"><a href="#客户端首次发出请求" class="headerlink" title="客户端首次发出请求"></a>客户端首次发出请求</h2><p>由于客户端(如浏览器)对一些加解密算法的支持程度不一样，但是在TLS协议传输过程中必须使用同一套加解密算法才能保证数据能够正常的加解密。在TLS握手阶段，客户端首先要告知服务端，自己支持哪些加密算法，所以客户端需要将本地支持的加密套件(Cipher Suite)的列表传送给服务端。除此之外，客户端还要产生一个随机数，这个随机数一方面需要在客户端保存，另一方面需要传送给服务端，客户端的随机数需要跟服务端产生的随机数结合起来产生后面要讲到的 Master Secret 。</p><p><strong>客户端需要提供如下信息</strong>：</p><ul><li>支持的协议版本，比如TLS 1.0版</li><li>一个客户端生成的随机数，稍后用于生成”对话密钥”</li><li>支持的加密方法，比如RSA公钥加密</li><li>支持的压缩方法</li></ul><h2 id="服务端首次回应"><a href="#服务端首次回应" class="headerlink" title="服务端首次回应"></a>服务端首次回应</h2><p>服务端在接收到客户端的Client Hello之后，服务端需要确定加密协议的版本，以及加密的算法，然后也生成一个随机数，以及将自己的证书发送给客户端一并发送给客户端，这里的随机数是整个过程的第二个随机数。</p><p><strong>服务端需要提供的信息</strong>：</p><ul><li>协议的版本</li><li>加密的算法</li><li>随机数</li><li>服务器证书</li></ul><h2 id="客户端再次回应"><a href="#客户端再次回应" class="headerlink" title="客户端再次回应"></a>客户端再次回应</h2><p>客户端首先会对服务器下发的证书进行验证，验证通过之后，则会继续下面的操作，客户端再次产生一个随机数（第三个随机数），然后使用服务器证书中的公钥进行加密，以及放一个ChangeCipherSpec消息即编码改变的消息，还有整个前面所有消息的hash值，进行服务器验证，然后用新秘钥加密一段数据一并发送到服务器，确保正式通信前无误。</p><p>客户端使用前面的两个随机数以及刚刚新生成的新随机数，使用与服务器确定的加密算法，生成一个Session Secret。</p><h2 id="服务器再次响应"><a href="#服务器再次响应" class="headerlink" title="服务器再次响应"></a>服务器再次响应</h2><p>服务端在接收到客户端传过来的第三个随机数的 加密数据之后，使用私钥对这段加密数据进行解密，并对数据进行验证，也会使用跟客户端同样的方式生成秘钥，一切准备好之后，也会给客户端发送一个 ChangeCipherSpec，告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和 Session Secret加密数据了。之后，服务端也会使用 Session Secret 加密一段 Finish 消息发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。</p><h2 id="后续客户端与服务器间通信"><a href="#后续客户端与服务器间通信" class="headerlink" title="后续客户端与服务器间通信"></a>后续客户端与服务器间通信</h2><p>确定秘钥之后，服务器与客户端之间就会通过商定的秘钥加密消息了，进行通讯了。整个握手过程也就基本完成了。</p><blockquote><p><strong>值得特别提出的是</strong>：</p><p>SSL协议在握手阶段使用的是非对称加密，在传输阶段使用的是对称加密，也就是说在SSL上传送的数据是使用对称密钥加密的！因为非对称加密的速度缓慢，耗费资源。其实当客户端和主机使用非对称加密方式建立连接后，客户端和主机已经决定好了在传输过程使用的对称加密算法和关键的对称加密密钥，由于这个过程本身是安全可靠的，也即对称加密密钥是不可能被窃取盗用的，因此，保证了在传输过程中对数据进行对称加密也是安全可靠的，因为除了客户端和主机之外，不可能有第三方窃取并解密出对称加密密钥！如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。</p></blockquote><h1 id="session的恢复"><a href="#session的恢复" class="headerlink" title="session的恢复"></a>session的恢复</h1><p>有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。</p><h2 id="session-ID"><a href="#session-ID" class="headerlink" title="session ID"></a>session ID</h2><p>session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的”对话密钥”，而不必重新生成一把。</p><p>session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。</p><h2 id="session-ticket"><a href="#session-ticket" class="headerlink" title="session ticket"></a>session ticket</h2><p>客户端发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。</p><p><strong>目前只有Firefox和Chrome浏览器支持</strong>。</p><h1 id="Https的劣势"><a href="#Https的劣势" class="headerlink" title="Https的劣势"></a>Https的劣势</h1><p><strong>对数据进行加解密决定了它比http慢</strong>。需要进行非对称的加解密，且需要三次握手。首次连接比较慢点，当然现在也有很多的优化。</p><p>出于安全考虑，浏览器不会在本地保存HTTPS缓存。实际上，只要在HTTP头中使用特定命令，HTTPS是可以缓存的。Firefox默认只在内存中缓存HTTPS。但是，只要头命令中有Cache-Control: Public，缓存就会被写到硬盘上。 IE只要http头允许就可以缓存https内容，缓存策略与是否使用HTTPS协议无关。</p><h1 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h1><ul><li>https协议需要到CA申请证书。</li><li>http是超文本传输协议，信息是明文传输；https 则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li><li>http默认使用80端口，https默认使用443端口</li></ul><h1 id="Python等爬虫怎么处理Https"><a href="#Python等爬虫怎么处理Https" class="headerlink" title="Python等爬虫怎么处理Https"></a>Python等爬虫怎么处理Https</h1><p>https拿爬虫毫无办法，或者说https就不是为了反爬虫的。https的作用是保证服务源授信。比如你访问支付宝，网络被劫持了，你看到的就是个假网站，一旦你登录，账号就泄露了。但用https就能保证你访问的一定是真的支付宝网站，这是由CA证书保证的。回过来再说爬虫，爬虫伪造的是客户端，https是不能保证客户端是授信的，你只要按照ssl协议进行通信，该怎么爬数据还是怎么爬。</p><p>https协议里数据的传输是需要经过加密的,在这个过程中，就给爬虫带来了抓包问题，抓出来的数据也是经过加密的，不能解析。</p><p>理论上是不行了，因为https保证的就是数据在传输过程中不会被盗取。但解决起来也很简单，就是设置个代理伪装一下，代价就是你要安装个假证书，当然这也肯定是无所谓的。</p><p><strong>参考文档</strong>：</p><ol><li><a href="http://www.wxtlife.com/2016/03/27/详解https是如何确保安全的？/" target="_blank" rel="noopener">详解https是如何确保安全的？</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></li><li><a href="http://fullstack.blog/2017/03/12/%E4%B9%9D%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E6%82%89HTTPS/#" target="_blank" rel="noopener">九个问题从入门到熟悉HTTPS</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></li><li><a href="https://www.zhihu.com/question/54504923" target="_blank" rel="noopener">爬虫 https python？</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Http协议中有可能存在信息窃听或身份伪装的安全问题。使用HTTPS通信机制可以有效地防止这些问题。&lt;/p&gt;
&lt;h1 id=&quot;Https&quot;&gt;&lt;a href=&quot;#Https&quot; class=&quot;headerlink&quot; title=&quot;Https&quot;&gt;&lt;/a&gt;Https&lt;/h1&gt;&lt;h2 id=&quot;Http的缺点&quot;&gt;&lt;a href=&quot;#Http的缺点&quot; class=&quot;headerlink&quot; title=&quot;Http的缺点&quot;&gt;&lt;/a&gt;Http的缺点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通信使用明文(不加密)，内容可能会被窃听。&lt;/li&gt;
&lt;li&gt;不验证通信方的身份，因此有可能遭遇伪装。&lt;/li&gt;
&lt;li&gt;无法验证报文的完整性，所以有可能已遭篡改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些问题不仅在Http上出现，其他未加密的协议中也会存在这类问题。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="https://www.morethink.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Https" scheme="https://www.morethink.cn/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>面试中的DNS</title>
    <link href="https://www.morethink.cn/DNS/"/>
    <id>https://www.morethink.cn/DNS/</id>
    <published>2017-12-25T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。</p><p>DNS基于UDP服务，端口53。该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。</p><a id="more"></a><h1 id="递归查询与迭代查询"><a href="#递归查询与迭代查询" class="headerlink" title="递归查询与迭代查询"></a>递归查询与迭代查询</h1><h2 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h2><p>递归查询是一种DNS 服务器的查询模式，在该模式下DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS 服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。</p><p><img src="https://images.morethink.cn/af0045f9f3bdd144a2afc434cb8146f7.png" alt="" title="DNS递归查询"></p><h2 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h2><p>DNS 服务器另外一种查询方式为迭代查询，DNS 服务器会向客户机提供其他能够解析查询请求的DNS 服务器地址，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台DNS 服务器地址，客户机再向这台DNS 服务器提交请求，依次循环直到返回查询的结果为止。<br><img src="https://images.morethink.cn/9550ed36f993d88f2d54e5d9c6c9f487.png" alt="" title="DNS迭代查询"></p><p><strong>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询</strong>。</p><h1 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h1><p>DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。</p><p>DNS劫持症状：在某些地区的用户在成功连接宽带后，首次打开任何页面都指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。</p><p><strong>解决方法</strong></p><p>对于DNS劫持，可以采用使用国外免费公用的DNS服务器解决。例如OpenDNS（208.67.222.222）或GoogleDNS（8.8.8.8）。</p><p><strong>总结</strong></p><p>DNS劫持就是指用户访问一个被标记的地址时，DNS服务器故意将此地址指向一个错误的IP地址的行为。范例，网通、电信、铁通的某些用户有时候会发现自己打算访问一个地址，却被转向了各种推送广告等网站，这就是DNS劫持。</p><h1 id="DNS污染"><a href="#DNS污染" class="headerlink" title="DNS污染"></a>DNS污染</h1><p>DNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。</p><p>其工作方式是：由于通常的DNS查询没有任何认证机制，而且DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改，通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。</p><p>DNS污染发生在用户请求的第一步上，直接从协议上对用户的DNS请求进行干扰。<br>DNS污染症状：目前一些被禁止访问的网站很多就是通过DNS污染来实现的，例如YouTube、Facebook等网站。</p><p><strong>解决办法</strong>：</p><p>对于DNS污染，可以说，个人用户很难单单靠设置解决，通常可以使用VPN或者域名远程解析的方法解决，但这大多需要购买付费的VPN或SSH等，也可以通过修改Hosts的方法，手动设置域名正确的IP地址。</p><p><strong>总结</strong>：</p><p>DNS污染，指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。范例，访问Youtube、Facebook之类网站等出现的状况。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DNS&quot;&gt;&lt;a href=&quot;#DNS&quot; class=&quot;headerlink&quot; title=&quot;DNS&quot;&gt;&lt;/a&gt;DNS&lt;/h1&gt;&lt;p&gt;当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。&lt;/p&gt;
&lt;p&gt;DNS基于UDP服务，端口53。该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="https://www.morethink.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Java使用Openoffice将word、ppt转换为PDF</title>
    <link href="https://www.morethink.cn/Java-openoffice-pdf/"/>
    <id>https://www.morethink.cn/Java-openoffice-pdf/</id>
    <published>2017-12-24T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.180Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目中要实现WORD的文件预览功能，我们可以通过将WORD转换成PDF或者HTML，然后通过浏览器预览。</p><h1 id="OpenOffice"><a href="#OpenOffice" class="headerlink" title="OpenOffice"></a>OpenOffice</h1><p>OpenOffice.org 是一套跨平台的办公室软件套件，能在 Windows、Linux、MacOS X (X11)、和 Solaris 等操作系统上执行。它与各个主要的办公室软件套件兼容。OpenOffice.org 是自由软件，任何人都可以免费下载、使用、及推广它。</p><a id="more"></a><p><strong>下载地址</strong></p><p><a href="http://www.openoffice.org/" target="_blank" rel="noopener">http://www.openoffice.org/</a></p><h1 id="JodConverter"><a href="#JodConverter" class="headerlink" title="JodConverter"></a>JodConverter</h1><p>jodconverter-2.2.2.zip 下载地址：<br><a href="http://sourceforge.net/projects/jodconverter/files/JODConverter/" target="_blank" rel="noopener">http://sourceforge.net/projects/jodconverter/files/JODConverter/</a></p><h1 id="Word转换"><a href="#Word转换" class="headerlink" title="Word转换"></a>Word转换</h1><p><strong>启动OpenOffice的服务</strong></p><p>进入openoffice安装目录，通过cmd启动一个soffice服务，启动的命令是<code>soffice -headless -accept=&quot;socket,host=127.0.0.1,port=8100;urp;&quot;</code>。</p><p>如果觉得后台运行OpenOffice服务比较麻烦，可以通过</p><h1 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PDFDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">officeToPDF</span><span class="params">(String sourceFile, String destFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            File inputFile = <span class="keyword">new</span> File(sourceFile);</span><br><span class="line">            <span class="keyword">if</span> (!inputFile.exists()) &#123;</span><br><span class="line">                <span class="comment">// 找不到源文件, 则返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果目标路径不存在, 则新建该路径</span></span><br><span class="line">            File outputFile = <span class="keyword">new</span> File(destFile);</span><br><span class="line">            <span class="keyword">if</span> (!outputFile.getParentFile().exists()) &#123;</span><br><span class="line">                outputFile.getParentFile().mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果目标文件存在，则删除</span></span><br><span class="line">            <span class="keyword">if</span> (outputFile.exists()) &#123;</span><br><span class="line">                outputFile.delete();</span><br><span class="line">            &#125;</span><br><span class="line">            DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm"</span>);</span><br><span class="line">            OpenOfficeConnection connection = <span class="keyword">new</span> SocketOpenOfficeConnection(<span class="string">"127.0.0.1"</span>, <span class="number">8100</span>);</span><br><span class="line">            connection.connect();</span><br><span class="line">            <span class="comment">//用于测试openOffice连接时间</span></span><br><span class="line">            System.out.println(<span class="string">"连接时间:"</span> + df.format(<span class="keyword">new</span> Date()));</span><br><span class="line">            DocumentConverter converter = <span class="keyword">new</span> StreamOpenOfficeDocumentConverter(</span><br><span class="line">                    connection);</span><br><span class="line">            converter.convert(inputFile, outputFile);</span><br><span class="line">            <span class="comment">//测试word转PDF的转换时间</span></span><br><span class="line">            System.out.println(<span class="string">"转换时间:"</span> + df.format(<span class="keyword">new</span> Date()));</span><br><span class="line">            connection.disconnect();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ConnectException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.err.println(<span class="string">"openOffice连接失败！请检查IP,端口"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        officeToPDF(<span class="string">"E:\\test.docx"</span>, <span class="string">"E:\\test.pdf"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Word、ppt转Html"><a href="#Word、ppt转Html" class="headerlink" title="Word、ppt转Html"></a>Word、ppt转Html</h1><p>只需要将后缀名从<code>.pdf</code>改为<code>.html</code>即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    officeToPDF(<span class="string">"E:\\test.docx"</span>, <span class="string">"E:\\test.html"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h1><p><strong>Maven依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.artofsolving<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jodconverter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openoffice<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jurt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openoffice<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ridl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openoffice<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>juh<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openoffice<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>unoil<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-jdk14<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Maven只有 2.2.1版本，2.2.1版本有一个问题，那就是不兼容docx和pptx，如果你们不使用jodconverter-2.2.2 中lib，而想要使用2.2.1版本，需要修改一下 <code>BasicDocumentFormatRegistry</code> 类中的 <code>getFormatByFileExtension</code>方法：</p><ol><li>新建包 <code>com.artofsolving.jodconverter</code></li><li>新建类<code>BasicDocumentFormatRegistry</code>，复制下面代码</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.artofsolving.jodconverter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李文浩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/12/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicDocumentFormatRegistry</span> <span class="keyword">implements</span> <span class="title">DocumentFormatRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List documentFormats = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicDocumentFormatRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDocumentFormat</span><span class="params">(DocumentFormat documentFormat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.documentFormats.add(documentFormat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List <span class="title">getDocumentFormats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.documentFormats;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DocumentFormat <span class="title">getFormatByFileExtension</span><span class="params">(String extension)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (extension == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extension.indexOf(<span class="string">"doc"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                extension = <span class="string">"doc"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (extension.indexOf(<span class="string">"ppt"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                extension = <span class="string">"ppt"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (extension.indexOf(<span class="string">"xls"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                extension = <span class="string">"xls"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String lowerExtension = extension.toLowerCase();</span><br><span class="line">            Iterator it = <span class="keyword">this</span>.documentFormats.iterator();</span><br><span class="line"></span><br><span class="line">            DocumentFormat format;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!it.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                format = (DocumentFormat)it.next();</span><br><span class="line">            &#125; <span class="keyword">while</span>(!format.getFileExtension().equals(lowerExtension));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> format;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DocumentFormat <span class="title">getFormatByMimeType</span><span class="params">(String mimeType)</span> </span>&#123;</span><br><span class="line">        Iterator it = <span class="keyword">this</span>.documentFormats.iterator();</span><br><span class="line"></span><br><span class="line">        DocumentFormat format;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!it.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            format = (DocumentFormat)it.next();</span><br><span class="line">        &#125; <span class="keyword">while</span>(!format.getMimeType().equals(mimeType));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> format;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是增加的部分，仅仅增加了将docx按照doc的处理方式处理。而2.2.2版本已经默认增加了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (extension.indexOf(<span class="string">"doc"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    extension = <span class="string">"doc"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (extension.indexOf(<span class="string">"ppt"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    extension = <span class="string">"ppt"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (extension.indexOf(<span class="string">"xls"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    extension = <span class="string">"xls"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考文档</strong>：</p><ol><li><a href="http://blog.csdn.net/yjclsx/article/details/51445546" target="_blank" rel="noopener">Java实现在线预览–openOffice实现</a></li><li><a href="http://blog.csdn.net/qq_33571718/article/details/51154472" target="_blank" rel="noopener">Java项目中使用OpenOffice转PDF</a></li><li><a href="http://blog.csdn.net/make_a_difference/article/details/53771136###;" target="_blank" rel="noopener">java使用openoffice将office系列文档转换为PDF</a></li><li><a href="http://www.cnblogs.com/xxyfhjl/p/6773786.html" target="_blank" rel="noopener">java 如何将 word,excel,ppt如何转pdf–jacob</a></li><li><a href="http://www.cnblogs.com/xxyfhjl/p/6775137.html" target="_blank" rel="noopener">java 如何将 word,excel,ppt如何转pdf –openoffice (1)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近项目中要实现WORD的文件预览功能，我们可以通过将WORD转换成PDF或者HTML，然后通过浏览器预览。&lt;/p&gt;
&lt;h1 id=&quot;OpenOffice&quot;&gt;&lt;a href=&quot;#OpenOffice&quot; class=&quot;headerlink&quot; title=&quot;OpenOffice&quot;&gt;&lt;/a&gt;OpenOffice&lt;/h1&gt;&lt;p&gt;OpenOffice.org 是一套跨平台的办公室软件套件，能在 Windows、Linux、MacOS X (X11)、和 Solaris 等操作系统上执行。它与各个主要的办公室软件套件兼容。OpenOffice.org 是自由软件，任何人都可以免费下载、使用、及推广它。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.morethink.cn/categories/Java/"/>
    
    
      <category term="PDF" scheme="https://www.morethink.cn/tags/PDF/"/>
    
  </entry>
  
  <entry>
    <title>面试中的TCP协议</title>
    <link href="https://www.morethink.cn/TCP/"/>
    <id>https://www.morethink.cn/TCP/</id>
    <published>2017-12-15T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP连接是通过三次握手来连接的。</p><p><strong>第一次握手</strong></p><p>当客户端向服务器发起连接请求时，客户端会发送同步序列标号<code>SYN</code>到服务器，在这里我们设<code>SYN</code>为x，等待服务器确认，这时客户端的状态为<code>SYN_SENT</code>。</p><a id="more"></a><p><strong>第二次握手</strong></p><p>当服务器收到客户端发送的<code>SYN</code>后，服务器要做的是确认客户端发送过来的<code>SYN</code>，在这里服务器发送确认包<code>ACK</code>，这里的<code>ACK</code>为x+1，意思是说“我收到了你发送的<code>SYN</code>了”，同时，服务器也会向客户端发送一个<code>SYN</code>包，这里我们设<code>SYN</code>为y。这时服务器的状态为<code>SYN_RECV</code>。</p><p>一句话，服务器端发送<code>SYN</code>和<code>ACK</code>两个包。</p><p><strong>第三次握手</strong></p><p>客户端收到服务器发送的<code>SYN</code>和<code>ACK</code>包后，需向服务器发送确认包<code>ACK</code>，“我也收到你发送的<code>SYN</code>了，我这就给你发个确认过去，然后我们即能合体了”，这里的<code>ACK</code>为y+1，发送完毕后，客户端和服务器的状态为<code>ESTABLISH</code>，即TCP连接成功。</p><p>在三次握手中，客户端和服务器端都发送两个包<code>SYN</code>和<code>ACK</code>，只不过服务器端的两个包是一次性发过来的，客户端的两个包是分两次发送的。</p><p><img src="https://images.morethink.cn/092017231747399.jpg" alt="" title="TCP的三次握手和四次挥手"></p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>当A端和B端要断开连接时，需要四次握手，这里称为四次挥手。</p><p>断开连接请求可以由客户端发出，也可以由服务器端发出，在这里我们称A端向B端请求断开连接。</p><p><strong>第一次挥手</strong></p><p>A端向B端请求断开连接时会向B端发送一个带有<code>FIN</code>标记的报文段，这里的<code>FIN</code>是<code>Finish</code>的意思。</p><p><strong>第二次挥手</strong></p><p>B端收到A发送的<code>FIN</code>后，B段现在可能现在还有数据没有传完，所以B端并不会马上向A端发送<code>FIN</code>，而是先发送一个确认序号<code>ACK</code>，意思是说“你发的断开连接请求我收到了，但是我现在还有数据没有发完，请稍等一下呗”。</p><p><strong>第三次挥手</strong></p><p>当B端的事情忙完了，那么此时B端就可以断开连接了，此时B端向A端发送<code>FIN</code>序号，意思是这次可以断开连接了。</p><p><strong>第四次挥手</strong></p><p>A端收到B端发送的<code>FIN</code>后，会向B端发送确认<code>ACK</code>，然后经过两个MSL时长后断开连接。</p><p>MSL是Maximum Segment Lifetime，最大报文段生存时间，2个MSL是报文段发送和接收的最长时间。</p><h2 id="两次握手可以么？"><a href="#两次握手可以么？" class="headerlink" title="两次握手可以么？"></a>两次握手可以么？</h2><p>TCP连接时是三次握手，那么两次握手可行吗？</p><p>在《计算机网络》中是这样解释的：已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送<code>ACK</code>包。这样就会白白浪费资源。</p><p>而经过三次握手，客户端和服务器都有应有答，这样可以确保TCP正确连接。</p><h2 id="为什么TCP连接是三次，挥手确是四次？"><a href="#为什么TCP连接是三次，挥手确是四次？" class="headerlink" title="为什么TCP连接是三次，挥手确是四次？"></a>为什么TCP连接是三次，挥手确是四次？</h2><p>在TCP连接中，服务器端的<code>SYN</code>和<code>ACK</code>向客户端发送是一次性发送的，而在断开连接的过程中，B端向A端发送的<code>ACK</code>和<code>FIN</code>是是分两次发送的。因为在B端接收到A端的<code>FIN</code>后，B端可能还有数据要传输，所以先发送<code>ACK</code>，等B端处理完自己的事情后就可以发送<code>FIN</code>断开连接了。</p><h2 id="为什么在第四次挥手后会有2个MSL的延时？"><a href="#为什么在第四次挥手后会有2个MSL的延时？" class="headerlink" title="为什么在第四次挥手后会有2个MSL的延时？"></a>为什么在第四次挥手后会有2个MSL的延时？</h2><p>前文说到:<br>MSL是Maximum Segment Lifetime，最大报文段生存时间，2个MSL是报文段发送和接收的最长时间。</p><p>假定网络不可靠，那么第四次发送的<code>ACK</code>可能丢失，即B端无法收到这个<code>ACK</code>，如果B端收不到这个确认<code>ACK</code>，B端会定时向A端重复发送<code>FIN</code>，直到B端收到A的确认<code>ACK</code>。所以这个2MSL就是用来处理这个可能丢失的<code>ACK</code>的。</p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。</p><p>ack通常被理解为收到数据后给出的一个确认，事实上该确认是指接收端已经收到确认帧以前的所有的帧。举个例子，假如接收端收到 1-1024字节，它会发送一个确认号为1025的ACK，但是接下来收到的是2049-3072，它是不会发送确认号为3072的ACK,而依旧发送 1025的ACK。</p><p>滑动窗口协议如图所示：<br><img src="https://images.morethink.cn/cf6a1ce659c9b81d49a4ae3ccc3c2df5.png" alt="" title="滑动窗口协议"></p><p>在这个图中，我们将字节从1至11进行标号。接收方通告的窗口称为提出的窗口，它覆盖了从第4字节到第9字节的区域，表明接收方已经确认了包括第3字节在内的数据，且通告窗口大小为6。我们知道窗口大小是与确认序号相对应的。发送方计算它的可用窗口，该窗口表明多少数据可以立即被发送。当接收方确认数据后，这个滑动窗口不时地向右移动。窗口两个边沿的相对运动增加或减少了窗口的大小。我们使用三个术语来描述窗口左右边沿的运动：</p><ul><li>窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时。</li><li>当窗口右边沿向右移动时将允许发送更多的数据，我们称之为窗口张开。这种现象发生在另一端的接收进程读取已经确认的数据并释放了T C P的接收缓存时。</li><li>当右边缘向左移动时，称之为窗口收缩。</li></ul><p>每个TCP连接有发送窗口和接收窗口这两个窗口。</p><p>TCP是双工的协议，会话的双方都可以同时接收、发送数据。</p><p>TCP会话的双方都各自维护一个“发送窗口”和一个“接收窗口”。其中各自的“接收窗口”大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的“发送窗口”则要求取决于对端通告的“接收窗口”，要求相同。</p><h1 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h1><p>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方可能来不及接收，这就会造成数据的丢失。所谓 <strong>流量控制(flow contrl)</strong> 就是 <strong>让发送方的发送速率不要太快，要让接收方来得及接收</strong> 。</p><p>TCP利用滑动窗口机制实现对发送方的流量控制，发送方的发送窗口不可以大于接收方给出的接收窗口的大小。窗口两个边沿的相对运动增加或减少了窗口的大小。当接收方没有缓存可用，会发送零窗口大小的报文，此时发送方不能够发送任何数据。</p><p>TCP的窗口单位是字节，不是报文段。</p><h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><p>在计算机网络中的链路容量(即带宽)、交换节点中的缓存和处理机等，都是网络中的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏。这种情况就叫做 <strong>拥塞</strong>。</p><p><strong>拥塞控制</strong> 就是 <strong>防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载</strong>。</p><p>拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。</p><p>进行拥塞控制的四种算法：</p><ol><li>慢开始（Slow-start)</li><li>拥塞避免（Congestion Avoidance)</li><li>快重传（Fast Restrangsmit)</li><li>快恢复（Fast Recovery）。</li></ol><h2 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h2><p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。</p><p>慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。在一开始发送方先设置cwnd=1，<strong>每经过一次传输轮次之后拥塞窗口就加倍（2的指数倍增加）</strong>。</p><p>为了防止窗口cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：</p><ul><li>当cwnd&lt;ssthresh时，使用慢开始算法。</li><li>当cwnd&gt;ssthresh时，改用拥塞避免算法。</li><li>当cwnd=ssthresh时，既可使用慢开始算法，也可使用拥塞算法。</li></ul><p>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。<strong>这样拥塞窗口按线性规律缓慢增长</strong>，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（<strong>其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理</strong>），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。</p><p><img src="https://images.morethink.cn/13101915439696.jpg" alt="" title="慢开始和拥塞避免"></p><h2 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h2><p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。由于发送方能 <strong>尽早重传未被确认的报文段</strong>，因此采用快重传算法后可以使整个网络的吞吐量提高约20%。</p><p>快恢复算法，有以下两个要点:</p><ol><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。<strong>但是接下去并不执行慢开始算法</strong>。</li><li><strong>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法</strong>。</li></ol><p><img src="https://images.morethink.cn/c6f967f1bbd18ddafcfef14669c8fca7.png" alt="" title="快重传和快恢复算法"></p><h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><ul><li>TCP面向连接，UDP面向非连接即发送数据前不需要建立链接。<ul><li>面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。</li><li>非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。</li></ul></li><li>TCP提供可靠的服务（数据传输），UDP无法保证。</li><li>TCP面向字节流，UDP面向报文。</li><li>TCP数据传输慢，UDP数据传输快。</li></ul><p><strong>注意</strong>：</p><p>TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p><h1 id="TCP、UDP对应的协议"><a href="#TCP、UDP对应的协议" class="headerlink" title="TCP、UDP对应的协议"></a>TCP、UDP对应的协议</h1><h2 id="TCP对应的协议"><a href="#TCP对应的协议" class="headerlink" title="TCP对应的协议"></a>TCP对应的协议</h2><ol><li>FTP：定义了文件传输协议，使用21端口。</li><li>Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</li><li>SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。</li><li>POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。</li><li>HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。</li></ol><h2 id="UDP对应的协议"><a href="#UDP对应的协议" class="headerlink" title="UDP对应的协议"></a>UDP对应的协议</h2><ol><li>DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</li><li>SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li><li>TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</li></ol><h1 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a><code>SYN</code>攻击</h1><h2 id="什么是-SYN-攻击（SYN-Flood）？"><a href="#什么是-SYN-攻击（SYN-Flood）？" class="headerlink" title="什么是 SYN 攻击（SYN Flood）？"></a>什么是 <code>SYN</code> 攻击（SYN Flood）？</h2><p>在三次握手过程中，服务器发送 <code>SYN-ACK</code> 之后，收到客户端的 <code>ACK</code> 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 <code>SYN_RCVD</code> 状态。当收到 ACK 后，服务器才能转入 <code>ESTABLISHED</code> 状态.</p><p><code>SYN</code>攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送<code>SYN</code>包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的<code>SYN</code>包将长时间占用未连接队列，正常的<code>SYN</code>请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p><p><code>SYN</code> 攻击是一种典型的 <code>DoS/DDoS</code> 攻击。</p><h2 id="如何检测-SYN-攻击？"><a href="#如何检测-SYN-攻击？" class="headerlink" title="如何检测 SYN 攻击？"></a>如何检测 <code>SYN</code> 攻击？</h2><p>检测 <code>SYN</code> 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次<code>SYN</code>攻击。在 <code>Linux/Unix</code> 上可以使用系统自带的 <code>netstats</code> 命令来检测 <code>SYN</code> 攻击。</p><h2 id="如何防御-SYN-攻击？"><a href="#如何防御-SYN-攻击？" class="headerlink" title="如何防御 SYN 攻击？"></a>如何防御 <code>SYN</code> 攻击？</h2><p><code>SYN</code>攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻<code>SYN</code>攻击的危害，常见的防御<code>SYN</code> 攻击的方法有如下几种：</p><ul><li>缩短超时（<code>SYN</code> Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li><code>SYN</code> cookies技术</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP的三次握手和四次挥手&quot;&gt;&lt;a href=&quot;#TCP的三次握手和四次挥手&quot; class=&quot;headerlink&quot; title=&quot;TCP的三次握手和四次挥手&quot;&gt;&lt;/a&gt;TCP的三次握手和四次挥手&lt;/h1&gt;&lt;h2 id=&quot;三次握手&quot;&gt;&lt;a href=&quot;#三次握手&quot; class=&quot;headerlink&quot; title=&quot;三次握手&quot;&gt;&lt;/a&gt;三次握手&lt;/h2&gt;&lt;p&gt;TCP连接是通过三次握手来连接的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一次握手&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当客户端向服务器发起连接请求时，客户端会发送同步序列标号&lt;code&gt;SYN&lt;/code&gt;到服务器，在这里我们设&lt;code&gt;SYN&lt;/code&gt;为x，等待服务器确认，这时客户端的状态为&lt;code&gt;SYN_SENT&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="https://www.morethink.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="面试" scheme="https://www.morethink.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>单点登录原理与简单实现</title>
    <link href="https://www.morethink.cn/sso/"/>
    <id>https://www.morethink.cn/sso/</id>
    <published>2017-12-15T16:00:00.000Z</published>
    <updated>2018-03-31T05:41:05.668Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自： <a href="https://www.cnblogs.com/ywlaker/p/6113927.html" target="_blank" rel="noopener">https://www.cnblogs.com/ywlaker/p/6113927.html</a></p><blockquote><p>作者：凌承一<br>出处：<a href="http://www.cnblogs.com/ywlaker/" target="_blank" rel="noopener">http://www.cnblogs.com/ywlaker/</a><br>声明：本文版权归作者和博客园共有，欢迎转载，但转载必须保留此段声明，并在文章页面明显位置给出原文链接，否则作者将保留追究法律责任的权利。</p></blockquote><h1 id="单系统登录机制"><a href="#单系统登录机制" class="headerlink" title="单系统登录机制"></a>单系统登录机制</h1><p>web应用采用browser/server架构，http作为通信协议。http是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系。</p><p><img src="https://images.morethink.cn/02c5bff6aa0c8a04bbda6261bb0fbd7f.png" alt="" title="无状态的Http协议"></p><a id="more"></a><p>但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然http协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制。</p><h2 id="会话机制"><a href="#会话机制" class="headerlink" title="会话机制"></a>会话机制</h2><p>浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器，浏览器存储会话id，并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联。</p><p><img src="https://images.morethink.cn/41970737be124812ef2b457d33aa38df.png" alt="" title="会话机制"></p><p>服务器在内存中保存会话对象，浏览器怎么保存会话id呢？</p><p>你可能会想到两种方式</p><ul><li>请求参数</li><li>cookie</li></ul><p>将会话id作为每一个请求的参数，服务器接收请求自然能解析参数获得会话id，并借此判断是否来自同一会话，很明显，这种方式不靠谱。那就浏览器自己来维护这个会话id吧，每次发送http请求时浏览器自动发送会话id，cookie机制正好用来做这件事。cookie是浏览器用来存储少量数据的一种机制，数据以”key/value”形式存储，浏览器发送http请求时自动附带cookie信息。</p><p>tomcat会话机制当然也实现了cookie，访问tomcat服务器时，浏览器中可以看到一个名为<code>JSESSIONID</code>的cookie，这就是tomcat会话机制维护的会话id，使用了cookie的请求响应过程如下图：</p><p><img src="https://images.morethink.cn/61273ed59b80ddef53862a0cba5f83a0.png" alt="" title="JSESSIONID"></p><h2 id="登录状态"><a href="#登录状态" class="headerlink" title="登录状态"></a>登录状态</h2><p>有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat在会话对象中设置登录状态如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setAttribute(<span class="string">"isLogin"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>用户再次访问时，tomcat在会话对象中查看登录状态：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.getAttribute(<span class="string">"isLogin"</span>);</span><br></pre></td></tr></table></figure><p>实现了登录状态的浏览器请求服务器模型如下图描述：</p><p><img src="https://images.morethink.cn/39ec3914d68cc400fab2d251d84370e6.png" alt="" title="登录状态控制"></p><p>每次请求受保护资源时都会检查会话对象中的登录状态，只有 <code>isLogin=true</code> 的会话才能访问，登录机制因此而实现。</p><h1 id="多系统的复杂性"><a href="#多系统的复杂性" class="headerlink" title="多系统的复杂性"></a>多系统的复杂性</h1><p>web系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样</p><p><img src="https://images.morethink.cn/1c722018d9dfd78b8623a1c5c50cd740.png" alt="" title="多系统"></p><p><strong>web系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了</strong>。</p><p><img src="https://images.morethink.cn/33e912634f234d469982fd25afac8e2a.png" alt="" title="单系统的登录"></p><p><strong><em>虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？</em></strong></p><p>单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie。</p><p><img src="https://images.morethink.cn/3d3db13c2cab0ba0863b8ecfe4c3f7b2.png" alt="" title="夸域名"></p><h2 id="子域名cookie共享完成单点登录"><a href="#子域名cookie共享完成单点登录" class="headerlink" title="子域名cookie共享完成单点登录"></a>子域名cookie共享完成单点登录</h2><p>既然这样，为什么不将web应用群中所有子系统的域名统一在一个顶级域名下，例如“<code>*.baidu.com</code>”，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。</p><p>然而，可行并不代表好，共享cookie的方式存在众多局限。</p><ol><li>首先，应用群域名得统一。</li><li>其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间。</li><li>第三，cookie本身不安全。</li></ol><p>除上面之外，如果我们在<code>session</code>存放的是<code>User</code>对象，那么我们使用全局cookie共享<code>JSESSIONID</code>值，每一个子域名就可以访问同一个session，登录成功后保存一个user对象，注销后就移除这个user对象。session中的user对象必须先序列化保存到redis中，并且每次访问的时候，都需要去redis中取出session，并且重新序列化成user对象。<strong>这样会造成额外的消耗</strong>。</p><p>因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。</p><h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1><p><strong>什么是单点登录</strong>？</p><p>单点登录全称Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分。</p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。</p><p>这个过程，也就是单点登录的原理，用下图说明：</p><p><img src="https://images.morethink.cn/797930-20161203152650974-276822362.png" alt="" title="单点登录"></p><p>下面对上图简要描述：</p><ol><li>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数。</li><li>sso认证中心发现用户未登录，将用户引导至登录页面。</li><li>用户输入用户名密码提交登录申请。</li><li>sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌。</li><li>sso认证中心带着令牌跳转会最初的请求地址（系统1）。</li><li>系统1拿到令牌，去sso认证中心校验令牌是否有效。</li><li>sso认证中心校验令牌，返回有效，注册系统1。</li><li>系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源。</li><li>用户访问系统2的受保护资源。</li><li>系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数。</li><li>sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌。</li><li>系统2拿到令牌，去sso认证中心校验令牌是否有效。</li><li>sso认证中心校验令牌，返回有效，注册系统2。</li><li>系统2使用该令牌创建与用户的局部会话，返回受保护资源。</li></ol><p>用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系：</p><ul><li>局部会话存在，全局会话一定存在。</li><li>全局会话存在，局部会话不一定存在。</li><li>全局会话销毁，局部会话必须销毁。</li></ul><p>你可以通过博客园、百度、csdn、淘宝等网站的登录过程加深对单点登录的理解，注意观察登录过程中的跳转url与参数</p><h2 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h2><p>单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明：</p><p><img src="https://images.morethink.cn/797930-20161129155242271-222889796.png" alt="" title="单点注销"></p><p>sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作</p><p>下面对上图简要说明：</p><ol><li>用户向系统1发起注销请求。</li><li>系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求。</li><li>sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址。</li><li>sso认证中心向所有注册系统发起注销请求。</li><li>各注册系统接收sso认证中心的注销请求，销毁局部会话。</li><li>sso认证中心引导用户至登录页面。</li></ol><h2 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h2><p>单点登录涉及sso认证中心与众子系统，子系统与sso认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成sso的客户端，sso认证中心则是sso服务端，整个单点登录过程实质是sso客户端与服务端通信的过程，用下图描述：</p><p><img src="https://images.morethink.cn/797930-20161129155244646-2067469767.png" alt="" title="部署图"></p><p>sso认证中心与sso客户端通信方式有多种，这里以简单好用的httpClient为例，web service、rpc、restful api都可以。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>只是简要介绍下基于java的实现过程，不提供完整源码，明白了原理，我相信你们可以自己实现。sso采用客户端/服务端架构，我们先看sso-client与sso-server要实现的功能（下面：sso认证中心=sso-server）。</p><h3 id="sso-client"><a href="#sso-client" class="headerlink" title="sso-client"></a>sso-client</h3><ol><li>拦截子系统未登录用户请求，跳转至sso认证中心。</li><li>接收并存储sso认证中心发送的令牌。</li><li>与sso-server通信，校验令牌的有效性。</li><li>建立局部会话。</li><li>拦截用户注销请求，向sso认证中心发送注销请求。</li><li>接收sso认证中心发出的注销请求，销毁局部会话。</li></ol><h3 id="sso-server"><a href="#sso-server" class="headerlink" title="sso-server"></a>sso-server</h3><ol><li>验证用户的登录信息。</li><li>创建全局会话。</li><li>创建授权令牌。</li><li>与sso-client通信发送令牌。</li><li>校验sso-client令牌有效性。</li><li>系统注册。</li><li>接收sso-client注销请求，注销所有会话。</li></ol><p>接下来，我们按照原理来一步步实现sso吧！</p><h2 id="sso-client拦截未登录请求"><a href="#sso-client拦截未登录请求" class="headerlink" title="sso-client拦截未登录请求"></a>sso-client拦截未登录请求</h2><p>java拦截请求的方式有servlet、filter、listener三种方式，我们采用filter。在sso-client中新建LoginFilter.java类并实现Filter接口，在doFilter()方法中加入对未登录用户的拦截：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">    HttpServletResponse res = (HttpServletResponse) response;</span><br><span class="line">    HttpSession session = req.getSession();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (session.getAttribute(<span class="string">"isLogin"</span>)) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳转至sso认证中心</span></span><br><span class="line">    res.sendRedirect(<span class="string">"sso-server-url-with-system-url"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sso-server拦截未登录请求"><a href="#sso-server拦截未登录请求" class="headerlink" title="sso-server拦截未登录请求"></a>sso-server拦截未登录请求</h2><p>拦截从sso-client跳转至sso认证中心的未登录请求，跳转至登录页面，这个过程与sso-client完全一样。</p><h2 id="sso-server验证用户登录信息"><a href="#sso-server验证用户登录信息" class="headerlink" title="sso-server验证用户登录信息"></a>sso-server验证用户登录信息</h2><p>用户在登录页面输入用户名密码，请求登录，sso认证中心校验用户信息，校验成功，将会话状态标记为“已登录”。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.checkLoginInfo(username, password);</span><br><span class="line">    req.getSession().setAttribute(<span class="string">"isLogin"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sso-server创建授权令牌"><a href="#sso-server创建授权令牌" class="headerlink" title="sso-server创建授权令牌"></a>sso-server创建授权令牌</h2><p>授权令牌是一串随机字符，以什么样的方式生成都没有关系，只要不重复、不易伪造即可，下面是一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String token = UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure><h2 id="sso-client取得令牌并校验"><a href="#sso-client取得令牌并校验" class="headerlink" title="sso-client取得令牌并校验"></a>sso-client取得令牌并校验</h2><p>sso认证中心登录后，跳转回子系统并附上令牌，子系统（sso-client）取得令牌，然后去sso认证中心校验，在LoginFilter.java的doFilter()中添加几行：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求附带token参数</span></span><br><span class="line">String token = req.getParameter(<span class="string">"token"</span>);</span><br><span class="line"><span class="keyword">if</span> (token != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 去sso认证中心校验token</span></span><br><span class="line">    <span class="keyword">boolean</span> verifyResult = <span class="keyword">this</span>.verify(<span class="string">"sso-server-verify-url"</span>, token);</span><br><span class="line">    <span class="keyword">if</span> (!verifyResult) &#123;</span><br><span class="line">        res.sendRedirect(<span class="string">"sso-server-url"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>verify()方法使用httpClient实现，这里仅简略介绍，httpClient详细使用方法请参考官方文档。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpPost httpPost = <span class="keyword">new</span> HttpPost(<span class="string">"sso-server-verify-url-with-token"</span>);</span><br><span class="line">HttpResponse httpResponse = httpClient.execute(httpPost);</span><br></pre></td></tr></table></figure><h2 id="sso-server接收并处理校验令牌请求"><a href="#sso-server接收并处理校验令牌请求" class="headerlink" title="sso-server接收并处理校验令牌请求"></a>sso-server接收并处理校验令牌请求</h2><ul><li><p>用户在sso认证中心登录成功后，sso-server创建授权令牌并存储该令牌，所以，sso-server对令牌的校验就是去查找这个令牌是否存在以及是否过期，令牌校验成功后sso-server将发送校验请求的系统注册到sso认证中心（就是存储起来的意思）</p></li><li><p>令牌与注册系统地址通常存储在key-value数据库（如redis）中，redis可以为key设置有效时间也就是令牌的有效期。redis运行在内存中，速度非常快，正好sso-server不需要持久化任何数据。</p></li><li><p>令牌与注册系统地址可以用下图描述的结构存储在redis中，可能你会问，为什么要存储这些系统的地址？如果不存储，注销的时候就麻烦了，用户向sso认证中心提交注销请求，sso认证中心注销全局会话，但不知道哪些系统用此全局会话建立了自己的局部会话，也不知道要向哪些子系统发送注销请求注销局部会话。</p></li></ul><p><img src="https://images.morethink.cn/797930-20161129155245506-1069288802.png" alt=""></p><h2 id="sso-client校验令牌成功创建局部会话"><a href="#sso-client校验令牌成功创建局部会话" class="headerlink" title="sso-client校验令牌成功创建局部会话"></a>sso-client校验令牌成功创建局部会话</h2><p>令牌校验成功后，sso-client将当前局部会话标记为“已登录”，修改LoginFilter.java，添加几行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (verifyResult) &#123;</span><br><span class="line">    session.setAttribute(<span class="string">"isLogin"</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sso-client还需将当前会话id与令牌绑定，表示这个会话的登录状态与令牌相关，此关系可以用java的hashmap保存，保存的数据用来处理sso认证中心发来的注销请求</p><h2 id="注销过程"><a href="#注销过程" class="headerlink" title="注销过程"></a>注销过程</h2><p>用户向子系统发送带有“logout”参数的请求（注销请求），sso-client拦截器拦截该请求，向sso认证中心发起注销请求：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String logout = req.getParameter(<span class="string">"logout"</span>);</span><br><span class="line"><span class="keyword">if</span> (logout != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.ssoServer.logout(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sso认证中心也用同样的方式识别出sso-client的请求是注销请求（带有“logout”参数），sso认证中心注销全局会话：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/logout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    HttpSession session = req.getSession();</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">        session.invalidate();<span class="comment">//触发LogoutListener</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sso认证中心有一个全局会话的监听器，一旦全局会话注销，将通知所有注册系统注销</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogoutListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent event)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过httpClient向所有注册系统发送注销请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码部署"><a href="#代码部署" class="headerlink" title="代码部署"></a>代码部署</h1><p>GitHub地址： <a href="https://github.com/morethink/simple-sso.git" target="_blank" rel="noopener">https://github.com/morethink/simple-sso.git</a></p><h2 id="IDEA部署"><a href="#IDEA部署" class="headerlink" title="IDEA部署"></a>IDEA部署</h2><p><img src="https://images.morethink.cn/3a48b1deaaecd4dc74377a5eacec4a08.png" alt=""><br><img src="https://images.morethink.cn/d341e21bdb77889efae518d35d754b34.png" alt=""><br><img src="https://images.morethink.cn/1439e11d0b2659b62780e887bd22b20f.png" alt=""></p><h2 id="单点登录-1"><a href="#单点登录-1" class="headerlink" title="单点登录"></a>单点登录</h2><p><strong>访问a系统</strong>：</p><p><a href="http://localhost/a/test" target="_blank" rel="noopener">http://localhost/a/test</a></p><p><img src="https://images.morethink.cn/a743f4b854fb7f82bf4855112de304de.png" alt=""></p><p><strong>访问b系统</strong>：</p><p><a href="http://localhost/b/test" target="_blank" rel="noopener">http://localhost/b/test</a></p><p><img src="https://images.morethink.cn/e619435d561a998088a6d11a4ecc22cc.png" alt=""></p><p><strong>a系统登录成功</strong>：</p><p><img src="https://images.morethink.cn/07a3bf0aefd180dfaa5779ba740998b4.png" alt=""></p><p><strong>b系统同时也登录成功</strong>:</p><p><img src="https://images.morethink.cn/e504ce5c9dc7e9e70303b9f3f54d20c2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自： &lt;a href=&quot;https://www.cnblogs.com/ywlaker/p/6113927.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/ywlaker/p/6113927.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：凌承一&lt;br&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/ywlaker/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/ywlaker/&lt;/a&gt;&lt;br&gt;声明：本文版权归作者和博客园共有，欢迎转载，但转载必须保留此段声明，并在文章页面明显位置给出原文链接，否则作者将保留追究法律责任的权利。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;单系统登录机制&quot;&gt;&lt;a href=&quot;#单系统登录机制&quot; class=&quot;headerlink&quot; title=&quot;单系统登录机制&quot;&gt;&lt;/a&gt;单系统登录机制&lt;/h1&gt;&lt;p&gt;web应用采用browser/server架构，http作为通信协议。http是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/02c5bff6aa0c8a04bbda6261bb0fbd7f.png&quot; alt=&quot;&quot; title=&quot;无状态的Http协议&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="https://www.morethink.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="单点登录" scheme="https://www.morethink.cn/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 知识整理</title>
    <link href="https://www.morethink.cn/SpringMVC-Knowledge-finishing/"/>
    <id>https://www.morethink.cn/SpringMVC-Knowledge-finishing/</id>
    <published>2017-12-11T16:00:00.000Z</published>
    <updated>2018-03-27T03:21:42.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC架构设计"><a href="#SpringMVC架构设计" class="headerlink" title="SpringMVC架构设计"></a>SpringMVC架构设计</h1><p><strong>MVC是一种架构模式</strong>，它把业务的实现和展示相分离。</p><p><img src="https://images.morethink.cn/ddbf6d71cefe533f850b5466b583cfc0.png" alt="" title="SpringMVC架构"></p><a id="more"></a><h1 id="SpringMVC与struts2的区别"><a href="#SpringMVC与struts2的区别" class="headerlink" title="SpringMVC与struts2的区别"></a>SpringMVC与struts2的区别</h1><ol><li><strong>Struts2是类级别的拦截</strong>， 一个类对应一个request上下文，<strong>SpringMVC是方法级别的拦截</strong>，一个方法对应一个request上下文，而方法同时又跟一个url对应,所以说从架构本身上SpringMVC就容易实现restful url,而struts2的架构实现起来要费劲，因为Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。</li><li><strong>springmvc可以进行单例开发</strong>，并且建议使用单例开发，struts2通过类的成员变量接收参数，无法使用单例，只能使用多例。</li><li>由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。</li><li><strong>拦截器实现机制上</strong>，Struts2有以自己的interceptor机制，SpringMVC用的是独立的AOP方式，这样导致Struts2的配置文件量还是比SpringMVC大。</li><li>servlet和filter的区别了。</li><li>SpringMVC集成了Ajax，使用非常方便，只需一个注解<code>@ResponseBody</code>就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。</li><li>SpringMVC验证支持JSR303，处理起来相对更加灵活方便，而Struts2验证比较繁琐，感觉太烦乱。</li><li>spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。</li><li>设计思想上，Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。</li><li>SpringMVC开发效率和性能高于Struts2。</li><li>SpringMVC可以认为已经100%零配置。</li></ol><h1 id="SpringAOP整合SpringMVC"><a href="#SpringAOP整合SpringMVC" class="headerlink" title="SpringAOP整合SpringMVC"></a>SpringAOP整合SpringMVC</h1><p>spring容器不注册controller层组件，controller组件由springMVC容器单独注册。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// applicationContext.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.shuyun.channel"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.RestController"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.ControllerAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// springmvc-servlet.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.shuyun.channel"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.RestController"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.ControllerAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>关于<code>&lt;context:annotation-config /&gt;</code>和 <code>&lt;context:component-scan /&gt;</code>:</p><p><strong>component-scan会自动加上annotation-config功能，有了component-scan不用再写annotation-config了</strong>。参见spring官方reference</p><h1 id="配置层次化Spring容器"><a href="#配置层次化Spring容器" class="headerlink" title="配置层次化Spring容器"></a>配置层次化Spring容器</h1><p>参考 <a href="http://blog.csdn.net/skyhitnow/article/details/43731493" target="_blank" rel="noopener">配置层次化Spring容器</a></p><p>我们知道，在开发基于spring的Web应用时，通常使用两个IoC容器，一个是由DispatchServlet初始化的WebApplicationContext,一个是由ContextLoaderListener初始化的ApplicationContext。对于Spring容器，Spring的官方参考手册详细地讲解了依赖注入的配置方式，对于容器本身的配置和多个容器之间的关系却不曾提及。于是，很多人以为在一个应用中只有一个全局的Spring容器，或者不了解MVC使用的WebApplicationContext和根ApplicationContext的关系。</p><p>通过查看Spring的源码和API,发现Spring可以配置为多个容器，容器之间可以配置为层级关系，一个根容器可以配置许多子容器，子容器还可以配置子容器，从而形成一个单根的层次化结构。对于该容器结构中的每个容器，在其中查找特定的bean时，会首先在本容器内查找，如果找到对应的bean,就返回该bean；如果没有找到，就会从直接父容器中去查找，依此类推，直到根容器为止。</p><p>从上面的示例中可以看到，从子容器中可以取得父容器中配置的bean，而父容器中不能够取得子容器中的bean。</p><p>在Spring MVC中WebApplicationContext配置为根ApplicationContext的子容器，所以，MVC使用的容器中能够取得根ApplicationContext中的bean。<strong>在一个web程序中可以配置多个DispatchSerlvet，每个Servlet对应一个容器</strong>，所有这些容器都作为根容器的子容器，这样，我们就可以把通用的bean放在根容器中，而针对特定DispatchServlet的bean，可以放在各自的子容器中。</p><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><ul><li><p>Controller的方法中需要接受一个Spring MVC提供的MultipartFile接口作为方法的参数，该参数接收前台表单type为file提交的对象，使用<code>@RequestParam</code>注解指明参数，那么Spring就会自动将表单传递过来的对象的类型转换为MultipartFile类型。</p></li><li><p>MultipartFile中提供了getName()、getSize()、getByte()<br>getContentType()、isEmpty()、getInputStream()、getOriginalFilename()方法来访问文件。getOriginalFilename()方法是获取最初文件名，即本地文件名。</p></li><li>在Controller方法中使用FileUtils下的copyInputStreamToFile(InputStream in,File file)方法来完成文件的拷贝.第一个参数是文件拷贝源的输入流,直接使用MultipartFile下的getInputStream()方法.第二个参数是文件将要保存的位置.</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/doUpload"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doUpload</span><span class="params">(@RequestParam(<span class="string">"file"</span>)</span> MultipartFile file) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!file.isEmpty()) &#123;</span><br><span class="line">        FileUtils.copyInputStreamToFile(file.getInputStream(), <span class="keyword">new</span> File(<span class="string">"E://"</span>, file.getOriginalFilename()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ResultUtil.SUCCESS_RESULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h1><ul><li><a href="https://www.mkyong.com/java/how-to-enable-pretty-print-json-output-jackson/" target="_blank" rel="noopener">How to enable pretty print JSON output (Jackson)</a></li><li><a href="https://www.mkyong.com/java/jackson-2-convert-java-object-to-from-json/" target="_blank" rel="noopener">Jackson 2 – Convert Java Object to / from JSON</a></li><li><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html" target="_blank" rel="noopener">SpringMVC关于json、xml自动转换的原理研究(附带源码分析)</a></li></ul><h1 id="SpringMVC拦截器"><a href="#SpringMVC拦截器" class="headerlink" title="SpringMVC拦截器"></a>SpringMVC拦截器</h1><p>拦截器好比你要去取经，那么，你就必须经过九九八十一关，主要用来解决请求的共性问题，如：乱码问题、权限验证问题等</p><p>实现SpringMVC拦截器的三个步骤</p><ol><li>创建一个实现HandlerInterceptor接口，并实现接口的方法的类</li><li><p>将创建的拦截器注册到SpringMVC的配置文件中实现注册</p> <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc：interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"路径下的类"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc：interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置拦截器的拦截规则：</p> <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc：interceptors</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc：interceptor</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"拦截的action"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"路径下的类"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc：interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc：interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>拦截器中三个方法的介绍：</p><ol><li>preHandle()方法是否将当前请求拦截下来。（返回true请求继续运行，返回false请求终止（包括action层也会终止），Object arg代表被拦截的目标对象。）</li><li>postHandle()方法的ModelAndView对象可以改变发往的视图或修改发往视图的信息。</li><li>afterCompletion()方法表示视图显示之后在执行该方法。（一般用于资源的销毁）</li></ol><h2 id="拦截器和过滤器"><a href="#拦截器和过滤器" class="headerlink" title="拦截器和过滤器"></a>拦截器和过滤器</h2><p>共同：他们都是用来检查程序的共同场景，只不过拦截器是面向Action的，过滤器是面向整个web应用的。</p><ol><li>解决权限验证问题</li><li>解决乱码问题</li></ol><p>拦截器和过滤器的区别：</p><ol><li>拦截器是基于java的反射机制的，而过滤器是基于函数回调。</li><li>拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</li><li>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</li><li>拦截器可以访问action上下文、<strong>值栈</strong> 里的对象，而过滤器不能访问。</li><li>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</li><li><strong>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑</strong>。</li></ol><h2 id="拦截器方法的作用顺序"><a href="#拦截器方法的作用顺序" class="headerlink" title="拦截器方法的作用顺序"></a>拦截器方法的作用顺序</h2><p><img src="https://images.morethink.cn/a23b0321f130d0b064094c2b9e1e15a6.png" alt="" title="拦截器方法的作用顺序"></p><p>拦截器的其它实现方式：</p><ol><li>拦截器的类还可以通过实现WebRequestInterceptor（HandlerInterceptor）接口来编写。</li><li>向SpringMVC框架注册的写法不变。</li><li>弊端：preHandler方法没有返回值，不能终止请求。</li></ol><p>Ps：建议使用功能更强大的实现方式，实现HandlerInterceptor接口。</p><h1 id="Spring4增加功能"><a href="#Spring4增加功能" class="headerlink" title="Spring4增加功能"></a>Spring4增加功能</h1><p>Spring4主要在Web服务方面有下面两个方面提升：</p><ol><li>控制器使用<code>@ResponseBody</code>和 <code>@RestController</code>。</li><li>异步调用。</li></ol><h1 id="Spring整合Struts2"><a href="#Spring整合Struts2" class="headerlink" title="Spring整合Struts2"></a>Spring整合Struts2</h1><p>Spring默认是单例，Struts2默认是多实例的。</p><p>如果是spring配置文件中的 bean的名字的话就是spring创建，那么单实例还是多实例就由spring的action Bean中的业务逻辑控制器类是否配置为scope=”prototype”，有就是多实例的，没有就是单实例的，顺序是先从spring中找，找不到再从struts配置文件中找。</p><ol><li><p>对于无Spring插件（Struts2-spring-plugin-XXX.jar）的整合方式，需要在spring的action Bean中加业务逻辑控制器类配scope=”prototype”。</p> <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"modle.User"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>对于有Spring插件（Struts2-spring-plugin-XXX.jar）的整合方式：反编译StrutsSpringObjectFactory以及相关的代码才发现，如果在struts action的配置文件 <code>&lt;action name=&quot;..&quot; class=&quot;..&quot;/&gt;</code> 中class写的如果是完整的包名和类名的话就是struts创建action对象，也就是多实例的；</p></li></ol><p><strong>参考文档</strong>：</p><ol><li><a href="http://www.cnblogs.com/sunniest/p/4555801.html" target="_blank" rel="noopener">史上最全最强SpringMVC详细示例实战教程</a></li><li><a href="https://www.tianmaying.com/tutorial/spring-mvc-quickstart" target="_blank" rel="noopener">Spring MVC快速入门</a></li><li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html" target="_blank" rel="noopener">Web MVC framework - Part VI. The Web</a></li><li><a href="http://snowolf.iteye.com/blog/1628861" target="_blank" rel="noopener">Spring 注解学习手札（七） 补遗——@ResponseBody，@RequestBody，@PathVariable</a></li><li><a href="https://github.com/kuitos/kuitos.github.io/issues/9" target="_blank" rel="noopener">SpringMVC4.1之Controller层最佳实践</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringMVC架构设计&quot;&gt;&lt;a href=&quot;#SpringMVC架构设计&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC架构设计&quot;&gt;&lt;/a&gt;SpringMVC架构设计&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;MVC是一种架构模式&lt;/strong&gt;，它把业务的实现和展示相分离。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/ddbf6d71cefe533f850b5466b583cfc0.png&quot; alt=&quot;&quot; title=&quot;SpringMVC架构&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="SpringMVC" scheme="https://www.morethink.cn/categories/SpringMVC/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC 参数绑定注解解析</title>
    <link href="https://www.morethink.cn/SpringMVC-Annotation/"/>
    <id>https://www.morethink.cn/SpringMVC-Annotation/</id>
    <published>2017-12-11T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.186Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了用于参数绑定的相关注解。</p><p>绑定：将请求中的字段按照名字匹配的原则填入模型对象。</p><p>SpringMVC就跟Struts2一样，通过拦截器进行参数匹配。</p><p>代码在 <a href="https://github.com/morethink/MySpringMVC" target="_blank" rel="noopener">https://github.com/morethink/MySpringMVC</a></p><h1 id="URI模板变量"><a href="#URI模板变量" class="headerlink" title="URI模板变量"></a>URI模板变量</h1><p>这里指uri template中variable(路径变量)，不含queryString部分<br><a id="more"></a></p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a><code>@PathVariable</code></h2><p>当使用<code>@RequestMapping</code> URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 <code>@Pathvariable</code>注解绑定它传过来的值到方法的参数上。</p><p>示例代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">getUser</span><span class="params">(@PathVariable <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.successResult(<span class="string">"123456"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码把URI template 中变量 ownerId的值和petId的值，绑定到方法的参数上。<strong>若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称</strong>。</p><h1 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h1><h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a><code>@RequestHeader</code></h2><p><code>@RequestHeader</code> 注解，可以把Request请求header部分的值绑定到方法的参数上。</p><p>示例代码：</p><p>这是一个Request 的header部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Accept-Encoding:gzip, deflate, br</span><br><span class="line">Accept-Language:zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7</span><br><span class="line">Cache-Control:max-age=0</span><br><span class="line">Connection:keep-alive</span><br><span class="line">Host:localhost:8080</span><br><span class="line">Upgrade-Insecure-Requests:1</span><br><span class="line">User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getRequestHeader"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">getRequestHeader</span><span class="params">(@RequestHeader(<span class="string">"Accept-Encoding"</span>)</span> String encoding) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ResultUtil.successResult(encoding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，把request header部分的 Accept-Encoding的值，绑定到参数encoding上。</p><h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a><code>@CookieValue</code></h2><p>可以把Request header中关于cookie的值绑定到方法的参数上。</p><p>例如有如下Cookie值：<br><code>JSESSIONID=588DC770E582A3189B7E6210102EAE02</code><br>参数绑定的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getCookie"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">getCookie</span><span class="params">(@CookieValue(<span class="string">"JSESSIONID"</span>)</span> String cookie) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ResultUtil.successResult(cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即把JSESSIONID的值绑定到参数cookie上。</p><h1 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h1><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a><code>@RequestParam</code></h2><ul><li>常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（ String–&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值；</li><li><strong>用来处理Content-Type: 为 <code>application/x-www-form-urlencoded</code>编码的内容，提交方式GET、POST</strong>；</li><li>该注解有两个属性： value、required； value用来指定要传入值的id名称，required用来指示参数是否必须绑定；</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/tesRequestParam"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">tesRequestParam</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String username) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ResultUtil.successResult(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a><code>@RequestBody</code></h2><p>该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；</p><p>它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。</p><p>因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap<string, string="">里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api;</string,></p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/tesRequestBody&quot;)</span><br><span class="line">public Result tesRequestBody(@RequestBody User user) &#123;</span><br><span class="line"></span><br><span class="line">    return ResultUtil.successResult(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果截图：</p><p><img src="https://images.morethink.cn/f918dd11d4630c479a25548cca70acc2.png" alt="" title="Content-Type:application/json"></p><h2 id="RequestBody通过list接收对象数组"><a href="#RequestBody通过list接收对象数组" class="headerlink" title="@RequestBody通过list接收对象数组"></a><code>@RequestBody</code>通过list接收对象数组</h2><p>在我们传递对象的时候，无论<code>Content-Type</code>是<code>x-www-form-urlencoded</code>还是<code>application/json</code>其实没有多大的关系，可是当我们需要传递对象数组的时候，表单编码就不行了，这时我们是可以采用json传递，然后后台使用<code>@RequestBody</code>注解，通过list接收来对象数组。</p><p>前端代码：</p><p>index.html<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打开页面时运行</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> users = [];</span><br><span class="line">    <span class="keyword">var</span> user1 = &#123;<span class="string">"username"</span>: <span class="string">"dd"</span>, <span class="string">"password"</span>: <span class="string">"123"</span>&#125;;</span><br><span class="line">    <span class="keyword">var</span> user2 = &#123;<span class="string">"username"</span>: <span class="string">"gg"</span>, <span class="string">"password"</span>: <span class="string">"123"</span>&#125;;</span><br><span class="line">    users.push(user1);</span><br><span class="line">    users.push(user2);</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">"POST"</span>,</span><br><span class="line">        url: <span class="string">"users/saveUsers"</span>,</span><br><span class="line">        timeout: <span class="number">30000</span>,</span><br><span class="line">        dataType: <span class="string">"json"</span>,</span><br><span class="line">        contentType: <span class="string">"application/json"</span>,</span><br><span class="line">        data: <span class="built_in">JSON</span>.stringify(users),</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//将返回的数据展示成table</span></span><br><span class="line">            showTable(data);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//请求出错的处理</span></span><br><span class="line">            $(<span class="string">"#result"</span>).text(<span class="string">"请求出错"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>后台代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"saveUsers"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">saveUsers</span><span class="params">(@RequestBody List&lt;User&gt; users)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ResultUtil.successResult(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果截图：</p><p><img src="https://images.morethink.cn/2161af7bd2378ca110347dd73a4ecf94.png" alt="" title="表格展示数据"></p><h1 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a><code>@SessionAttribute</code></h1><p>该注解用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/setSessionAttribute"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">setSessionAttribute</span><span class="params">(HttpSession session, String attribute)</span> </span>&#123;</span><br><span class="line">    session.setAttribute(<span class="string">"attribute"</span>, attribute);</span><br><span class="line">    <span class="keyword">return</span> ResultUtil.SUCCESS_RESULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getSessionAttribute"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">getSessionAttribute</span><span class="params">(@SessionAttribute(<span class="string">"attribute"</span>)</span> String attribute) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ResultUtil.successResult(attribute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先给session添加一个attribute，然后再取出这个attribute。</p><p><img src="https://images.morethink.cn/03f2cfd9da78e5abd39254a7cc7c21d7.png" alt="" title="添加属性"></p><p><img src="https://images.morethink.cn/6d17bbc4aeb10b48e4593ca5e82f3ca9.png" alt="" title="得到属性"></p><h1 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a><code>@ModelAttribute</code></h1><p>@ModelAttribute标注可被应用在方法或方法参数上。</p><h2 id="方法使用-ModelAttribute标注"><a href="#方法使用-ModelAttribute标注" class="headerlink" title="方法使用@ModelAttribute标注"></a>方法使用@ModelAttribute标注</h2><p>标注在方法上的<code>@ModelAttribute</code>说明方法是用于添加一个或多个属性到model上。这样的方法能接受与<code>@RequestMapping</code>标注相同的参数类型，只不过不能直接被映射到具体的请求上。</p><p>在同一个控制器中，标注了<code>@ModelAttribute</code>的方法实际上会在<code>@RequestMapping</code>方法之前被调用。</p><p>以下是示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add one attribute</span></span><br><span class="line"><span class="comment">// The return value of the method is added to the model under the name "account"</span></span><br><span class="line"><span class="comment">// You can customize the name via @ModelAttribute("myAccount")</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">addAccount</span><span class="params">(@RequestParam String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accountManager.findAccount(number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add multiple attributes</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateModel</span><span class="params">(@RequestParam String number, Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(accountManager.findAccount(number));</span><br><span class="line">    <span class="comment">// add more ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>@ModelAttribute</code>方法通常被用来填充一些公共需要的属性或数据</strong>，比如一个下拉列表所预设的几种状态，或者宠物的几种类型，或者去取得一个HTML表单渲染所需要的命令对象，比如Account等。</p><p>@ModelAttribute标注方法有两种风格：</p><ul><li>在第一种写法中，方法通过返回值的方式默认地将添加一个属性；</li><li>在第二种写法中，方法接收一个Model对象，然后可以向其中添加任意数量的属性。</li></ul><p>可以在根据需要，在两种风格中选择合适的一种。</p><p><strong>一个控制器可以拥有多个<code>@ModelAttribute</code>方法。同个控制器内的所有这些方法，都会在<code>@RequestMapping</code>方法之前被调用。</strong></p><p><code>@ModelAttribute</code>方法也可以定义在<code>@ControllerAdvice</code>标注的类中，并且这些<code>@ModelAttribute</code>可以同时对许多控制器生效。</p><p>属性名没有被显式指定的时候又当如何呢？在这种情况下，框架将根据属性的类型给予一个默认名称。举个例子，若方法返回一个Account类型的对象，则默认的属性名为”account”。可以通过设置@ModelAttribute标注的值来改变默认值。当向Model中直接添加属性时，请使用合适的重载方法addAttribute(..)-即带或不带属性名的方法。</p><p>@ModelAttribute标注也可以被用在<code>@RequestMapping</code>方法上。这种情况下，<code>@RequestMapping</code>方法的返回值将会被解释为model的一个属性，而非一个视图名，此时视图名将以视图命名约定来方式来确定。</p><h2 id="方法参数使用-ModelAttribute标注"><a href="#方法参数使用-ModelAttribute标注" class="headerlink" title="方法参数使用@ModelAttribute标注"></a>方法参数使用<code>@ModelAttribute</code>标注</h2><p><strong>标注在方法参数上的<code>@ModelAttribute</code>说明了该方法参数的值将由model中取得。如果model中找不到，那么该参数会先被实例化，然后被添加到model中。在model中存在以后，请求中所有名称匹配的参数都会填充到该参数中。</strong></p><p>这在Spring MVC中被称为数据绑定，一个非常有用的特性，我们不用每次都手动从表格数据中转换这些字段数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">saveUser</span><span class="params">(@ModelAttribute User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ResultUtil.successResult(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上面的代码为例，这个User类型的实例可能来自哪里呢？有几种可能:</p><ul><li>它可能因为<code>@SessionAttributes</code>标注的使用已经存在于model中</li><li>它可能因为在同个控制器中使用了<code>@ModelAttribute</code>方法已经存在于model中，正如上一小节所叙述的</li><li>它可能是由URI模板变量和类型转换中取得的</li><li>它可能是调用了自身的默认构造器被实例化出来的</li></ul><p>@ModelAttribute方法常用于从数据库中取一个属性值，该值可能通过<code>@SessionAttributes</code>标注在请求中间传递。在一些情况下，使用URI模板变量和类型转换的方式来取得一个属性是更方便的方式。</p><h1 id="在不给定注解的情况下，参数是怎样绑定的？"><a href="#在不给定注解的情况下，参数是怎样绑定的？" class="headerlink" title="在不给定注解的情况下，参数是怎样绑定的？"></a>在不给定注解的情况下，参数是怎样绑定的？</h1><p>通过分析<code>AnnotationMethodHandlerAdapter</code>和<code>RequestMappingHandlerAdapter</code>的源代码发现，方法的参数在不给定参数的情况下：</p><ul><li>若要绑定的对象时简单类型：调用<code>@RequestParam</code>来处理的。<br>这里的简单类型指Java的原始类型(boolean, int 等)、原始类型对象（Boolean, Int等）、String、Date等ConversionService里可以直接String转换成目标对象的类型。也就是说没有特别需求，不推荐使用<code>@RequestParam</code>。</li><li>若要绑定的对象时复杂类型：调用<code>@ModelAttribute</code>来处理的。也就是说如果不需要从model或者session中得到数据，@ModelAttribute可以不使用。</li></ul><h1 id="RequestMapping支持的方法参数"><a href="#RequestMapping支持的方法参数" class="headerlink" title="@RequestMapping支持的方法参数"></a><code>@RequestMapping</code>支持的方法参数</h1><p>下面这些参数Spring在调用请求方法的时候会自动给它们赋值，所以当在请求方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。</p><ol><li>HttpServlet 对象，主要包括HttpServletRequest 、HttpServletResponse 和HttpSession 对象。 但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题。</li><li>Spring 自己的WebRequest 对象。 使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。</li><li>InputStream 、OutputStream 、Reader 和Writer 。 InputStream 和Reader 是针对HttpServletRequest 而言的，可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。</li><li>使用<code>@PathVariable</code> 、<code>@RequestParam</code> 、<code>@CookieValue</code> 和 <code>@RequestHeader</code> 标记的参数。</li><li>使用<code>@ModelAttribute</code> 标记的参数。</li><li>java.util.Map 、Spring 封装的Model 和ModelMap 。 这些都可以用来封装模型数据，用来给视图做展示。</li><li>实体类。 可以用来接收上传的参数。</li><li>Spring 封装的MultipartFile 。 用来接收上传文件的。</li><li>Spring 封装的Errors 和BindingResult 对象。 这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。</li></ol><h1 id="一个参数传多个值"><a href="#一个参数传多个值" class="headerlink" title="一个参数传多个值"></a>一个参数传多个值</h1><p>在浏览器输入此URL<code>http://localhost:8080/admin/login.action?username=geek&amp;password=geek&amp;password=geek</code></p><p>结果得到的对象为 ： <code>Manager{username=&#39;geek&#39;, password=&#39;geek,geek&#39;}</code></p><p><strong>参考文档</strong>:</p><ol><li><a href="http://blog.csdn.net/walkerjong/article/details/7946109" target="_blank" rel="noopener">@RequestParam @RequestBody @PathVariable 等参数绑定注解详解</a></li><li><a href="https://segmentfault.com/a/1190000005670764#articleHeader8" target="_blank" rel="noopener">SpringMVC之Controller常用注解功能全解析</a></li><li><a href="http://wangwengcn.iteye.com/blog/1677024" target="_blank" rel="noopener">@ModelAttribute使用详解</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了用于参数绑定的相关注解。&lt;/p&gt;
&lt;p&gt;绑定：将请求中的字段按照名字匹配的原则填入模型对象。&lt;/p&gt;
&lt;p&gt;SpringMVC就跟Struts2一样，通过拦截器进行参数匹配。&lt;/p&gt;
&lt;p&gt;代码在 &lt;a href=&quot;https://github.com/morethink/MySpringMVC&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/morethink/MySpringMVC&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;URI模板变量&quot;&gt;&lt;a href=&quot;#URI模板变量&quot; class=&quot;headerlink&quot; title=&quot;URI模板变量&quot;&gt;&lt;/a&gt;URI模板变量&lt;/h1&gt;&lt;p&gt;这里指uri template中variable(路径变量)，不含queryString部分&lt;br&gt;
    
    </summary>
    
      <category term="SpringMVC" scheme="https://www.morethink.cn/categories/SpringMVC/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis和Memcached区别</title>
    <link href="https://www.morethink.cn/Redis-and-Memcached-difference/"/>
    <id>https://www.morethink.cn/Redis-and-Memcached-difference/</id>
    <published>2017-12-01T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.185Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考 <a href="http://blog.51cto.com/gnucto/998509" target="_blank" rel="noopener">Redis与Memcached的区别</a>。</p><p>如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：</p><ol><li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li></ol><p>抛开这些，可以深入到Redis内部构造去观察更加本质的区别，理解Redis的设计。</p><a id="more"></a><h1 id="网络IO模型"><a href="#网络IO模型" class="headerlink" title="网络IO模型"></a>网络IO模型</h1><h2 id="Memcached网络IO模型"><a href="#Memcached网络IO模型" class="headerlink" title="Memcached网络IO模型"></a>Memcached网络IO模型</h2><p>Memcached是 <strong>多线程非阻塞IO复用</strong> 的网络模型，分为监听主线程和worker子线程，监听线程监听网络连接，接受请求后，将连接描述字pipe传递给worker线程，进行读写IO, 网络层使用libevent封装的事件库，多线程模型可以发挥多核作用，但是引入了cache coherency和锁的问题，比如，Memcached最常用的stats 命令，实际Memcached所有操作都要对这个全局变量加锁，进行计数等工作，带来了性能损耗。</p><p><img src="https://images.morethink.cn/0dcb499bd022cea2069865875decc2b7.png" alt="" title="Memcached网络IO模型"></p><h2 id="Redis网络IO模型"><a href="#Redis网络IO模型" class="headerlink" title="Redis网络IO模型"></a>Redis网络IO模型</h2><p>Redis使用 <strong>单线程非阻塞IO复用</strong> 模型，自己封装了一个简单的AeEvent事件处理框架，主要实现了epoll、kqueue和select，对于单纯只有IO操作来说，单线程可以将速度优势发挥到最大，但是 <strong>Redis也提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型实际会严重影响整体吞吐量，CPU计算过程中，整个IO调度都是被阻塞住的</strong>。</p><h1 id="内存管理方面"><a href="#内存管理方面" class="headerlink" title="内存管理方面"></a>内存管理方面</h1><ul><li>Memcached使用预分配的内存池的方式，使用slab和大小不同的chunk来管理内存，Item根据大小选择合适的chunk存储，内存池的方式可以省去申请/释放内存的开销，并且能减小内存碎片产生，但这种方式也会带来一定程度上的空间浪费，并且在内存仍然有很大空间时，新的数据也可能会被剔除，原因可以参考Timyang的文章： <a href="http://timyang.net/data/Memcached-lru-evictions/" target="_blank" rel="noopener">http://timyang.net/data/Memcached-lru-evictions/</a></li><li>Redis使用现场申请内存的方式来存储数据，并且很少使用free-list等方式来优化内存分配，会在一定程度上存在内存碎片，Redis跟据存储命令参数，会把带过期时间的数据单独存放在一起，并把它们称为临时数据，非临时数据是永远不会被剔除的，即便物理内存不够，导致swap也不会剔除任何非临时数据(但会尝试剔除部分临时数据)，这点上 <strong>Redis更适合作为存储而不是cache</strong>。</li></ul><h1 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h1><ul><li>Memcached提供了cas命令，可以保证多个并发访问操作同一份数据的一致性问题。</li><li>Redis没有提供cas命令，并不能保证这点，不过Redis提供了事务的功能，可以保证一串命令的原子性，中间不会被任何操作打断。</li></ul><h1 id="集群管理的不同"><a href="#集群管理的不同" class="headerlink" title="集群管理的不同"></a>集群管理的不同</h1><p>Memcached是全内存的数据缓冲系统，Redis虽然支持数据的持久化，但是全内存毕竟才是其高性能的本质。作为基于内存的存储系统来说，机器物理内存的大小就是系统能够容纳的最大数据量。如果需要处理的数据量超过了单台机器的物理内存大小，就需要构建分布式集群来扩展存储能力。</p><h2 id="分布式Memcached"><a href="#分布式Memcached" class="headerlink" title="分布式Memcached"></a>分布式Memcached</h2><p><strong>Memcached本身并不支持分布式</strong>，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。下图给出了Memcached的分布式存储实现架构。当客户端向Memcached集群发送数据之前，首先会通过内置的分布式算法计算出该条数据的目标节点，然后数据会直接发送到该节点上存储。但客户端查询数据时，同样要计算出查询数据所在的节点，然后直接向该节点发送查询请求以获取数据。</p><p><img src="https://images.morethink.cn/b4dc233573a34d272d52a270ff01d3f8.png" alt="" title="分布式Memcached"></p><h2 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h2><p>相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。最新版本的Redis已经支持了分布式存储功能。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，具有线性可伸缩的功能。下图给出Redis Cluster的分布式存储架构，其中节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个key的数值域分成4096个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis Cluster支持的最大节点数就是4096。Redis Cluster使用的分布式算法也很简单：<code>crc16( key ) %HASH_SLOTS_NUMBER</code>。</p><p><img src="https://images.morethink.cn/ecb156696a22333a19ea5647b7eaefcc.png" alt="" title="Redis-Cluster"></p><p>为了保证单点故障下的数据可用性，Redis Cluster引入了Master节点和Slave节点。在Redis Cluster中，每个Master节点都会有对应的两个用于冗余的Slave节点。这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当Master节点退出后，集群会自动选择一个Slave节点成为新的Master节点。</p><p><img src="https://images.morethink.cn/c7b06587ee2b47925a540cc1c10ca44f.png" alt="" title="Redis-Cluster-2"></p><h1 id="存储方式及其它方面"><a href="#存储方式及其它方面" class="headerlink" title="存储方式及其它方面"></a>存储方式及其它方面</h1><ul><li>Memcached基本只支持简单的key-value存储，不支持枚举，不支持持久化和复制等功能</li><li>Redis除key/value之外，还支持list,set,sorted set,hash等众多数据结构，提供了KEYS进行枚举操作，但不能在线上使用，如果需要枚举线上数据，Redis提供了工具可以直接扫描其dump文件，枚举出所有数据，Redis还同时提供了持久化和复制等功能。</li></ul><p><strong>根据以上比较不难看出，当我们不希望数据被踢出，或者需要除key/value之外的更多数据类型时，或者需要落地功能时，使用Redis比使用Memcached更合适</strong>。</p><h1 id="单线程的Redis为什么这么高效"><a href="#单线程的Redis为什么这么高效" class="headerlink" title="单线程的Redis为什么这么高效"></a>单线程的Redis为什么这么高效</h1><h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p>Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中执行命令阶段，由于Redis是单线程来处理命令的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。</p><h2 id="单线程模型每秒万级别处理能力的原因"><a href="#单线程模型每秒万级别处理能力的原因" class="headerlink" title="单线程模型每秒万级别处理能力的原因"></a>单线程模型每秒万级别处理能力的原因</h2><ol><li>纯内存访问。数据存放在内存中，内存的响应时间大约是100纳秒，这是Redis每秒万亿级别访问的重要基础。</li><li>非阻塞I/O，Redis采用epoll做为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I/O上浪费过多的时间。</li><li>单线程避免了线程切换和竞态产生的消耗。</li><li>Redis采用单线程模型，每条命令执行如果占用大量时间，会造成其他线程阻塞，对于Redis这种高性能服务是致命的，所以Redis是面向高速执行的数据库。</li></ol><p><strong>总结</strong>：<br>　　1. Redis使用最佳方式是全部数据in-memory。<br>　　2. Redis更多场景是作为Memcached的替代者来使用。<br>　　3. 当需要除key/value之外的更多数据类型支持时，使用Redis更合适。<br>　　4. 当存储的数据不能被剔除时，使用Redis更合适。<br>　　5. 需要分布式部署时，使用Redis更合适。</p><p><strong>参考文档</strong>：</p><ol><li><a href="http://blog.51cto.com/gnucto/998509" target="_blank" rel="noopener">Redis与Memcached的区别</a></li><li><a href="https://www.biaodianfu.com/redis-vs-memcached.html?spm=5176.100239.blogcont238409.17.w1SLGA" target="_blank" rel="noopener">Redis和Memcached的区别</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文参考 &lt;a href=&quot;http://blog.51cto.com/gnucto/998509&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis与Memcached的区别&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。&lt;/li&gt;
&lt;li&gt;Redis支持数据的备份，即master-slave模式的数据备份。&lt;/li&gt;
&lt;li&gt;Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;抛开这些，可以深入到Redis内部构造去观察更加本质的区别，理解Redis的设计。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://www.morethink.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="https://www.morethink.cn/tags/Redis/"/>
    
      <category term="Memcached" scheme="https://www.morethink.cn/tags/Memcached/"/>
    
  </entry>
  
  <entry>
    <title>常用编程工具快捷键整理</title>
    <link href="https://www.morethink.cn/Common-programming-tools-shortcut-keys/"/>
    <id>https://www.morethink.cn/Common-programming-tools-shortcut-keys/</id>
    <published>2017-11-27T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.178Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要整理常用编程工具的快捷键。</p><a id="more"></a><h1 id="Navicat-for-mysql-快捷键"><a href="#Navicat-for-mysql-快捷键" class="headerlink" title="Navicat for mysql 快捷键"></a>Navicat for mysql 快捷键</h1><ol><li>Ctrl+Q           打开查询窗口</li><li>Ctrl+/            注释sql语句</li><li>Ctrl+Shift +/  解除注释</li><li>Ctrl+R           运行查询窗口的sql语句</li><li>Ctrl+Shift+R   只运行选中的sql语句</li><li>F6               打开一个mysql命令行窗口</li><li>Ctrl+L            删除一行</li><li>Ctrl+N           打开一个新的查询窗口</li><li>Ctrl+W          关闭一个查询窗口</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要整理常用编程工具的快捷键。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://www.morethink.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.morethink.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="效率" scheme="https://www.morethink.cn/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC数据验证(AOP处理Errors和方法验证)</title>
    <link href="https://www.morethink.cn/SpringMVC-Bean-Validation/"/>
    <id>https://www.morethink.cn/SpringMVC-Bean-Validation/</id>
    <published>2017-11-18T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.186Z</updated>
    
    <content type="html"><![CDATA[<p>什么是JSR303？</p><p>JSR 303 – Bean Validation 是一个数据验证的规范，2009 年 11 月确定最终方案。<br>Hibernate Validator 是 Bean Validation 的最佳实践。</p><p>为什么使用JSR，松耦合，让业务代码的职责更加清晰。</p><p>松耦合就是职责更加清晰，每个人都有自己的职责，如果你的代码进行改动，我不用改动或者仅仅少量改动就可以发布和部署。<br><a id="more"></a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="maven-配置"><a href="#maven-配置" class="headerlink" title="maven 配置"></a>maven 配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JSR 303 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Hibernate validator--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SpringMVC-配置"><a href="#SpringMVC-配置" class="headerlink" title="SpringMVC 配置"></a>SpringMVC 配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">validator</span>=<span class="string">"validator"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置校验器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"validator"</span> <span class="attr">class</span>=<span class="string">"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 校验器，使用Hibernate校验器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"providerClass"</span> <span class="attr">value</span>=<span class="string">"org.hibernate.validator.HibernateValidator"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定校验使用的资源文件，在文件中配置校验错误信息，如果不指定则默认使用classpath下面的ValidationMessages.properties文件， --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationMessageSource"</span> <span class="attr">ref</span>=<span class="string">"messageSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 校验错误信息配置文件，也可以不配置，直接使用注解中的message即可 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ReloadableResourceBundleMessageSource"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 资源文件名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basenames"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:messageSource<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 资源文件编码格式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fileEncodings"</span> <span class="attr">value</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对资源文件内容缓存时间，单位秒 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheSeconds"</span> <span class="attr">value</span>=<span class="string">"120"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="常用校验注解"><a href="#常用校验注解" class="headerlink" title="常用校验注解"></a>常用校验注解</h1><table><thead><tr><th>注解</th><th>运行时检查</th></tr></thead><tbody><tr><td>@AssertFalse</td><td>被注解的元素必须为false</td></tr><tr><td>@AssertTrue</td><td>被注解的元素必须为true</td></tr><tr><td>@DecimalMax(value)</td><td>被注解的元素必须为一个数字，其值必须小于等于指定的最大值</td></tr><tr><td>@DecimalMin(Value)</td><td>被注解的元素必须为一个数字，其值必须大于等于指定的最小值</td></tr><tr><td>@Digits(integer=, fraction=)</td><td>被注解的元素必须为一个数字，其值必须在可接受的范围内</td></tr><tr><td>@Future</td><td>被注解的元素必须是日期，检查给定的日期是否比现在晚</td></tr><tr><td>@Max(value)</td><td>被注解的元素必须为一个数字，其值必须小于等于指定的最大值</td></tr><tr><td>@Min(value)</td><td>被注解的元素必须为一个数字，其值必须大于等于指定的最小值</td></tr><tr><td>@NotNull</td><td>被注解的元素必须不为null</td></tr><tr><td>@Null</td><td>被注解的元素必须为null</td></tr><tr><td>@Past(java.util.Date/Calendar)</td><td>被注解的元素必须过去的日期，检查标注对象中的值表示的日期比当前早</td></tr><tr><td>@Pattern(regex=, flag=)</td><td>被注解的元素必须符合正则表达式，检查该字符串是否能够在match指定的情况下被regex定义的正则表达式匹配</td></tr><tr><td>@Size(min=, max=)</td><td>被注解的元素必须在制定的范围(数据类型:String, Collection, Map and arrays)</td></tr><tr><td>@Valid</td><td>递归的对关联对象进行校验, 如果关联对象是个集合或者数组, 那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验</td></tr><tr><td>@CreditCardNumber</td><td>对信用卡号进行一个大致的验证</td></tr><tr><td>@Email</td><td>被注释的元素必须是电子邮箱地址</td></tr><tr><td>@Length(min=, max=)</td><td>被注解的对象必须是字符串的大小必须在制定的范围内</td></tr><tr><td>@NotBlank</td><td>被注解的对象必须为字符串，不能为空，检查时会将空格忽略</td></tr><tr><td>@NotEmpty</td><td>被注释的对象必须不为空(数据:String,Collection,Map,arrays)</td></tr><tr><td>@Range(min=, max=)</td><td>被注释的元素必须在合适的范围内 (数据：BigDecimal, BigInteger, String, byte, short, int, long and 原始类型的包装类 )</td></tr><tr><td>@URL(protocol=, host=, port=, regexp=, flags=)</td><td>被注解的对象必须是字符串，检查是否是一个有效的URL，如果提供了protocol，host等，则该URL还需满足提供的条件</td></tr><tr><td></td></tr></tbody></table><h1 id="Bean验证"><a href="#Bean验证" class="headerlink" title="Bean验证"></a>Bean验证</h1><p>首先向我们的bean中添加注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty</span>(message = <span class="string">"用户名不为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@NotEmpty</span>(message = <span class="string">"密码不为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// getter 和 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Controller</code>中配置:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">login</span><span class="params">(@Validated User user, Errors errors)</span> </span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResultUtil.messageResult(errors);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.SUCCESS_RESULT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要在要校验的bean前面添加<code>@Validated</code>，在需要校验的bean后面添加<code>Errors</code>对象来接收校验出错信息即可，然后根据错误信息进行判断和返回错误信息给前端。</p><p><strong>注意</strong>：<br><code>@Validated</code> 和 <code>Errors errors</code> 是成对出现的，并且形参顺序是固定的（一前一后）。也就是所每一个<code>@Validated</code>后面必须跟一个<code>Errors</code>，需要验证多个bean，后面就跟多个<code>Errors</code>。</p><h1 id="AOP处理Errors"><a href="#AOP处理Errors" class="headerlink" title="AOP处理Errors"></a>AOP处理Errors</h1><p>如果我们通过JSR来验证bean对象，那么在每个需要验证的方法中都需要处理Error对象，很容易想到可以通过AOP的方式来统一处理错误对象，并且组织错误信息，返回给前端。</p><p>通过一个环绕通知对所有的action方法尽心拦截，如果发现有Errors对象存在，就获取所有的错误信息，封装为一个list返回前端。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindingResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.Errors;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.ObjectError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李文浩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2017/10/8.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切点处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Errors errors = <span class="keyword">null</span>;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != args &amp;&amp; args.length != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object object : args) &#123;</span><br><span class="line">                <span class="keyword">if</span> (object <span class="keyword">instanceof</span> BindingResult) &#123;</span><br><span class="line">                    errors = (BindingResult) object;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (errors != <span class="keyword">null</span> &amp;&amp; errors.hasErrors()) &#123;</span><br><span class="line">            List&lt;ObjectError&gt; allErrors = errors.getAllErrors();</span><br><span class="line">            List&lt;String&gt; messages = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ObjectError error : allErrors) &#123;</span><br><span class="line">                messages.add(error.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ResultUtil.messageResult(messages);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"validationAdvice"</span> <span class="attr">class</span>=<span class="string">"studio.jikewang.util.ValidationAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"validation1"</span> <span class="attr">expression</span>=<span class="string">"execution(public * studio.jikewang.action.*.*(..))"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"validationAspect"</span> <span class="attr">ref</span>=<span class="string">"validationAdvice"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"aroundMethod"</span> <span class="attr">pointcut-ref</span>=<span class="string">"validation1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Validated-和-Valid"><a href="#Validated-和-Valid" class="headerlink" title="@Validated 和 @Valid"></a><code>@Validated</code> 和 <code>@Valid</code></h1><ul><li><code>@Valid</code>是使用Hibernate Validation的时候使用。<br>Java的JSR303声明了这类接口，然后hibernate－validator对其进行了实现。</li><li><code>@Validated</code>是只用Spring Validator校验机制使用。</li></ul><h1 id="方法参数验证"><a href="#方法参数验证" class="headerlink" title="方法参数验证"></a>方法参数验证</h1><p>Spring提供了<code>MethodValidationPostProcessor</code>类，用于对方法的校验。</p><p><code>Controller</code>中配置:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">login</span><span class="params">(@NotEmpty(message = <span class="string">"用户名不为空"</span>)</span> String username,</span></span><br><span class="line"><span class="function">                        @<span class="title">NotEmpty</span><span class="params">(message = <span class="string">"密码不为空"</span>)</span>  String password) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.SUCCESS_RESULT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml配置(<strong>最好是配置在<code>&lt;mvc:annotation-driven validator=&quot;validator&quot; /&gt;</code>上面，不然会有未知错误</strong>)如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>  <span class="attr">class</span>=<span class="string">"org.springframework.validation.beanvalidation.MethodValidationPostProcessor"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在校验遇到非法的参数时会抛出<code>ConstraintViolationException</code>，可以通过<code>getConstraintViolations</code>获得所有没有通过的校验<code>ConstraintViolation</code>集合，可以通过它们来获得对应的消息。</p><p>我们同样使用 <code>@ExceptionHandler</code> 捕捉<code>ConstraintViolationException</code>异常处理全局异常信息。</p><p>然后将所有的错误信息封装好返回给前端。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionHandler</span> </span>&#123;</span><br><span class="line">       <span class="meta">@ExceptionHandler</span>(ConstraintViolationException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">handleConstraintViolationException</span><span class="params">(ConstraintViolationException e)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ConstraintViolation&lt;?&gt; s : e.getConstraintViolations()) &#123;</span><br><span class="line">            System.out.println(s.getInvalidValue() + <span class="string">": "</span> + s.getMessage());</span><br><span class="line">            list.add(s.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        Result result = <span class="keyword">new</span> Result();</span><br><span class="line">        result.setStatus(<span class="string">"0"</span>);</span><br><span class="line">        result.setMessage(list);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用-Validated验证list"><a href="#使用-Validated验证list" class="headerlink" title="使用@Validated验证list"></a>使用<code>@Validated</code>验证list</h1><p>现在我遇到一个新的需求，我需要前端给我传递一个对象数组，于是我使用一个list去接收，但是无法获得验证信息。</p><p>于是将list重新包装一下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;E&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Controller</code>中配置:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">login</span><span class="params">(@Validated ValidList&lt;User&gt; users, Errors errors)</span> </span>&#123;</span><br><span class="line">        System.out.println(users.getList());</span><br><span class="line">        <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResultUtil.messageResult(errors);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.SUCCESS_RESULT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为了只返回第一个验证失败的信息(如果不更改，就会将所有的出错信息返回给前端)，更改<code>ValidationAdvice</code>如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切点处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="keyword">boolean</span> isValidList = <span class="keyword">false</span>;</span><br><span class="line">        Errors errors = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != args &amp;&amp; args.length != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object object : args) &#123;</span><br><span class="line">                <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ValidList) &#123;</span><br><span class="line">                    isValidList = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (object <span class="keyword">instanceof</span> BindingResult) &#123;</span><br><span class="line">                    errors = (BindingResult) object;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (errors != <span class="keyword">null</span> &amp;&amp; errors.hasErrors()) &#123;</span><br><span class="line">            List&lt;ObjectError&gt; allErrors = errors.getAllErrors();</span><br><span class="line">            List&lt;String&gt; messages = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ObjectError error : allErrors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isValidList) &#123;</span><br><span class="line">                    messages.add(error.getDefaultMessage());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    messages.add(error.getDefaultMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ResultUtil.messageResult(messages);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样即可验证<code>list</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>AOP的思想是贯穿我们的开发的，使用AOP的思想可以大大提高我们的开发效率，减少重复代码。</p><p><strong>参考文档</strong>：</p><ol><li><a href="http://www.jianshu.com/p/fc6c20af759a" target="_blank" rel="noopener">springmvc参数校验-JSR303(Bean Validation）</a></li><li><a href="http://www.cnblogs.com/beiyan/p/5946345.html" target="_blank" rel="noopener">Java Bean Validation 最佳实践</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是JSR303？&lt;/p&gt;
&lt;p&gt;JSR 303 – Bean Validation 是一个数据验证的规范，2009 年 11 月确定最终方案。&lt;br&gt;Hibernate Validator 是 Bean Validation 的最佳实践。&lt;/p&gt;
&lt;p&gt;为什么使用JSR，松耦合，让业务代码的职责更加清晰。&lt;/p&gt;
&lt;p&gt;松耦合就是职责更加清晰，每个人都有自己的职责，如果你的代码进行改动，我不用改动或者仅仅少量改动就可以发布和部署。&lt;br&gt;
    
    </summary>
    
      <category term="SpringMVC" scheme="https://www.morethink.cn/categories/SpringMVC/"/>
    
    
  </entry>
  
  <entry>
    <title>查询在一张表不在另外一张表的记录及效率探究</title>
    <link href="https://www.morethink.cn/records-in-a-table-but-not-in-another-table/"/>
    <id>https://www.morethink.cn/records-in-a-table-but-not-in-another-table/</id>
    <published>2017-11-15T16:00:00.000Z</published>
    <updated>2018-03-23T03:03:50.190Z</updated>
    
    <content type="html"><![CDATA[<p>在我做项目的时候遇到一个需求，要将存在于表ta而不存在于表tb中的数据查询出来。</p><p>记录使用的方法和探讨效率。</p><a id="more"></a><h1 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h1><p>创建表ta，并且使用存储过程插入13000条数据，在我的机器上运行时间: 346.719s。如果觉得插入的速度比较慢,可以直接导入我建好的表，百度云地址 <a href="http://pan.baidu.com/s/1dFtovg1" target="_blank" rel="noopener">http://pan.baidu.com/s/1dFtovg1</a> ，里面已经有数据了，直接导入sql执行即可，这样比用存储过程要快很多。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> ta;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`ta`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">13000</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> ta_insert;</span><br><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ta_insert()</span><br><span class="line"> MODIFIES <span class="keyword">SQL</span> <span class="keyword">DATA</span></span><br><span class="line"> <span class="keyword">BEGIN</span></span><br><span class="line"> <span class="keyword">SET</span> @i=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">SET</span> @<span class="keyword">max</span>=<span class="number">13000</span>;</span><br><span class="line"> WHILE @i&lt;@max DO</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`ta`</span> <span class="keyword">VALUES</span> ();</span><br><span class="line"> <span class="keyword">SET</span> @i = @i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"><span class="keyword">end</span> $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> ta_insert();</span><br></pre></td></tr></table></figure><p>创建表tb，并且使用存储过程插入10000条数据，在我的机器上运行时间:  224.102s。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> tb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">8000</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> tb_insert;</span><br><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> tb_insert()</span><br><span class="line"> MODIFIES <span class="keyword">SQL</span> <span class="keyword">DATA</span></span><br><span class="line"> <span class="keyword">BEGIN</span></span><br><span class="line"> <span class="keyword">SET</span> @i=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">SET</span> @<span class="keyword">max</span>=<span class="number">8000</span>;</span><br><span class="line"> WHILE @i&lt;@max DO</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`tb`</span> <span class="keyword">VALUES</span> ();</span><br><span class="line"> <span class="keyword">SET</span> @i = @i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"><span class="keyword">end</span> $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> tb_insert();</span><br></pre></td></tr></table></figure><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>使用<code>NOT IN</code>，ta表中的每一个id值都要去与tb表中的id匹配，匹配到就停止，也就是说，存在于ta表而不存在于tb表的id值需要与所有tb表中的id值进行匹配。</p><p>执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。</p><p>平均时间为 0.04s。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ta.id <span class="keyword">FROM</span> ta <span class="keyword">WHERE</span> ta.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> tb)</span><br></pre></td></tr></table></figure></p><h1 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h1><p>使用 <code>LEFT JOIN</code>，ta表左连接tb表，而存在于ta表不存在于tb表中的字段为<code>NULL</code>，于是我们可以通过判断<code>WHERE tb.id IS NULL</code>来找到存在于ta表而不存在于tb表的id值。</p><p>平均时间是 0.06s。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ta.id <span class="keyword">FROM</span> ta <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tb <span class="keyword">ON</span> ta.id = tb.id <span class="keyword">WHERE</span> tb.id <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure></p><h1 id="效率之谜"><a href="#效率之谜" class="headerlink" title="效率之谜"></a>效率之谜</h1><h2 id="版本问题？"><a href="#版本问题？" class="headerlink" title="版本问题？"></a>版本问题？</h2><p>按理来说，连接应该比子查询要快，但是在我进行试验的时候发现却不是这样的，子查询居然还比连接要快。</p><p><img src="https://images.morethink.cn/20ef641be3a9a9aa899e5e373e05eef9.png" alt="" title="疑惑"></p><p>搜索了解到</p><blockquote><p>对于类似NOT IN这样的子查询，也能受益于subquery materialize，将子查询的结果集cache到临时表里，使用hashindex来进行检索；物化的子查询可以看到select_type字段为SUBQUERY，而在MySQL5.5里为DEPENDENT SUBQUERY</p></blockquote><p>可能是版本原因，我用的是mysql5.7，可能做了优化。</p><p>于是使用mysql5.5再次测试。</p><p>发现子查询和左连接的查询时间都在0.12s附近，还是不能说明连接比子查询高效。进一步猜测，我的数据组织格式是否出现了问题，于是使用上面百度云盘连接中的mm_member表和mm_log表(这是 <a href="https://www.cnblogs.com/cdf-opensource-007/p/6540521.html" target="_blank" rel="noopener">mysql（4）—— 表连接查询与where后使用子查询的性能分析。</a> 提供的数据) 。</p><h2 id="猜测验证"><a href="#猜测验证" class="headerlink" title="猜测验证"></a>猜测验证</h2><p><strong>子查询</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> mm_member.id <span class="keyword">FROM</span> mm_member <span class="keyword">WHERE</span> mm_member.id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> mm_log.member_id <span class="keyword">FROM</span> mm_log)</span><br></pre></td></tr></table></figure><p><strong>左连接</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> mm_member.id <span class="keyword">FROM</span> mm_member <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> mm_log.member_id <span class="keyword">FROM</span> mm_log ) <span class="keyword">AS</span> mm</span><br><span class="line"><span class="keyword">ON</span> mm.member_id = mm_member.id <span class="keyword">WHERE</span> mm.member_id <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p><strong>mysql5.7</strong></p><p>子查询为1.1s左右，左连接为1.55s，子查询依然速度较快。</p><p><strong>mysql5.5</strong></p><p>子查询为48s左右，左连接为1.4s，将近34倍的差距，由此印证上面引用的那部分，<strong>mysql5.7确实已经多子查询做了优化，使其达到了逼近左连接的效率</strong>。</p><p><strong>那为什么我自己所建立的表无法体现版本的这种性能差别？</strong></p><p>猜测应该是数据类型的原因，可能int类型的查询效率已经都优化好了。</p><h1 id="网传最高效"><a href="#网传最高效" class="headerlink" title="网传最高效"></a>网传最高效</h1><p>不太清楚其中的原理，并且在我的测试中性能跟连接差不多。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> ta <span class="keyword">WHERE</span> (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">AS</span> <span class="keyword">num</span> <span class="keyword">FROM</span> tb <span class="keyword">WHERE</span> ta.id = tb.id) = <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>而且网上流传的版本(<a href="http://blog.csdn.net/windren06/article/details/8188136" target="_blank" rel="noopener">(数据库篇) SQL查询~ 存在一个表而不在另一个表中的数据</a>)为</p><p>select <em> from B where (select count(1) as num from A where A.ID = B.ID) = 0<br>应该是<br>select </em> from A where (select count(1) as num from  B where A.ID = B.ID) = 0<br>大表在前，小表在后。</p></blockquote><p><strong>注意</strong>：</p><ol><li>存储过程循环插入比普通方式插入数据慢很多倍。</li><li>索引可以有效提高搜索效率。</li><li>不是所有的子查询都比连接慢的。</li></ol><p><strong>参考文档</strong>：</p><ol><li><a href="http://mysqllover.com/?p=919" target="_blank" rel="noopener">MySQL 5.6的优化器改进</a></li><li><a href="https://www.cnblogs.com/cdf-opensource-007/p/6540521.html" target="_blank" rel="noopener">mysql（4）—— 表连接查询与where后使用子查询的性能分析。</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我做项目的时候遇到一个需求，要将存在于表ta而不存在于表tb中的数据查询出来。&lt;/p&gt;
&lt;p&gt;记录使用的方法和探讨效率。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://www.morethink.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://www.morethink.cn/tags/MySQL/"/>
    
  </entry>
  
</feed>
